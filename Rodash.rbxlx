<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Workspace" referent="11">
		<Properties>
			<bool name="AllowThirdPartySales">false</bool>
			<string name="CollisionGroups">Default^0^1</string>
			<Ref name="CurrentCamera">RBXf9ad0589e20940158c0001145d47e1b2</Ref>
			<double name="DistributedGameTime">0</double>
			<bool name="ExplicitAutoJoints">true</bool>
			<float name="FallenPartsDestroyHeight">-500</float>
			<bool name="FilteringEnabled">true</bool>
			<float name="Gravity">196.199997</float>
			<CoordinateFrame name="ModelInPrimary">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<string name="Name">Workspace</string>
			<Ref name="PrimaryPart">null</Ref>
			<bool name="StreamingEnabled">false</bool>
			<int name="StreamingMinRadius">64</int>
			<token name="StreamingPauseMode">0</token>
			<int name="StreamingTargetRadius">1024</int>
			<BinaryString name="Tags"></BinaryString>
			<bool name="TemporaryLegacyPhysicsSolverOverrideStreaming">false</bool>
			<bool name="TerrainWeldsFixed">true</bool>
		</Properties>
		<Item class="Camera" referent="RBXf9ad0589e20940158c0001145d47e1b2">
			<Properties>
				<CoordinateFrame name="CFrame">
					<X>150.158936</X>
					<Y>69.1109314</Y>
					<Z>111.396156</Z>
					<R00>0.783709109</R00>
					<R01>-0.367723465</R01>
					<R02>0.500579298</R02>
					<R10>-1.4901163e-08</R10>
					<R11>0.805919528</R11>
					<R12>0.592025101</R12>
					<R20>-0.621128142</R20>
					<R21>-0.463975459</R21>
					<R22>0.6316064</R22>
				</CoordinateFrame>
				<Ref name="CameraSubject">null</Ref>
				<token name="CameraType">0</token>
				<float name="FieldOfView">70</float>
				<CoordinateFrame name="Focus">
					<X>149.157776</X>
					<Y>67.9268799</Y>
					<Z>110.132942</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="HeadLocked">true</bool>
				<float name="HeadScale">1</float>
				<string name="Name">Camera</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="Part" referent="12">
			<Properties>
				<bool name="Anchored">true</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>-10</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CastShadow">true</bool>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4284636770</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<string name="Name">Baseplate</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>512</X>
					<Y>20</Y>
					<Z>512</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="Terrain" referent="RBX81d01e24af724894a3af34d8d7afc73f">
			<Properties>
				<bool name="Anchored">true</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CastShadow">true</bool>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<BinaryString name="MaterialColors"><![CDATA[AAAAAAAAan8/P39rf2Y/ilY+j35fi21PZmxvZbDqw8faiVpHOi4kHh4lZlw76JxKc3trhHta
gcLgc4RKxr21zq2UlJSM]]></BinaryString>
				<string name="Name">Terrain</string>
				<BinaryString name="PhysicsGrid">AgMAAAAAAAAAAAAAAAA=</BinaryString>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<BinaryString name="SmoothGrid">AQU=</BinaryString>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<Color3 name="WaterColor">
					<R>0.0500000007</R>
					<G>0.330000013</G>
					<B>0.360000014</B>
				</Color3>
				<float name="WaterReflectance">1</float>
				<float name="WaterTransparency">0.300000012</float>
				<float name="WaterWaveSize">0.150000006</float>
				<float name="WaterWaveSpeed">10</float>
				<Vector3 name="size">
					<X>2044</X>
					<Y>252</Y>
					<Z>2044</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="SpotLight" referent="RBX83711e01f88f41f5bb62af0b23eb04ce">
			<Properties>
				<float name="Angle">90</float>
				<float name="Brightness">1</float>
				<Color3 name="Color">
					<R>1</R>
					<G>1</G>
					<B>1</B>
				</Color3>
				<bool name="Enabled">true</bool>
				<token name="Face">5</token>
				<string name="Name">SpotLight</string>
				<float name="Range">16</float>
				<bool name="Shadows">false</bool>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
	</Item>
	<Item class="SoundService" referent="10">
		<Properties>
			<token name="AmbientReverb">0</token>
			<float name="DistanceFactor">3.32999992</float>
			<float name="DopplerScale">1</float>
			<string name="Name">SoundService</string>
			<bool name="RespectFilteringEnabled">true</bool>
			<float name="RolloffScale">1</float>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="NonReplicatedCSGDictionaryService" referent="RBX4a152d12569044288493d9dbd50ed1f4">
		<Properties>
			<string name="Name">NonReplicatedCSGDictionaryService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="CSGDictionaryService" referent="RBX1e0bb66ff87e4316ba28598e719185bf">
		<Properties>
			<string name="Name">CSGDictionaryService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Chat" referent="RBX1842c445827341c099ab50a268bc84d7">
		<Properties>
			<bool name="BubbleChatEnabled">false</bool>
			<bool name="LoadDefaultChat">true</bool>
			<string name="Name">Chat</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="TimerService" referent="RBX4e3a7fc68ccf4ef28daa58dc81fd96dd">
		<Properties>
			<string name="Name">Instance</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Players" referent="RBX9254d3ce345e4dc49e00402c89670673">
		<Properties>
			<bool name="CharacterAutoLoads">true</bool>
			<int name="MaxPlayersInternal">12</int>
			<string name="Name">Players</string>
			<int name="PreferredPlayersInternal">0</int>
			<float name="RespawnTime">5</float>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ReplicatedFirst" referent="RBX9a678e4001e94bcb8620fadbaa058dda">
		<Properties>
			<string name="Name">ReplicatedFirst</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="TweenService" referent="RBXd8843bd3ac8e46f18125448449af4ef8">
		<Properties>
			<string name="Name">TweenService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="StarterPlayer" referent="RBX3ed84b233b2b4056843a8684661cf4fb">
		<Properties>
			<bool name="AllowCustomAnimations">true</bool>
			<bool name="AutoJumpEnabled">true</bool>
			<float name="CameraMaxZoomDistance">400</float>
			<float name="CameraMinZoomDistance">0.5</float>
			<token name="CameraMode">0</token>
			<float name="CharacterJumpHeight">7.19999981</float>
			<float name="CharacterJumpPower">50</float>
			<float name="CharacterMaxSlopeAngle">89</float>
			<bool name="CharacterUseJumpPower">true</bool>
			<float name="CharacterWalkSpeed">16</float>
			<token name="DevCameraOcclusionMode">0</token>
			<token name="DevComputerCameraMovementMode">0</token>
			<token name="DevComputerMovementMode">0</token>
			<token name="DevTouchCameraMovementMode">0</token>
			<token name="DevTouchMovementMode">0</token>
			<bool name="EnableMouseLockOption">true</bool>
			<int64 name="GameSettingsAssetIDFace">0</int64>
			<int64 name="GameSettingsAssetIDHead">0</int64>
			<int64 name="GameSettingsAssetIDLeftArm">0</int64>
			<int64 name="GameSettingsAssetIDLeftLeg">0</int64>
			<int64 name="GameSettingsAssetIDPants">0</int64>
			<int64 name="GameSettingsAssetIDRightArm">0</int64>
			<int64 name="GameSettingsAssetIDRightLeg">0</int64>
			<int64 name="GameSettingsAssetIDShirt">0</int64>
			<int64 name="GameSettingsAssetIDTeeShirt">0</int64>
			<int64 name="GameSettingsAssetIDTorso">0</int64>
			<token name="GameSettingsAvatar">1</token>
			<token name="GameSettingsR15Collision">0</token>
			<NumberRange name="GameSettingsScaleRangeBodyType">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHead">0.95 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHeight">0.9 1.05 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeProportion">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeWidth">0.7 1 </NumberRange>
			<float name="HealthDisplayDistance">100</float>
			<bool name="LoadCharacterAppearance">true</bool>
			<string name="Name">StarterPlayer</string>
			<float name="NameDisplayDistance">100</float>
			<BinaryString name="Tags"></BinaryString>
			<bool name="UserEmotesEnabled">true</bool>
		</Properties>
		<Item class="StarterPlayerScripts" referent="RBX9fc122f1a7144e37bb8486deee082b98">
			<Properties>
				<string name="Name">StarterPlayerScripts</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="StarterCharacterScripts" referent="RBXf6edd46fc6134e2082a7f482f71621dc">
			<Properties>
				<string name="Name">StarterCharacterScripts</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
	</Item>
	<Item class="StarterPack" referent="RBX582ddda2eaac48118ecf8eb2e6a29ca9">
		<Properties>
			<string name="Name">StarterPack</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="StarterGui" referent="RBX16b09d9fa70645a0b690876516ddf31d">
		<Properties>
			<string name="Name">StarterGui</string>
			<bool name="ResetPlayerGuiOnSpawn">true</bool>
			<token name="ScreenOrientation">2</token>
			<bool name="ShowDevelopmentGui">true</bool>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="LocalizationService" referent="RBX25da5889bf384d67b2b62c3c83e20111">
		<Properties>
			<string name="Name">LocalizationService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="TeleportService" referent="RBX366f335e7b2945e79ad8ee3a3befb2d1">
		<Properties>
			<string name="Name">Teleport Service</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="CollectionService" referent="RBX95529ec16f8049009ba1b73d3bffb9b1">
		<Properties>
			<string name="Name">CollectionService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="PhysicsService" referent="RBX212542c76d2c4584be4d962f05f7ec5f">
		<Properties>
			<string name="Name">PhysicsService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Geometry" referent="RBXbf7d65b61ec845b98118fe74470c7634">
		<Properties>
			<string name="Name">Geometry</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="InsertService" referent="RBXae1fec54f96740e09661ada47a2178bf">
		<Properties>
			<bool name="AllowClientInsertModels">false</bool>
			<bool name="AllowInsertFreeModels">false</bool>
			<string name="Name">InsertService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="GamePassService" referent="RBX79cde0b0363a4796a00f05c1c90c4301">
		<Properties>
			<string name="Name">GamePassService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Debris" referent="RBX483a5fcc8ddc4f919d6ad2957826be37">
		<Properties>
			<int name="MaxItems">1000</int>
			<string name="Name">Debris</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="CookiesService" referent="RBX8c624345d8cd4cf3b27769b5985a91a8">
		<Properties>
			<string name="Name">CookiesService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="VRService" referent="RBX30077c3dd1884c57b8dc8e0eda327e0e">
		<Properties>
			<string name="Name">VRService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ContextActionService" referent="RBX226bdc3cd15645f28ebcbc196909d007">
		<Properties>
			<string name="Name">ContextActionService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ScriptService" referent="RBX7926baee0db44ae4b918bf4199932dc3">
		<Properties>
			<string name="Name">Instance</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="AssetService" referent="RBX93e86bca1b144a55a13ac689e2b0966e">
		<Properties>
			<string name="Name">AssetService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="TouchInputService" referent="RBX76c98482ff4a493bbac5330eb86e85e0">
		<Properties>
			<string name="Name">TouchInputService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Selection" referent="RBX928b74987ccc40ed94b97e567c766edc">
		<Properties>
			<string name="Name">Selection</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ServerScriptService" referent="RBX8ac2bfc6f02a40a5b2e5a846d3e066b0">
		<Properties>
			<bool name="LoadStringEnabled">false</bool>
			<string name="Name">ServerScriptService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Script" referent="RBX52147180fbdb4c528244e7fd95ba0a7a">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Example</string>
				<string name="ScriptGuid">{c2891012-18d5-4b2b-baa7-11f8ecce21c3}</string>
				<ProtectedString name="Source"><![CDATA[print("Examples of using Rodash in your project:")

local dash = require(game.ReplicatedStorage.Rodash)
local fn = dash.fn

dash.setInterval(function()
	local getNames = fn:map(fn:get("Name"))
	local playerNames = getNames(game.Players:GetChildren())
	print(dash.format("Players online ({#1}): {:#?}", playerNames))
end, 1)

print(dash.encodeUrlComponent("https://example.com/Egg+Fried Rice!?🤷🏼‍♀️"))]]></ProtectedString>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
	</Item>
	<Item class="ServerStorage" referent="RBXf7ff40b888c744759516d09d30494414">
		<Properties>
			<string name="Name">ServerStorage</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ReplicatedStorage" referent="2">
		<Properties>
			<string name="Name">ReplicatedStorage</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="ModuleScript" referent="RBX517662dc9cc740948fd12811110a6271">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Promise</string>
				<string name="ScriptGuid">{bb5512ad-1130-4c98-92e8-c04f2234c224}</string>
				<ProtectedString name="Source"><![CDATA[--[[
	An implementation of Promises similar to Promise/A+.
]]

local PROMISE_DEBUG = false

--[[
	Packs a number of arguments into a table and returns its length.

	Used to cajole varargs without dropping sparse values.
]]
local function pack(...)
	local len = select("#", ...)

	return len, { ... }
end

--[[
	wpcallPacked is a version of xpcall that:
	* Returns the length of the result first
	* Returns the result packed into a table
	* Passes extra arguments through to the passed function; xpcall doesn't
	* Issues a warning if PROMISE_DEBUG is enabled
]]
local function wpcallPacked(f, ...)
	local argsLength, args = pack(...)

	local body = function()
		return f(unpack(args, 1, argsLength))
	end

	local resultLength, result = pack(xpcall(body, debug.traceback))

	-- If promise debugging is on, warn whenever a pcall fails.
	-- This is useful for debugging issues within the Promise implementation
	-- itself.
	if PROMISE_DEBUG and not result[1] then
		warn(result[2])
	end

	return resultLength, result
end

--[[
	Creates a function that invokes a callback with correct error handling and
	resolution mechanisms.
]]
local function createAdvancer(callback, resolve, reject)
	return function(...)
		local resultLength, result = wpcallPacked(callback, ...)
		local ok = result[1]

		if ok then
			resolve(unpack(result, 2, resultLength))
		else
			reject(unpack(result, 2, resultLength))
		end
	end
end

local function isEmpty(t)
	return next(t) == nil
end

local function createSymbol(name)
	assert(type(name) == "string", "createSymbol requires `name` to be a string.")

	local symbol = newproxy(true)

	getmetatable(symbol).__tostring = function()
		return ("Symbol(%s)"):format(name)
	end

	return symbol
end

local PromiseMarker = createSymbol("PromiseMarker")

local Promise = {}
Promise.prototype = {}
Promise.__index = Promise.prototype

Promise.Status = {
	Started = createSymbol("Started"),
	Resolved = createSymbol("Resolved"),
	Rejected = createSymbol("Rejected"),
}

--[[
	Constructs a new Promise with the given initializing callback.

	This is generally only called when directly wrapping a non-promise API into
	a promise-based version.

	The callback will receive 'resolve' and 'reject' methods, used to start
	invoking the promise chain.

	For example:

		local function get(url)
			return Promise.new(function(resolve, reject)
				spawn(function()
					resolve(HttpService:GetAsync(url))
				end)
			end)
		end

		get("https://google.com")
			:andThen(function(stuff)
				print("Got some stuff!", stuff)
			end)
]]
function Promise.new(callback)
	local self = {
		-- Used to locate where a promise was created
		_source = debug.traceback(),

		-- A tag to identify us as a promise
		[PromiseMarker] = true,

		_status = Promise.Status.Started,

		-- A table containing a list of all results, whether success or failure.
		-- Only valid if _status is set to something besides Started
		_values = nil,

		-- Lua doesn't like sparse arrays very much, so we explicitly store the
		-- length of _values to handle middle nils.
		_valuesLength = -1,

		-- If an error occurs with no observers, this will be set.
		_unhandledRejection = false,

		-- Queues representing functions we should invoke when we update!
		_queuedResolve = {},
		_queuedReject = {},
	}

	setmetatable(self, Promise)

	local function resolve(...)
		self:_resolve(...)
	end

	local function reject(...)
		self:_reject(...)
	end

	local _, result = wpcallPacked(callback, resolve, reject)
	local ok = result[1]
	local err = result[2]

	if not ok and self._status == Promise.Status.Started then
		reject(err)
	end

	return self
end

--[[
	Create a promise that represents the immediately resolved value.
]]
function Promise.resolve(value)
	return Promise.new(function(resolve)
		resolve(value)
	end)
end

--[[
	Create a promise that represents the immediately rejected value.
]]
function Promise.reject(value)
	return Promise.new(function(_, reject)
		reject(value)
	end)
end

--[[
	Returns a new promise that:
		* is resolved when all input promises resolve
		* is rejected if ANY input promises reject
]]
function Promise.all(promises)
	if type(promises) ~= "table" then
		error("Please pass a list of promises to Promise.all", 2)
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 then
		return Promise.resolve({})
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i = 1, #promises do
		if not Promise.is(promises[i]) then
			error(("Non-promise value passed into Promise.all at index #%d"):format(i), 2)
		end
	end

	return Promise.new(function(resolve, reject)
		-- An array to contain our resolved values from the given promises.
		local resolvedValues = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local resolvedCount = 0

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			resolvedValues[i] = ...
			resolvedCount = resolvedCount + 1

			if resolvedCount == #promises then
				resolve(resolvedValues)
			end
		end

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i = 1, #promises do
			promises[i]:andThen(
				function(...)
					resolveOne(i, ...)
				end,
				function(...)
					reject(...)
				end
			)
		end
	end)
end

--[[
	Is the given object a Promise instance?
]]
function Promise.is(object)
	if type(object) ~= "table" then
		return false
	end

	return object[PromiseMarker] == true
end

function Promise.prototype:getStatus()
	return self._status
end

--[[
	Creates a new promise that receives the result of this promise.

	The given callbacks are invoked depending on that result.
]]
function Promise.prototype:andThen(successHandler, failureHandler)
	self._unhandledRejection = false

	-- Create a new promise to follow this part of the chain
	return Promise.new(function(resolve, reject)
		-- Our default callbacks just pass values onto the next promise.
		-- This lets success and failure cascade correctly!

		local successCallback = resolve
		if successHandler then
			successCallback = createAdvancer(successHandler, resolve, reject)
		end

		local failureCallback = reject
		if failureHandler then
			failureCallback = createAdvancer(failureHandler, resolve, reject)
		end

		if self._status == Promise.Status.Started then
			-- If we haven't resolved yet, put ourselves into the queue
			table.insert(self._queuedResolve, successCallback)
			table.insert(self._queuedReject, failureCallback)
		elseif self._status == Promise.Status.Resolved then
			-- This promise has already resolved! Trigger success immediately.
			successCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Rejected then
			-- This promise died a terrible death! Trigger failure immediately.
			failureCallback(unpack(self._values, 1, self._valuesLength))
		end
	end)
end

--[[
	Used to catch any errors that may have occurred in the promise.
]]
function Promise.prototype:catch(failureCallback)
	return self:andThen(nil, failureCallback)
end

--[[
	Yield until the promise is completed.

	This matches the execution model of normal Roblox functions.
]]
function Promise.prototype:await()
	self._unhandledRejection = false

	if self._status == Promise.Status.Started then
		local result
		local resultLength
		local bindable = Instance.new("BindableEvent")

		self:andThen(
			function(...)
				resultLength, result = pack(...)
				bindable:Fire(true)
			end,
			function(...)
				resultLength, result = pack(...)
				bindable:Fire(false)
			end
		)

		local ok = bindable.Event:Wait()
		bindable:Destroy()

		return ok, unpack(result, 1, resultLength)
	elseif self._status == Promise.Status.Resolved then
		return true, unpack(self._values, 1, self._valuesLength)
	elseif self._status == Promise.Status.Rejected then
		return false, unpack(self._values, 1, self._valuesLength)
	end
end

--[[
	Intended for use in tests.

	Similar to await(), but instead of yielding if the promise is unresolved,
	_unwrap will throw. This indicates an assumption that a promise has
	resolved.
]]
function Promise.prototype:_unwrap()
	if self._status == Promise.Status.Started then
		error("Promise has not resolved or rejected.", 2)
	end

	local success = self._status == Promise.Status.Resolved

	return success, unpack(self._values, 1, self._valuesLength)
end

function Promise.prototype:_resolve(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	-- If the resolved value was a Promise, we chain onto it!
	if Promise.is((...)) then
		-- Without this warning, arguments sometimes mysteriously disappear
		if select("#", ...) > 1 then
			local message = (
				"When returning a Promise from andThen, extra arguments are " ..
				"discarded! See:\n\n%s"
			):format(
				self._source
			)
			warn(message)
		end

		(...):andThen(
			function(...)
				self:_resolve(...)
			end,
			function(...)
				self:_reject(...)
			end
		)

		return
	end

	self._status = Promise.Status.Resolved
	self._valuesLength, self._values = pack(...)

	-- We assume that these callbacks will not throw errors.
	for _, callback in ipairs(self._queuedResolve) do
		callback(...)
	end
end

function Promise.prototype:_reject(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Rejected
	self._valuesLength, self._values = pack(...)

	-- If there are any rejection handlers, call those!
	if not isEmpty(self._queuedReject) then
		-- We assume that these callbacks will not throw errors.
		for _, callback in ipairs(self._queuedReject) do
			callback(...)
		end
	else
		-- At this point, no one was able to observe the error.
		-- An error handler might still be attached if the error occurred
		-- synchronously. We'll wait one tick, and if there are still no
		-- observers, then we should put a message in the console.

		self._unhandledRejection = true
		local err = tostring((...))

		spawn(function()
			-- Someone observed the error, hooray!
			if not self._unhandledRejection then
				return
			end

			-- Build a reasonable message
			local message = ("Unhandled promise rejection:\n\n%s\n\n%s"):format(
				err,
				self._source
			)
			warn(message)
		end)
	end
end

return Promise]]></ProtectedString>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBXed431ae1bf934c78b9a2daabe0637f75">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">init.spec</string>
					<string name="ScriptGuid">{fbff2b8f-5992-4b82-b6dd-b9a014eb186f}</string>
					<ProtectedString name="Source"><![CDATA[return function()
	local Promise = require(script.Parent)

	local function pack(...)
		local len = select("#", ...)

		return len, { ... }
	end

	describe("Promise.new", function()
		it("should instantiate with a callback", function()
			local promise = Promise.new(function() end)

			expect(promise).to.be.ok()
		end)

		it("should invoke the given callback with resolve and reject", function()
			local callCount = 0
			local resolveArg
			local rejectArg

			local promise = Promise.new(function(resolve, reject)
				callCount = callCount + 1
				resolveArg = resolve
				rejectArg = reject
			end)

			expect(promise).to.be.ok()

			expect(callCount).to.equal(1)
			expect(resolveArg).to.be.a("function")
			expect(rejectArg).to.be.a("function")
			expect(promise:getStatus()).to.equal(Promise.Status.Started)
		end)

		it("should resolve promises on resolve()", function()
			local callCount = 0

			local promise = Promise.new(function(resolve)
				callCount = callCount + 1
				resolve()
			end)

			expect(promise).to.be.ok()
			expect(callCount).to.equal(1)
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
		end)

		it("should reject promises on reject()", function()
			local callCount = 0

			local promise = Promise.new(function(resolve, reject)
				callCount = callCount + 1
				reject()
			end)

			expect(promise).to.be.ok()
			expect(callCount).to.equal(1)
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
		end)

		it("should reject on error in callback", function()
			local callCount = 0

			local promise = Promise.new(function()
				callCount = callCount + 1
				error("hahah")
			end)

			expect(promise).to.be.ok()
			expect(callCount).to.equal(1)
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]:find("hahah")).to.be.ok()

			-- Loosely check for the pieces of the stack trace we expect
			expect(promise._values[1]:find("init.spec")).to.be.ok()
			expect(promise._values[1]:find("new")).to.be.ok()
			expect(promise._values[1]:find("error")).to.be.ok()
		end)
	end)

	describe("Promise.resolve", function()
		it("should immediately resolve with a value", function()
			local promise = Promise.resolve(5)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1]).to.equal(5)
		end)

		it("should chain onto passed promises", function()
			local promise = Promise.resolve(Promise.new(function(_, reject)
				reject(7)
			end))

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]).to.equal(7)
		end)
	end)

	describe("Promise.reject", function()
		it("should immediately reject with a value", function()
			local promise = Promise.reject(6)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]).to.equal(6)
		end)

		it("should pass a promise as-is as an error", function()
			local innerPromise = Promise.new(function(resolve)
				resolve(6)
			end)

			local promise = Promise.reject(innerPromise)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]).to.equal(innerPromise)
		end)
	end)

	describe("Promise:andThen", function()
		it("should chain onto resolved promises", function()
			local args
			local argsLength
			local callCount = 0
			local badCallCount = 0

			local promise = Promise.resolve(5)

			local chained = promise:andThen(
				function(...)
					argsLength, args = pack(...)
					callCount = callCount + 1
				end,
				function()
					badCallCount = badCallCount + 1
				end
			)

			expect(badCallCount).to.equal(0)

			expect(callCount).to.equal(1)
			expect(argsLength).to.equal(1)
			expect(args[1]).to.equal(5)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1]).to.equal(5)

			expect(chained).to.be.ok()
			expect(chained).never.to.equal(promise)
			expect(chained:getStatus()).to.equal(Promise.Status.Resolved)
			expect(#chained._values).to.equal(0)
		end)

		it("should chain onto rejected promises", function()
			local args
			local argsLength
			local callCount = 0
			local badCallCount = 0

			local promise = Promise.reject(5)

			local chained = promise:andThen(
				function(...)
					badCallCount = badCallCount + 1
				end,
				function(...)
					argsLength, args = pack(...)
					callCount = callCount + 1
				end
			)

			expect(badCallCount).to.equal(0)

			expect(callCount).to.equal(1)
			expect(argsLength).to.equal(1)
			expect(args[1]).to.equal(5)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]).to.equal(5)

			expect(chained).to.be.ok()
			expect(chained).never.to.equal(promise)
			expect(chained:getStatus()).to.equal(Promise.Status.Resolved)
			expect(#chained._values).to.equal(0)
		end)

		it("should chain onto asynchronously resolved promises", function()
			local args
			local argsLength
			local callCount = 0
			local badCallCount = 0

			local startResolution
			local promise = Promise.new(function(resolve)
				startResolution = resolve
			end)

			local chained = promise:andThen(
				function(...)
					args = {...}
					argsLength = select("#", ...)
					callCount = callCount + 1
				end,
				function()
					badCallCount = badCallCount + 1
				end
			)

			expect(callCount).to.equal(0)
			expect(badCallCount).to.equal(0)

			startResolution(6)

			expect(badCallCount).to.equal(0)

			expect(callCount).to.equal(1)
			expect(argsLength).to.equal(1)
			expect(args[1]).to.equal(6)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1]).to.equal(6)

			expect(chained).to.be.ok()
			expect(chained).never.to.equal(promise)
			expect(chained:getStatus()).to.equal(Promise.Status.Resolved)
			expect(#chained._values).to.equal(0)
		end)

		it("should chain onto asynchronously rejected promises", function()
			local args
			local argsLength
			local callCount = 0
			local badCallCount = 0

			local startResolution
			local promise = Promise.new(function(_, reject)
				startResolution = reject
			end)

			local chained = promise:andThen(
				function()
					badCallCount = badCallCount + 1
				end,
				function(...)
					args = {...}
					argsLength = select("#", ...)
					callCount = callCount + 1
				end
			)

			expect(callCount).to.equal(0)
			expect(badCallCount).to.equal(0)

			startResolution(6)

			expect(badCallCount).to.equal(0)

			expect(callCount).to.equal(1)
			expect(argsLength).to.equal(1)
			expect(args[1]).to.equal(6)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]).to.equal(6)

			expect(chained).to.be.ok()
			expect(chained).never.to.equal(promise)
			expect(chained:getStatus()).to.equal(Promise.Status.Resolved)
			expect(#chained._values).to.equal(0)
		end)
	end)

	describe("Promise.all", function()
		it("should error if given something other than a table", function()
			expect(function()
				Promise.all(1)
			end).to.throw()
		end)

		it("should resolve instantly with an empty table if given no promises", function()
			local promise = Promise.all({})
			local success, value = promise:_unwrap()

			expect(success).to.equal(true)
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(value).to.be.a("table")
			expect(next(value)).to.equal(nil)
		end)

		it("should error if given non-promise values", function()
			expect(function()
				Promise.all({{}, {}, {}})
			end).to.throw()
		end)

		it("should wait for all promises to be resolved and return their values", function()
			local resolveFunctions = {}

			local testValuesLength, testValues = pack(1, "A string", nil, false)

			local promises = {}

			for i = 1, testValuesLength do
				promises[i] = Promise.new(function(resolve)
					resolveFunctions[i] = {resolve, testValues[i]}
				end)
			end

			local combinedPromise = Promise.all(promises)

			for _, resolve in ipairs(resolveFunctions) do
				expect(combinedPromise:getStatus()).to.equal(Promise.Status.Started)
				resolve[1](resolve[2])
			end

			local resultLength, result = pack(combinedPromise:_unwrap())
			local success, resolved = unpack(result, 1, resultLength)

			expect(resultLength).to.equal(2)
			expect(success).to.equal(true)
			expect(resolved).to.be.a("table")
			expect(#resolved).to.equal(#promises)

			for i = 1, testValuesLength do
				expect(resolved[i]).to.equal(testValues[i])
			end
		end)

		it("should reject if any individual promise rejected", function()
			local rejectA
			local resolveB

			local a = Promise.new(function(_, reject)
				rejectA = reject
			end)

			local b = Promise.new(function(resolve)
				resolveB = resolve
			end)

			local combinedPromise = Promise.all({a, b})

			expect(combinedPromise:getStatus()).to.equal(Promise.Status.Started)

			resolveB("foo", "bar")
			rejectA("baz", "qux")

			local resultLength, result = pack(combinedPromise:_unwrap())
			local success, first, second = unpack(result, 1, resultLength)

			expect(resultLength).to.equal(3)
			expect(success).to.equal(false)
			expect(first).to.equal("baz")
			expect(second).to.equal("qux")
		end)

		it("should not resolve if resolved after rejecting", function()
			local rejectA
			local resolveB

			local a = Promise.new(function(_, reject)
				rejectA = reject
			end)

			local b = Promise.new(function(resolve)
				resolveB = resolve
			end)

			local combinedPromise = Promise.all({a, b})

			expect(combinedPromise:getStatus()).to.equal(Promise.Status.Started)

			rejectA("baz", "qux")
			resolveB("foo", "bar")

			local resultLength, result = pack(combinedPromise:_unwrap())
			local success, first, second = unpack(result, 1, resultLength)

			expect(resultLength).to.equal(3)
			expect(success).to.equal(false)
			expect(first).to.equal("baz")
			expect(second).to.equal("qux")
		end)

		it("should only reject once", function()
			local rejectA
			local rejectB

			local a = Promise.new(function(_, reject)
				rejectA = reject
			end)

			local b = Promise.new(function(_, reject)
				rejectB = reject
			end)

			local combinedPromise = Promise.all({a, b})

			expect(combinedPromise:getStatus()).to.equal(Promise.Status.Started)

			rejectA("foo", "bar")

			expect(combinedPromise:getStatus()).to.equal(Promise.Status.Rejected)

			rejectB("baz", "qux")

			local resultLength, result = pack(combinedPromise:_unwrap())
			local success, first, second = unpack(result, 1, resultLength)

			expect(resultLength).to.equal(3)
			expect(success).to.equal(false)
			expect(first).to.equal("foo")
			expect(second).to.equal("bar")
		end)
	end)
end]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="ModuleScript" referent="RBXd50c0893db6d490c8f81a120705a6e58">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">t</string>
				<string name="ScriptGuid">{7ef8a7ad-be73-45be-afd9-96cc6de33fd3}</string>
				<ProtectedString name="Source"><![CDATA[-- t: a runtime typechecker for Roblox

-- regular lua compatibility
local typeof = typeof or type

local function primitive(typeName)
	return function(value)
		local valueType = typeof(value)
		if valueType == typeName then
			return true
		else
			return false, string.format("%s expected, got %s", typeName, valueType)
		end
	end
end

local t = {}

--[[**
	matches any type except nil

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.any(value)
	if value ~= nil then
		return true
	else
		return false, "any expected, got nil"
	end
end

--Lua primitives

--[[**
	ensures Lua primitive boolean type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.boolean = primitive("boolean")

--[[**
	ensures Lua primitive coroutine type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.coroutine = primitive("thread")

--[[**
	ensures Lua primitive callback type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.callback = primitive("function")

--[[**
	ensures Lua primitive none type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.none = primitive("nil")

--[[**
	ensures Lua primitive string type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.string = primitive("string")

--[[**
	ensures Lua primitive table type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.table = primitive("table")

--[[**
	ensures Lua primitive userdata type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.userdata = primitive("userdata")

--[[**
	ensures value is a number and non-NaN

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.number(value)
	local valueType = typeof(value)
	if valueType == "number" then
		if value == value then
			return true
		else
			return false, "unexpected NaN value"
		end
	else
		return false, string.format("number expected, got %s", valueType)
	end
end

--[[**
	ensures value is NaN

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.nan(value)
	if value ~= value then
		return true
	else
		return false, "unexpected non-NaN value"
	end
end

-- roblox types

--[[**
	ensures Roblox Axes type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Axes = primitive("Axes")

--[[**
	ensures Roblox BrickColor type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.BrickColor = primitive("BrickColor")

--[[**
	ensures Roblox CFrame type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.CFrame = primitive("CFrame")

--[[**
	ensures Roblox Color3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Color3 = primitive("Color3")

--[[**
	ensures Roblox ColorSequence type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.ColorSequence = primitive("ColorSequence")

--[[**
	ensures Roblox ColorSequenceKeypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.ColorSequenceKeypoint = primitive("ColorSequenceKeypoint")

--[[**
	ensures Roblox DockWidgetPluginGuiInfo type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.DockWidgetPluginGuiInfo = primitive("DockWidgetPluginGuiInfo")

--[[**
	ensures Roblox Faces type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Faces = primitive("Faces")

--[[**
	ensures Roblox Instance type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Instance = primitive("Instance")

--[[**
	ensures Roblox NumberRange type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberRange = primitive("NumberRange")

--[[**
	ensures Roblox NumberSequence type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberSequence = primitive("NumberSequence")

--[[**
	ensures Roblox NumberSequenceKeypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberSequenceKeypoint = primitive("NumberSequenceKeypoint")

--[[**
	ensures Roblox PathWaypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.PathWaypoint = primitive("PathWaypoint")

--[[**
	ensures Roblox PhysicalProperties type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.PhysicalProperties = primitive("PhysicalProperties")

--[[**
	ensures Roblox Random type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Random = primitive("Random")

--[[**
	ensures Roblox Ray type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Ray = primitive("Ray")

--[[**
	ensures Roblox Rect type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Rect = primitive("Rect")

--[[**
	ensures Roblox Region3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Region3 = primitive("Region3")

--[[**
	ensures Roblox Region3int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Region3int16 = primitive("Region3int16")

--[[**
	ensures Roblox TweenInfo type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.TweenInfo = primitive("TweenInfo")

--[[**
	ensures Roblox UDim type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.UDim = primitive("UDim")

--[[**
	ensures Roblox UDim2 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.UDim2 = primitive("UDim2")

--[[**
	ensures Roblox Vector2 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector2 = primitive("Vector2")

--[[**
	ensures Roblox Vector3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector3 = primitive("Vector3")

--[[**
	ensures Roblox Vector3int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector3int16 = primitive("Vector3int16")

-- roblox enum types

--[[**
	ensures Roblox Enum type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Enum = primitive("Enum")

--[[**
	ensures Roblox EnumItem type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.EnumItem = primitive("EnumItem")

--[[**
	ensures value is a given literal value

	@param literal The literal to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.literal(literal)
	return function(value)
		if value ~= literal then
			return false, string.format("expected %s, got %s", tostring(literal), tostring(value))
		end
		return true
	end
end

--[[**
	DEPRECATED
	Please use t.literal
**--]]
t.exactly = t.literal

--[[**
	ensures value is an integer

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.integer(value)
	local success, errMsg = t.number(value)
	if not success then
		return false, errMsg or ""
	end
	if value%1 == 0 then
		return true
	else
		return false, string.format("integer expected, got %d", value)
	end
end

--[[**
	ensures value is a number where min <= value

	@param min The minimum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMin(min)
	return function(value)
		local success, errMsg = t.number(value)
		if not success then
			return false, errMsg or ""
		end
		if value >= min then
			return true
		else
			return false, string.format("number >= %d expected, got %d", min, value)
		end
	end
end

--[[**
	ensures value is a number where value <= max

	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMax(max)
	return function(value)
		local success, errMsg = t.number(value)
		if not success then
			return false, errMsg
		end
		if value <= max then
			return true
		else
			return false, string.format("number <= %d expected, got %d", max, value)
		end
	end
end

--[[**
	ensures value is a number where min < value

	@param min The minimum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMinExclusive(min)
	return function(value)
		local success, errMsg = t.number(value)
		if not success then
			return false, errMsg or ""
		end
		if min < value then
			return true
		else
			return false, string.format("number > %d expected, got %d", min, value)
		end
	end
end

--[[**
	ensures value is a number where value < max

	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMaxExclusive(max)
	return function(value)
		local success, errMsg = t.number(value)
		if not success then
			return false, errMsg or ""
		end
		if value < max then
			return true
		else
			return false, string.format("number < %d expected, got %d", max, value)
		end
	end
end

--[[**
	ensures value is a number where value > 0

	@returns A function that will return true iff the condition is passed
**--]]
t.numberPositive = t.numberMinExclusive(0)

--[[**
	ensures value is a number where value < 0

	@returns A function that will return true iff the condition is passed
**--]]
t.numberNegative = t.numberMaxExclusive(0)

--[[**
	ensures value is a number where min <= value <= max

	@param min The minimum to use
	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberConstrained(min, max)
	assert(t.number(min) and t.number(max))
	local minCheck = t.numberMin(min)
	local maxCheck = t.numberMax(max)
	return function(value)
		local minSuccess, minErrMsg = minCheck(value)
		if not minSuccess then
			return false, minErrMsg or ""
		end

		local maxSuccess, maxErrMsg = maxCheck(value)
		if not maxSuccess then
			return false, maxErrMsg or ""
		end

		return true
	end
end

--[[**
	ensures value is a number where min < value < max

	@param min The minimum to use
	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberConstrainedExclusive(min, max)
	assert(t.number(min) and t.number(max))
	local minCheck = t.numberMinExclusive(min)
	local maxCheck = t.numberMaxExclusive(max)
	return function(value)
		local minSuccess, minErrMsg = minCheck(value)
		if not minSuccess then
			return false, minErrMsg or ""
		end

		local maxSuccess, maxErrMsg = maxCheck(value)
		if not maxSuccess then
			return false, maxErrMsg or ""
		end

		return true
	end
end

--[[**
	ensures value is either nil or passes check

	@param check The check to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.optional(check)
	assert(t.callback(check))
	return function(value)
		if value == nil then
			return true
		end
		local success, errMsg = check(value)
		if success then
			return true
		else
			return false, string.format("(optional) %s", errMsg or "")
		end
	end
end

--[[**
	matches given tuple against tuple type definition

	@param ... The type definition for the tuples

	@returns A function that will return true iff the condition is passed
**--]]
function t.tuple(...)
	local checks = {...}
	return function(...)
		local args = {...}
		for i = 1, #checks do
			local success, errMsg = checks[i](args[i])
			if success == false then
				return false, string.format("Bad tuple index #%d:\n\t%s", i, errMsg or "")
			end
		end
		return true
	end
end

--[[**
	ensures all keys in given table pass check

	@param check The function to use to check the keys

	@returns A function that will return true iff the condition is passed
**--]]
function t.keys(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess, tableErrMsg = t.table(value)
		if tableSuccess == false then
			return false, tableErrMsg or ""
		end

		for key in pairs(value) do
			local success, errMsg = check(key)
			if success == false then
				return false, string.format("bad key %s:\n\t%s", tostring(key), errMsg or "")
			end
		end

		return true
	end
end

--[[**
	ensures all values in given table pass check

	@param check The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.values(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess, tableErrMsg = t.table(value)
		if tableSuccess == false then
			return false, tableErrMsg or ""
		end

		for key, val in pairs(value) do
			local success, errMsg = check(val)
			if success == false then
				return false, string.format("bad value for key %s:\n\t%s", tostring(key), errMsg or "")
			end
		end

		return true
	end
end

--[[**
	ensures value is a table and all keys pass keyCheck and all values pass valueCheck

	@param keyCheck The function to use to check the keys
	@param valueCheck The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.map(keyCheck, valueCheck)
	assert(t.callback(keyCheck), t.callback(valueCheck))
	local keyChecker = t.keys(keyCheck)
	local valueChecker = t.values(valueCheck)
	return function(value)
		local keySuccess, keyErr = keyChecker(value)
		if not keySuccess then
			return false, keyErr or ""
		end

		local valueSuccess, valueErr = valueChecker(value)
		if not valueSuccess then
			return false, valueErr or ""
		end

		return true
	end
end

do
	local arrayKeysCheck = t.keys(t.integer)
	--[[**
		ensures value is an array and all values of the array match check

		@param check The check to compare all values with

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.array(check)
		assert(t.callback(check))
		local valuesCheck = t.values(check)
		return function(value)
			local keySuccess, keyErrMsg = arrayKeysCheck(value)
			if keySuccess == false then
				return false, string.format("[array] %s", keyErrMsg or "")
			end

			-- all keys are sequential
			local arraySize = #value
			for key in pairs(value) do
				if key < 1 or key > arraySize then
					return false, string.format("[array] key %s must be sequential", tostring(key))
				end
			end

			local valueSuccess, valueErrMsg = valuesCheck(value)
			if not valueSuccess then
				return false, string.format("[array] %s", valueErrMsg or "")
			end

			return true
		end
	end
end

do
	local callbackArray = t.array(t.callback)
	--[[**
		creates a union type

		@param ... The checks to union

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.union(...)
		local checks = {...}
		assert(callbackArray(checks))
		return function(value)
			for _, check in pairs(checks) do
				if check(value) then
					return true
				end
			end
			return false, "bad type for union"
		end
	end

	--[[**
		creates an intersection type

		@param ... The checks to intersect

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.intersection(...)
		local checks = {...}
		assert(callbackArray(checks))
		return function(value)
			for _, check in pairs(checks) do
				local success, errMsg = check(value)
				if not success then
					return false, errMsg or ""
				end
			end
			return true
		end
	end
end

do
	local checkInterface = t.map(t.string, t.callback)
	--[[**
		ensures value matches given interface definition

		@param checkTable The interface definition

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.interface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess, tableErrMsg = t.table(value)
			if tableSuccess == false then
				return false, tableErrMsg or ""
			end

			for key, check in pairs(checkTable) do
				local success, errMsg = check(value[key])
				if success == false then
					return false, string.format("[interface] bad value for %s:\n\t%s", key, errMsg or "")
				end
			end
			return true
		end
	end

	--[[**
		ensures value matches given interface definition strictly

		@param checkTable The interface definition

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.strictInterface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess, tableErrMsg = t.table(value)
			if tableSuccess == false then
				return false, tableErrMsg or ""
			end

			for key, check in pairs(checkTable) do
				local success, errMsg = check(value[key])
				if success == false then
					return false, string.format("[interface] bad value for %s:\n\t%s", key, errMsg or "")
				end
			end

			for key in pairs(value) do
				if not checkTable[key] then
					return false, string.format("[interface] unexpected field '%s'", key)
				end
			end

			return true
		end
	end
end

--[[**
	ensure value is an Instance and it's ClassName matches the given ClassName

	@param className The class name to check for

	@returns A function that will return true iff the condition is passed
**--]]
function t.instance(className)
	assert(t.string(className))
	return function(value)
		local instanceSuccess, instanceErrMsg = t.Instance(value)
		if not instanceSuccess then
			return false, instanceErrMsg or ""
		end

		if value.ClassName ~= className then
			return false, string.format("%s expected, got %s", className, value.ClassName)
		end

		return true
	end
end

--[[**
	ensure value is an Instance and it's ClassName matches the given ClassName by an IsA comparison

	@param className The class name to check for

	@returns A function that will return true iff the condition is passed
**--]]
function t.instanceIsA(className)
	assert(t.string(className))
	return function(value)
		local instanceSuccess, instanceErrMsg = t.Instance(value)
		if not instanceSuccess then
			return false, instanceErrMsg or ""
		end

		if not value:IsA(className) then
			return false, string.format("%s expected, got %s", className, value.ClassName)
		end

		return true
	end
end

--[[**
	ensures value is an enum of the correct type

	@param enum The enum to check

	@returns A function that will return true iff the condition is passed
**--]]
function t.enum(enum)
	assert(t.Enum(enum))
	return function(value)
		local enumItemSuccess, enumItemErrMsg = t.EnumItem(value)
		if not enumItemSuccess then
			return false, enumItemErrMsg
		end

		if value.EnumType == enum then
			return true
		else
			return false, string.format("enum of %s expected, got enum of %s", tostring(enum), tostring(value.EnumType))
		end
	end
end

do
	local checkWrap = t.tuple(t.callback, t.callback)

	--[[**
		wraps a callback in an assert with checkArgs

		@param callback The function to wrap
		@param checkArgs The functon to use to check arguments in the assert

		@returns A function that first asserts using checkArgs and then calls callback
	**--]]
	function t.wrap(callback, checkArgs)
		assert(checkWrap(callback, checkArgs))
		return function(...)
			assert(checkArgs(...))
			return callback(...)
		end
	end
end

--[[**
	asserts a given check

	@param check The function to wrap with an assert

	@returns A function that simply wraps the given check in an assert
**--]]
function t.strict(check)
	return function(...)
		assert(check(...))
	end
end

return t]]></ProtectedString>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX6b14cfa6e11743fda98b5160cd7fed88">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Rodash</string>
				<string name="ScriptGuid">{b55125cc-ec4c-44c9-a87d-efb2d1b81ac1}</string>
				<ProtectedString name="Source"><![CDATA[local Async = require(script.Async)
local Classes = require(script.Classes)
local Functions = require(script.Functions)
local Strings = require(script.Strings)
local Arrays = require(script.Arrays)
local Tables = require(script.Tables)

local rd = Tables.assign(Async, Classes, Functions, Strings, Arrays, Tables)
return rd
]]></ProtectedString>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX1d4297acf9de43b1b0cad0a58ed3c4da">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Arrays</string>
					<string name="ScriptGuid">{5887ef10-8b1b-465b-afbf-548125a513c2}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	A collection of functions that operate specifically on arrays, defined as tables with just keys _1..n_.

	```lua
		-- Examples of valid arrays:
		{}
		{"red", "green", "blue"}
		{"winter", {is = "coming"}, [3] = "again"}
		{1966, nil, nil}
		-- Examples of invalid arrays:
		{1994, nil, 2002}
		{you = {"know", "nothing"}}
		{[5] = "gold rings"}
		42
	```

	Functions can also iterate over custom iterator functions which provide elements with natural keys _1..n_.
]]
local t = require(script.Parent.Parent.t)
local Tables = require(script.Parent.Tables)

local Arrays = {}

local function assertHandlerIsFn(handler)
	local Functions = require(script.Parent.Functions)
	assert(Functions.isCallable(handler), "BadInput: handler must be a function")
end
local function assertPredicateIsFn(handler)
	local Functions = require(script.Parent.Functions)
	assert(Functions.isCallable(handler), "BadInput: handler must be a function")
end

local typeIndex = {
	boolean = 1,
	number = 2,
	string = 3,
	["function"] = 4,
	["CFunction"] = 5,
	userdata = 6,
	table = 7
}

--[[
	The default comparator is used by `_.sort` and can sort elements of different types, in the
	order: boolean, number, string, function, CFunction, userdata, and table.
		
	Elements which cannot be sorted naturally will be sorted by their string value.

	@see _.sort
]]
function Arrays.defaultComparator(a, b)
	if type(a) ~= type(b) then
		return typeIndex[type(a)] - typeIndex[type(b)]
	end
	local ok, result =
		pcall(
		function()
			return a < b
		end
	)
	if ok then
		return result
	else
		return tostring(a) < tostring(b)
	end
end

--[[
	Returns a sorted array from the _input_ array, based on a _comparator_ function.

	Unlike `table.sort`, the comparator to `_.sort` is optional, but it can also be defined to
	a numeric weight or nil as well as a boolean.

	@param comparator (optional) should return `true` or `n < 0` if the first element should be
		before the second in the resulting array, or `0` or `nil` if the elements have the same
		order.

	@example _.sort({2, 5, 3}) --> {2, 3, 5}
	@example _.sort({"use", "the", "force", "Luke"}) --> {"Luke", "force", "the", "use"}
]]
--: <T>(T[], (T -> bool | number | nil) -> T[])
function Arrays.sort(input, comparator)
	assert(t.table(input), "BadInput: input must be an array")

	local Functions = require(script.Parent.Functions)
	assert(comparator == nil or Functions.isCallable(comparator), "BadInput: comparator must be callable or nil")

	comparator = comparator or Arrays.defaultComparator

	table.sort(
		input,
		function(a, b)
			local result = comparator(a, b)

			if type(result) ~= "number" and type(result) ~= "boolean" and result ~= nil then
				error("BadResult: comparator must return a boolean, a number or nil")
			end

			return result == true or (type(result) == "number" and result < 0)
		end
	)

	return input
end

--[[
	Returns a copied portion of the _source_.
	@param first (default = 1) The index of the first element to include.
	@param last (default = `#source`) The index of the last element to include.
	@param step (default = 1) What amount to step the index by during iteration.
	@example _.slice({10, 20, 30, 40}) --> {10, 20, 30, 40}
	@example _.slice({10, 20, 30, 40}, 2) --> {20, 30, 40}
	@example _.slice({10, 20, 30, 40}, 2, 3) --> {20, 30}
	@example _.slice({10, 20, 30, 40}, 2, 4, 2) --> {20, 40}
]]
--: <T>(T[], int?, int?, int? -> T[])
function Arrays.slice(source, first, last, step)
	assert(t.table(source), "BadInput: source must be an array")
	assert(t.optional(t.number)(first), "BadInput: first must be an int")
	assert(t.optional(t.number)(last), "BadInput: last must be an int")
	assert(t.optional(t.number)(step), "BadInput: step must be an int")
	local sliced = {}

	for i = first or 1, last or #source, step or 1 do
		sliced[#sliced + 1] = source[i]
	end

	return sliced
end

--[[
	Returns a new array with the order of the values from _source_ randomized.
	@example
		local teamColors = {"red", "red", "red", "blue", "blue", "blue"}
		-- (in some order)
		_.shuffle(teamColors) --> {"blue", "blue", "red", "blue", "red", "red"}
]]
--: <T: Iterable>(T -> T)
function Arrays.shuffle(source)
	assert(t.table(source), "BadInput: source must be an array")
	local result = Tables.clone(source)
	for i = #result, 1, -1 do
		local j = math.random(i)
		result[i], result[j] = result[j], result[i]
	end
	return result
end

--[[
	Runs the _handler_ on each element of _source_ in turn, passing the result of the previous call
	(or _initial_ for the first element) as the first argument, and the current element as a value
	and key as subsequent arguments.
	@example
		local sum = _.reduce({1, 2, 3}, function(result, value)
			return result + value
		end, 0)
		sum --> 6
	@example
		local recipe = {first = "cheese", second = "nachos", third = "chillies"}
		local unzipRecipe = _.reduce(recipe, function(result, value, key)
			table.insert(result[1], key)
			table.insert(result[2], value)
			return result
		end, {{}, {}})
		-- (in some order)
		unzipRecipe --> {{"first", "third", "second"}, {"cheese", "chillies", "nachos"}}
]]
--: <T, R>(T[], (result: R, value: T, key: int -> R), R) -> R
function Arrays.reduce(source, handler, initial)
	local result = initial
	for i, v in Tables.iterator(source) do
		result = handler(result, v, i)
	end
	return result
end

--[[
	Inserts into _target_ the elements from all subsequent arguments in order.
	@param ... any number of other arrays
	@example _.append({}, {1, 2, 3}, {4, 5, 6}) --> {1, 2, 3, 4, 5, 6}
	@example _.append({1, 2, 3}) --> {1, 2, 3}
	@example
		local list = {"cheese"}
		_.append(list, {"nachos"}, {}, {"chillies"})
		list --> {"cheese", "nachos", "chillies"}
]]
--: <T>(mut T[], ...T[] -> T[])
function Arrays.append(target, ...)
	for i = 1, select("#", ...) do
		local x = select(i, ...)
		if type(x) == "table" then
			for _, y in ipairs(x) do
				table.insert(target, y)
			end
		else
			table.insert(target, x)
		end
	end

	return target
end

--[[
	Sums all the values in the _source_ array.
	@example _.sum({1, 2, 3}) --> 6
]]
function Arrays.sum(source)
	return Arrays.reduce(
		source,
		function(current, value)
			return current + value
		end,
		0
	)
end

--[[
	Swaps the order of elements in _source_.
	@example _.reverse({1, 2, 4, 3, 5}) --> {5, 3, 4, 2, 1}
]]
--: <T>(T[] -> T[])
function Arrays.reverse(source)
	local output = {}
	for i = #source, 1, -1 do
		table.insert(output, source[i])
	end
	return output
end

--[[
	Returns the earliest value from the array that _predicate_ returns `true` for.

	If the _predicate_ is not specified, `_.first` simply returns the first element of the array.
	@param predicate (default = `_.returns(true)`)
	@example
		local names = {
			"Boromir",
			"Frodo",
			"Bilbo"
		}

		_.first(names) --> "Boromir", 1

		-- Find a particular value:
		local firstNameWithF = _.first(names, function(name)
			return _.startsWith(name, "F")
		end)
		firstNameWithF --> "Frodo", 2

		-- What about a value whcih doesn't exist?
		local firstNameWithC = _.first(names, function(name)
			return _.startsWith(name, "C")
		end)
		firstNameWithC --> nil

		-- Find the index of a value:
		local _, index = _.first(names, _.fn:matches("Bilbo"))
		index --> 2
	@see _.find 
	@usage If you need to find a value in a table which isn't an array, use `_.find`.
]]
--: <T: Iterable<K,V>>((T, (element: V, key: K) -> bool) -> V?)
function Arrays.first(source, predicate)
	predicate = predicate or function()
			return true
		end
	assertPredicateIsFn(predicate)
	for i, v in Tables.iterator(source, true) do
		if (predicate(v, i)) then
			return v, i
		end
	end
end

--[[
	Returns the last value from the array that _predicate_ returns `true` for.

	If the _predicate_ is not specified, `_.last` simply returns the last element of the array.
	@param predicate (default = `_.returns(true)`)
	@example
		local names = {
			"Boromir",
			"Frodo",
			"Bilbo"
		}

		_.last(names) --> "Bilbo", 3

		local lastNameWithB = _.last(names, _.fn:startsWith("B"))
		lastNameWithB --> "Bilbo", 3

		local _, key = _.last(names, _.fn:matches("Frodo"))
		key --> 2
	@see _.find
	@see _.first
]]
--: <T: Iterable<K,V>>((T, (element: V, key: K) -> bool) -> V?)
function Arrays.last(source, predicate)
	predicate = predicate or function()
			return true
		end
	assertHandlerIsFn(predicate)
	for i = #source, 1, -1 do
		local value = source[i]
		if (predicate(value, i)) then
			return value, i
		end
	end
end

return Arrays
]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXa39ea473f3494770a7dc73d5cc7ad69b">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Async</string>
					<string name="ScriptGuid">{248c7254-b1f6-4a52-9d73-5e57c5b576bd}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	Building upon the functionality of [Roblox Lua Promise](https://github.com/LPGhatguy/roblox-lua-promise)
	and borrowing ideas from [Bluebird](http://bluebirdjs.com/docs/getting-started.html),
	these functions improve the experience of working with asynchronous code in Roblox.
]]
local t = require(script.Parent.Parent.t)
local Tables = require(script.Parent.Tables)
local Functions = require(script.Parent.Functions)
local Promise = require(script.Parent.Parent.Promise)
local Async = {}

local baseRandomStream = Random.new()

--[[
	Yields completion of a promise `promise:await()`, but returns immediately with the value if it
	isn't a promise.
	@example
		local heat = function( item )
			return _.delay(1).returns("hot " .. item)
		end
		local recipe = {"wrap", heat("steak"), heat("rice")}
		local burrito = _.map(recipe, _.await)
		_.debug("{:#?}", burrito)
		-->> {"wrap", "hot steak", "hot rice"} (2 seconds)
]]
function Async.await(value)
	if Async.isPromise(value) then
		return value:await()
	end
	return value
end

--[[
	Wraps `Promise.is` but catches any errors thrown in attempting to ascertain if _value_ is a
	promise, which will occur if the value throws when trying to access missing keys.
]]
function Async.isPromise(value)
	local ok, isPromise =
		pcall(
		function()
			return Promise.is(value)
		end
	)
	return ok and isPromise
end

--[[
    Given an _array_ of values, this function returns a promise which
    resolves once all of the array elements have resolved, or rejects
    if any of the array elements reject.
	
	@returns an array mapping the input to resolved elements.
	@example
		local heat = function( item )
			local oven = _.parallel({item, _.delay(1)})
			return oven:andThen(function( result )
				return "hot-" .. result[1] 
			end)
		end
		local meal =_.parallel({heat("cheese"), "tomato"})
		meal:await() --> {"hot-cheese", "tomato"} (1 second later)
	@rejects passthrough
	@usage This function is like `Promise.all` but allows objects in the array which aren't
		promises. These are considered resolved immediately.
	@usage Promises that return nil values will cause the return array to be sparse.
]]
--: <T>((Promise<T> | T)[]) -> Promise<T[]>
function Async.parallel(array)
	assert(t.table(array), "BadInput: array must be an array")
	local promises =
		Tables.map(
		array,
		function(object)
			if Async.isPromise(object) then
				return object
			else
				return Promise.resolve(object)
			end
		end
	)
	return Promise.all(promises)
end

--[[
	Given a _dictionary_ of values, this function returns a promise which
	resolves once all of the values in the dictionary have resolved, or rejects
	if any of them are promises that reject.
	
	@returns a dictionary mapping the input to resolved elements.
	@rejects passthrough
	@example
		local heat = function( item )
			local oven = _.parallel({item, _.delay(1)})
			return oven:andThen(function( result )
				return "hot-" .. result[1] 
			end)
		end
		local toastie = _.parallelAll({
			bread = "brown",
			filling = heat("cheese")
		})
		toastie:await() --> {bread = "brown", filling = "hot-cheese"} (1 second later)
	@usage Values which are not promises are considered resolved immediately.
]]
--: <T>((Promise<T> | T){}) -> Promise<T{}>
function Async.parallelAll(dictionary)
	assert(t.table(dictionary), "BadInput: dictionary must be a table")
	local keys = Tables.keys(dictionary)
	local values =
		Tables.map(
		keys,
		function(key)
			return dictionary[key]
		end
	)
	return Async.parallel(values):andThen(
		function(output)
			return Tables.keyBy(
				output,
				function(value, i)
					return keys[i]
				end
			)
		end
	)
end

--[[
	Like `Promise.resolve` but can take any number of arguments.
	@example
		local function mash( veg )
			return _.resolve("mashed", veg)
		end
		mash("potato"):andThen(function(style, veg)
			_.debug("{} was {}", veg, style)
		end)
		-- >> potato was mashed
	@usage As `_.resolve(promise) --> promise`, this function can also be used to ensure a value is a promise.
]]
--: T -> Promise<T>
function Async.resolve(...)
	local args = {...}
	return Promise.new(
		function(resolve)
			resolve(unpack(args))
		end
	)
end

--[[
	Returns a promise which completes after the first promise in the _array_ input completes, or
	first _n_ promises if specified. If any promise rejects, race rejects with the first rejection.
	@param n the number of promises required (default = 1)
	@returns an array containing the first n resolutions, in the order that they resolved.
	@rejects passthrough
	@throws OutOfBoundsError - if the number of required promises is greater than the input length.
	@usage Promises which return nil values are ignored due to the in-order constraint.
	@usage The size of _array_ must be equal to or larger than _n_.
]]
--: <T>(Promise<T>[], uint?) -> Promise<T[]>
function Async.race(array, n)
	n = n or 1
	assert(n >= 0, "BadInput: n must be an integer >= 0")
	assert(#array >= n, "OutOfBoundsError: n must be less than #array")
	local function handler(resolve, reject)
		local results = {}
		local function finally(ok, result)
			if #results < n then
				if ok then
					table.insert(results, result)
					if #results == n then
						resolve(results)
					end
				else
					reject(result)
				end
			end
		end
		local function awaitElement(promise)
			Async.finally(promise, finally)
		end
		Tables.map(array, awaitElement)
		if n == 0 then
			resolve(results)
		end
	end
	return Promise.new(handler)
end

--[[
	Returns a promise which completes after the _promise_ input has completed, regardless of
	whether it has resolved or rejected.
	@param fn _function(ok, result)_
	@example
		local getHunger = _.async(function( player )
			if player.health == 0 then
				error("Player is dead!")
			else
				return game.ReplicatedStorage.GetHunger:InvokeServer( player )
			end
		end)
		local localPlayer = game.Players.LocalPlayer
		local isHungry = getHunger( localPlayer ):finally(function( isAlive, result )
			return isAlive and result < 5
		end)
]]
--: <T>(Promise<T>, (bool, T) -> nil) -> Promise<nil>
function Async.finally(promise, fn)
	assert(Async.isPromise(promise), "BadInput: promise must be a promise")
	return promise:andThen(
		function(...)
			fn(true, ...)
		end
	):catch(
		function(...)
			fn(false, ...)
		end
	)
end

--[[
	Returns a promise which never resolves or rejects.
	@usage Useful in combination with `_.race` where a resolution or rejection should be ignored.
]]
--: () -> never
function Async.never()
	return Promise.new(Functions.noop)
end

--[[
	Resolves to the result of `promise` if it resolves before the deadline, otherwise rejects with
	an error, which can be optionally customized.
	@param timeoutMessage (default = "TimeoutError")
	@rejects **TimeoutError** - or _timeoutMessage_
	@example
		let eatGreens = function() return _.never end
		_.timeout(eatGreens(), 10, "TasteError"):await()
		--> throws "TasteError" (after 10s)
]]
--: <T>(Promise<T>, number, string?) -> Promise<T>
function Async.timeout(promise, deadlineInSeconds, timeoutMessage)
	return Async.race(
		{
			promise,
			Async.delay(deadlineInSeconds):andThen(Functions.throws(timeoutMessage or "TimeoutError"))
		}
	)
end

--[[
	Like `_.compose` but takes functions that can return a promise. Returns a promise that resolves
	once all functions have resolved. Like compose, functions receive the resolution of the
	previous promise as argument(s).
	@example
		local function fry(item) return _.delay(1):andThen(_.returns("fried " .. item)) end
		local function cheesify(item) return _.delay(1):andThen(_.returns("cheesy " .. item)) end
		local prepare = _.compose(fry, cheesify)
		prepare("nachos"):await() --> "cheesy fried nachos" (after 2s)
]]
--: <A>((...A -> Promise<A>)[]) -> ...A -> Promise<A>
function Async.series(...)
	local fnCount = select("#", ...)
	local fns = {...}
	return Async.async(
		function(...)
			local result = {fns[1](...)}
			for i = 2, fnCount do
				result = {Async.resolve(fns[i](unpack(result))):await()}
			end
			return unpack(result)
		end
	)
end

--[[
	Returns a promise which resolves after the given delayInSeconds.
	@example _.delay(1):andThen(function() print("Delivered") end)
	-->> Delivered (1 second later)
]]
--: number -> Promise<nil>
function Async.delay(delayInSeconds)
	assert(t.number(delayInSeconds), "BadInput: delayInSeconds must be a number")
	return Promise.new(
		function(resolve)
			delay(delayInSeconds, resolve)
		end
	)
end

--[[
	Wraps a function which may yield in a promise. When run, async calls the
	the function in a coroutine and resolves with the output of the function
	after any asynchronous actions, and rejects if the function throws an error.
	@rejects passthrough
	@example
		local fetch = _.async(function( url )
			local HttpService = game:GetService("HttpService")
			return HttpService:GetAsync(url)
		end)
		_.parallelAll({
			main = fetch("http://example.com/burger"),
			side = fetch("http://example.com/fries") 
		}):andThen(function( meal )
			print("Meal", _.pretty(meal))
		end)
		-->> Meal {burger = "Cheeseburger", fries = "Curly fries"} (ideal response)
	@usage With `promise:await` the `_.async` function can be used just like the async-await pattern in languages like JS.
]]
--: <T, A>(Yieldable<T, A>) -> ...A -> Promise<T>
function Async.async(fn)
	assert(Functions.isCallable(fn), "BadInput: fn must be callable")
	return function(...)
		local callArgs = {...}
		return Promise.new(
			function(resolve, reject)
				coroutine.wrap(
					function()
						local ok, result = pcall(fn, unpack(callArgs))
						if ok then
							resolve(result)
						else
							reject(result)
						end
					end
				)()
			end
		)
	end
end

--[[
	Wraps any functions in _dictionary_ with `_.async`, returning a new dictionary containing
	functions that return promises when called rather than yielding.
	@example
		local buyDinner = _.async(function()
			local http = _.asyncAll(game:GetService("HttpService"))
			local order = _.parallelAll({
				main = http:GetAsync("http://example.com/burger"),
				side = http:GetAsync("http://example.com/fries")
			})
			return http:PostAsync("http://example.com/purchase", order:await())
		end)
		buyDinner():await() --> "Purchased!" (some time later)
]]
--: <T, Args>(Yieldable<T, Args>{}) -> (...Args -> Promise<T>){}
function Async.asyncAll(dictionary)
	assert(t.table(dictionary), "BadInput: dictionary must be a table")
	local result =
		Tables.map(
		dictionary,
		function(value)
			if Functions.isCallable(value) then
				return Async.async(value)
			else
				return value
			end
		end
	)
	setmetatable(result, getmetatable(dictionary))
	return result
end

--[[
	Try running a function which returns a promise and retry if the function throws
	and error or the promise rejects. The retry behaviour can be adapted using
	backoffOptions, which can customize the maximum number of retries and the backoff
	timing of the form `[0, x^attemptNumber] + y` where _x_ is an exponent that produces
	a random exponential delay and _y_ is a constant delay.

	#### Backoff Options
	|Option|Type|Description|
	|---|---|---|
	| **maxTries** | _int_ | how many tries (including the first one) the function should be called |
	| **retryExponentInSeconds** | _number_ | customize the backoff exponent |
	| **retryConstantInSeconds** | _number_ | customize the backoff constant |
	| **randomStream** | _Random_ | use a Roblox "Random" instance to control the backoff |
	| **shouldRetry(response)** | _T -> bool_ | called if maxTries > 1 to determine whether a retry should occur |
	| **onRetry(waitTime, errorMessage)** | _(number, string) -> nil_ | a hook for when a retry is triggered, with the delay before retry and error message which caused the failure |
	| **onDone(response, durationInSeconds)** | _(T, number) -> nil_ | a hook for when the promise resolves |
	| **onFail(errorMessage)** | _string -> nil_ | a hook for when the promise has failed and no more retries are allowed |
	
	@rejects passthrough
]]
--: <T>(() -> Promise<T>, BackoffOptions) -> Promise<T>
function Async.retryWithBackoff(getPromise, backoffOptions)
	assert(Functions.isCallable(getPromise), "BadInput: getPromise must be callable")
	local function backoffThenRetry(errorMessage)
		local waitTime =
			(backoffOptions.retryExponentInSeconds ^ backoffOptions.attemptNumber) * backoffOptions.randomStream:NextNumber() +
			backoffOptions.retryConstantInSeconds
		backoffOptions.onRetry(waitTime, errorMessage)
		return Async.delay(waitTime):andThen(
			function()
				return Async.retryWithBackoff(
					getPromise,
					Tables.assign(
						{},
						backoffOptions,
						{
							maxTries = backoffOptions.maxTries - 1,
							attemptNumber = backoffOptions.attemptNumber + 1
						}
					)
				)
			end
		)
	end

	local function getDurationInSeconds()
		return tick() - backoffOptions.startTime
	end

	backoffOptions =
		Tables.assign(
		{
			startTime = tick(),
			maxTries = 5,
			attemptNumber = 0,
			retryExponentInSeconds = 5,
			retryConstantInSeconds = 2,
			randomStream = baseRandomStream,
			onRetry = function()
			end,
			onDone = function()
			end,
			onFail = function()
			end,
			shouldRetry = function()
				return true
			end
		},
		backoffOptions
	)
	assert(backoffOptions.maxTries > 0, "BadInput: maxTries must be > 0")

	local function shouldRetry(response)
		return backoffOptions.maxTries > 1 and backoffOptions.shouldRetry(response)
	end

	local function retryIfShouldElseCallOnFailAndReturn(response, failHandler)
		if shouldRetry(response) then
			return backoffThenRetry(response)
		else
			backoffOptions.onFail(response)
			return failHandler(response)
		end
	end

	local function callOnDoneAndReturnPromise(response)
		backoffOptions.onDone(response, getDurationInSeconds())
		return Async.isPromise(response) and response or Promise.resolve(response)
	end

	local ok, response =
		pcall(
		function()
			return getPromise()
		end
	)

	if ok then
		if Async.isPromise(response) then
			return response:catch(
				function(response)
					return retryIfShouldElseCallOnFailAndReturn(response, error)
				end
			):andThen(callOnDoneAndReturnPromise)
		else
			return callOnDoneAndReturnPromise(response)
		end
	else
		return retryIfShouldElseCallOnFailAndReturn(response, Promise.reject)
	end
end

return Async
]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXeadb4d77f80b46ae9ff1e3b97307090d">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Classes</string>
					<string name="ScriptGuid">{3d17cb8d-c370-4c27-8f37-0c34f9f9ee34}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	These tools provide implementations of and functions for higher-order abstractions such as classes, enumerations and symbols.
]]
local t = require(script.Parent.Parent.t)
local Tables = require(script.Parent.Tables)
local Arrays = require(script.Parent.Arrays)
local Functions = require(script.Parent.Functions)
local Classes = {}

--[[
	Create a class called _name_ with the specified _constructor_. The constructor should return a
	plain table which will be turned into an instance of _Class_ from a call to `Class.new(...)`.

	Optionally, you may provide an array of _decorators_ which compose and reduce the Class, adding
	additional methods and functionality you may need. Specifically you can:
	
	1. Add standard functionality to the class e.g. `_.Clone`, `_.ShallowEq`
	2. Mixin an implementation of an interface e.g. `_.mixin( fns )`
	3. Decorate fields or functions e.g. `_.decorate(_.freeze)`

	@param constructor (default = `_.returns({})`)
	@param decorators (default = `{}`)
	@example
		-- Create a simple Vehicle class
		local Vehicle = _.class("Vehicle", function( wheelCount ) return 
			{
				speed = 0,
				wheelCount = wheelCount
			}
		end)
		function Vehicle:drive(speed)
			self.speed = speed
		end
		-- Create a car instance
		local car = Vehicle.new(4)
		car.wheelCount --> 4
		car.speed --> 0
		-- Drive the car
		car:drive(10)
		car.speed --> 10
		
	@usage When using Rodash classes, private fields should be prefixed with `_` to avoid accidental access.
	@usage A private field should only be accessed by a method of the class itself, though Rodash
		does not restrict this in code.
	@usage Public fields are recommended when there is no complex access logic e.g. `position.x`
	@see _.classWithInterface - recommended for providing runtime type-checking.
	@see _.mixin - extend the class with extra methods.
	@see _.decorate - include methods that run when an instance of the class is constructed.
]]
--: <T>(string, Constructor<T>?, Decorator<T>[]?) -> Class<T>
function Classes.class(name, constructor, decorators)
	assert(t.string(name), "BadInput: name must be a string")
	assert(t.optional(Functions.isCallable)(constructor), "BadInput: constructor must be callable or nil")
	assert(t.optional(t.table)(decorators), "BadInput: decorators must be a table or nil")
	local decorate = Functions.compose(unpack(decorators or {}))
	constructor = constructor or function()
			return {}
		end
	-- @type Class<T>
	local Class = {
		name = name
	}
	--[[
		Return a new instance of the class, passing any arguments to the specified constructor.
	]]
	--: Constructor<T>
	function Class.new(...)
		local instance = constructor(...)
		setmetatable(
			instance,
			{
				__index = Class,
				__tostring = Class.toString,
				__eq = Class.equals,
				__lt = Class.__lt,
				__le = Class.__le,
				__add = Class.__add,
				__sub = Class.__sub,
				__mul = Class.__mul,
				__div = Class.__div,
				__mod = Class.__mod
			}
		)
		instance.Class = Class
		instance:_init(...)
		return instance
	end
	--[[
		Run after the instance has been properly initialized, allowing methods on the instance to
		be used.
		@example
			local Vehicle = _.class("Vehicle", function( wheelCount ) return 
				{
					speed = 0,
					wheelCount = wheelCount
				}
			end)
			-- Let's define a static private function to generate a unique id for each vehicle.
			function Vehicle._getNextId()
				Vehicle._nextId = Vehicle._nextId + 1
				return Vehicle._nextId
			end
			Vehicle._nextId = 0
			-- A general purpose init function may call other helper methods
			function Vehicle:_init()
				self._id = self:_generateId()
			end
			-- Assign an id to the new instance
			function Vehicle:_generateId()
				return _.format("#{}: {} wheels", Vehicle._getNextId(), self.wheelCount)
			end
			-- Return the id if the instance is represented as a string 
			function Vehicle:toString()
				return self._id
			end

			local car = Vehicle.new(4)
			tostring(car) --> "#1: 4 wheels"
	]]
	--: (mut T:) -> nil
	function Class:_init()
	end

	--[[
		Returns `true` if _value_ is an instance of _Class_ or any sub-class.
		@example
			local Vehicle = _.class("Vehicle", function( wheelCount ) return 
				{
					speed = 0,
					wheelCount = wheelCount
				}
			end)
			local Car = Vehicle:extend("Vehicle", function()
				return Vehicle.constructor(4)
			end)
			local car = Car.new()
			car.isInstance(Car) --> true
			car.isInstance(Vehicle) --> true
			car.isInstance(Bike) --> false
	]]
	--: any -> bool
	function Class.isInstance(value)
		local ok = Classes.isA(value, Class)
		return ok, not ok and string.format("Not a %s instance", name) or nil
	end

	--[[
		Create a subclass of _Class_ with a new _name_ that inherits the metatable of _Class_,
		optionally overriding the _constructor_ and providing additional _decorators_.

		The super-constructor can be accessed with `Class.constructor`.

		Super methods can be accessed using `Class.methodName` and should be called with self.

		@example
			local Vehicle = _.class("Vehicle", function( wheelCount ) return 
				{
					speed = 0,
					wheelCount = wheelCount
				}
			end)
			-- Let's define a static private function to generate a unique id for each vehicle.
			function Vehicle._getNextId()
				Vehicle._nextId = Vehicle._nextId + 1
				return Vehicle._nextId
			end
			Vehicle._nextId = 0
			-- A general purpose init function may call other helper methods
			function Vehicle:_init()
				self.id = self:_generateId()
			end
			-- Assign an id to the new instance
			function Vehicle:_generateId()
				return _.format("#{}: {} wheels", Vehicle._getNextId(), self.wheelCount)
			end
			-- Let's make a Car class which has a special way to generate ids
			local Car = Vehicle:extend("Vehicle", function()
				return Vehicle.constructor(4)
			end)
			-- Uses the super method to generate a car-specific id
			function Car:_generateId()
				self.id = _.format("Car {}", Vehicle._generateId(self))
			end

			local car = Car.new()
			car.id --> "Car #1: 4 wheels"
	]]
	--: <S: T>(T: string, Constructor<T>? Decorator[]?) -> Class<S>
	function Class:extend(name, constructor, decorators)
		local SubClass = Classes.class(name, constructor or Class.new, decorators)
		setmetatable(SubClass, {__index = self})
		return SubClass
	end

	--[[
		Create a subclass of _Class_ with a new _name_ that inherits the metatable of _Class_,
		optionally overriding the _constructor_ and providing additional _decorators_.

		@usage Interfaces currently silently override super interfaces, even if their types
		are incompatible. Avoid doing this as more advanced type checking may throw if the types
		do not unify in the future.

		@example
			local Vehicle = _.classWithInterface("Vehicle", {
				speed = t.number,
				wheelCount = t.number,
				color: t.string
			})
			local vehicle = Vehicle.new({
				speed = 5,
				wheelCount = 4,
				color = "red"
			})
			_.pretty(vehicle) --> 'Vehicle {speed = 4, wheelCount = 4, color = "red"}'
	]]
	--: <S: T>(T: string, S, Decorator[]?) -> Class<S>
	function Class:extendWithInterface(name, interface, decorators)
		local function getComposableInterface(input)
			if input == nil then
				return function()
					return {}
				end
			elseif type(input) == "function" then
				return input
			else
				return function()
					return input
				end
			end
		end
		local inheritedInterface = self.interface
		local compositeInterface = function(Class)
			return Tables.assign({}, getComposableInterface(interface)(Class), getComposableInterface(inheritedInterface)(Class))
		end
		local SubClass = Classes.classWithInterface(name, compositeInterface, decorators)
		setmetatable(SubClass, {__index = self})
		return SubClass
	end

	--[[
		Return a string representation of the instance. By default this is the _name_ field (or the
		Class name if this is not defined), but the method can be overwridden.
	]]
	--: (T:) -> string
	function Class:toString()
		return self.name
	end

	--[[
		Returns `true` if `self` is considered equal to _other_. This replaces the `==` operator
		on instances of this class, and can be overwridden to provide a custom implementation.
	]]
	--: (T:) -> string
	function Class:equals(other)
		return rawequal(self, other)
	end

	--[[
		Returns `true` if `self` is considered less than  _other_. This replaces the `<` operator
		on instances of this class, and can be overwridden to provide a custom implementation.
	]]
	--: (T:) -> string
	function Class:__lt(other)
		return false
	end

	--[[
		Returns `true` if `self` is considered less than or equal to _other_. This replaces the
		`<=` operator on instances of this class, and can be overwridden to provide a custom
		implementation.
	]]
	--: (T:) -> string
	function Class:__le(other)
		return false
	end

	return decorate(Class)
end

--[[
	Create a class called _name_ that implements a specific strict interface which is asserted when
	any instance is created.

	Instead of using a constructor, an instance is initialized with a table containing the required
	fields. If an `_init` method is present on the instance, this is called afterwards, which has
	the added benefit over a constructor that `self` and the instance are well-defined.

	Optionally, you may provide an array of _decorators_ which compose and reduce the Class, adding
	additional functionality in the same way `_.class` does.

	@usage Rodash uses `t` by Osyris to perform runtime type assertions, which we recommend using during
	development and production code to catch errors quickly and fail fast. For more information
	about `t`, please visit [https://github.com/osyrisrblx/t](https://github.com/osyrisrblx/t).
	@usage If you want to instantiate private fields, we recommend using a static factory with a
		public interface, using `_.privatize` if appropriate.
	@see _.class
	@see _.privatize
]]
--: <T>(string, T, Decorator<T>[]? -> Class<T>)
function Classes.classWithInterface(name, interface, decorators)
	local function getImplementsInterface(currentInterface)
		local ok, problem = t.values(t.callback)(currentInterface)
		assert(ok, string.format([[BadInput: Class %s does not have a valid interface
%s]], name, tostring(problem)))
		return t.strictInterface(currentInterface)
	end
	local implementsInterface
	local Class =
		Classes.class(
		name,
		function(data)
			data = data or {}
			local ok, problem = implementsInterface(data)
			assert(ok, string.format([[BadInput: Class %s cannot be instantiated
%s]], name, tostring(problem)))
			return Tables.keyBy(
				data,
				function(_, key)
					return key
				end
			)
		end,
		decorators
	)
	implementsInterface =
		type(interface) == "function" and getImplementsInterface(interface(Class)) or getImplementsInterface(interface)
	Class.interface = interface
	return Class
end

--[[
	A decorator which adds a dictionary of functions to to a Class table.
	@example
		local CanBrake = {
			brake = function( self )
				self.speed = 0
			end
		}
		local Car = _.class("Car", function( speed )
			return {
				speed = speed
			}
		end, {_.mixin(CanBrake)})
		local car = Car.new(5)
		print(car.speed) --> 5
		car:brake()
		print(car.speed) --> 0
	@usage Include the return of this function in the decorators argument when creating a class.
]]
function Classes.mixin(fns)
	assert(t.table(fns), "BadInput: fns must be a table")
	return function(Class)
		Tables.assign(Class, fns)
		return Class
	end
end

--[[
	A decorator which runs _fn_ on each instance that is created of the class, returning
	the result of the function as the class instance.
	@example
		local Frozen = _.decorate(_.freeze)
		local StaticCar = _.class("StaticCar", function( speed )
			return {
				speed = speed
			}
		end, {Frozen})
		function StaticCar:brake()
			self.speed = 0
		end
		local car = Car.new(5)
		print(car.speed) --> 5
		car:brake() --!> ReadonlyKey: s
	@usage Include the return of this function in the decorators argument when creating a class.
]]
function Classes.decorate(fn)
	assert(Functions.isCallable(fn), "BadInput: fn must be callable")
	return function(Class)
		local underlyingNew = Class.new
		function Class.new(...)
			local instance = underlyingNew(...)
			return fn(instance)
		end
		return Class
	end
end

--[[
	A decorator which derives a `:clone()` method for the _Class_ that returns a shallow clone of
	the instance when called that has the same metatable as the instance it is called on.
	@example
		local Car =
			Classes.class(
			"Car",
			function(speed)
				return {
					speed = speed
				}
			end,
			{_.Clone}
		)
		function Car:brake()
			self.speed = 0
		end
		local car = Car.new(5)
		local carClone = car:clone()
		print(carClone.speed) --> 5
		carClone:brake()
		print(carClone.speed) --> 0
		print(car.speed) --> 5
]]
function Classes.Clone(Class)
	function Class:clone()
		local newInstance = Tables.clone(self)
		setmetatable(newInstance, getmetatable(self))
		return newInstance
	end
	return Class
end

--[[
	A decorator which derives the equality operator for the _Class_ so that any instances of the
	class which are shallow equal 
	@example
		local Car =
			Classes.class(
			"Car",
			function(speed)
				return {
					speed = speed
				}
			end,
			{_.ShallowEq}
		)
		function Car:brake()
			self.speed = 0
		end
		local fastCar = Car.new(500)
		local fastCar2 = Car.new(500)
		local slowCar = Car.new(5)
		print(fastCar == fastCar2) --> true
		print(fastCar == slowCar) --> false
]]
function Classes.ShallowEq(Class)
	function Class:equals(other)
		return Tables.shallowEqual(self, other)
	end
	return Class
end

--[[
	A decorator which derives an order for the _Class_ so that any instances of the class which
	can be compared using `<`, `<=`, `>` and  `>=`. To do this, it compares values of the two
	instances at the same keys, as defined by the order of the _keys_ passed in.
	@param keys (default = a sorted array of all the instance's keys)
	@example
		local Car =
			Classes.class(
			"Car",
			function(speed)
				return {
					speed = speed
				}
			end,
			{_.PartialOrd}
		)
		function Car:brake()
			self.speed = 0
		end
		local fastCar = Car.new(500)
		local fastCar2 = Car.new(500)
		local slowCar = Car.new(5)
		print(fastCar == fastCar2) --> true
		print(fastCar == slowCar) --> false
]]
function Classes.PartialOrd(keys)
	if keys then
		assert(Tables.isArray(keys), "BadInput: keys must be an array if defined")
	end
	return function(Class)
		function Class:equals(other)
			local instanceKeys = keys or Arrays.sort(Tables.keys(self))
			for _, key in ipairs(instanceKeys) do
				if self[key] ~= other[key] then
					return false
				end
			end
			return true
		end
		function Class:__le(other)
			local instanceKeys = keys or Arrays.sort(Tables.keys(self))
			for _, key in ipairs(instanceKeys) do
				if Arrays.defaultComparator(self[key], other[key]) then
					return true
				elseif Arrays.defaultComparator(other[key], self[key]) then
					return false
				end
				if self[key] ~= other[key] then
					return false
				end
			end
			return true
		end
		function Class:__lt(other)
			local instanceKeys = keys or Arrays.sort(Tables.keys(self))
			for _, key in ipairs(instanceKeys) do
				if Arrays.defaultComparator(self[key], other[key]) then
					return true
				elseif Arrays.defaultComparator(other[key], self[key]) then
					return false
				end
				if self[key] ~= other[key] then
					return true
				end
			end
			return false
		end
		return Class
	end
end

function Classes.ToString(keys)
	return function(Class)
		function Class:toString()
			local Strings = require(script.Parent.Strings)
			return Strings.format(
				"{}({})",
				Class.name,
				Tables.serialize(
					self,
					{
						keys = keys,
						omitKeys = {"Class"}
					}
				):sub(2, -2)
			)
		end
		return Class
	end
end

--[[
	Create an enumeration from an array string _keys_, provided in upper snake-case.

	An Enum is used when a value should only be one of a limited number of possible states.
	`_.enum` creates a string enum, which uses a name for each state so it is easy to refer to.
	For ease of use values in the enum are identical to their key.

	Enums are frozen and will throw if access to a missing key is attempted, helping to eliminate
	typos.

	Symbols are not used so that enum values are serializable.

	@param keys provided in upper snake-case.
	@example
		local TOGGLE = _.enum("ON", "OFF")
		local switch = TOGGLE.ON
		if switch == TOGGLE.ON then
			game.Workspace.RoomLight.Brightness = 1
		else
			game.Workspace.RoomLight.Brightness = 0
		end
	@see _.match
]]
--: <T>(string -> Enum<T>)
function Classes.enum(keys)
	local enum =
		Tables.keyBy(
		keys,
		function(key)
			assert(key:match("^[A-Z_]+$"), "BadInput: Enum keys must be defined as upper snake-case")
			return key
		end
	)
	Classes.finalize(enum)
	return Classes.freeze(enum)
end

--[[
	Given an _enum_ and _strategies_, a dictionary of functions keyed by enum values, `_.match`
	returns a function that will execute the strategy for any value provided.

	A strategy for every enum key must be implemented, and this helps prevent missing values
	from causing problems later on down the line.

	@example
		local TOGGLE = _.enum("ON", "OFF")
		local setLightTo = _.match(TOGGLE, {
			ON = function(light)
				light.Brightness = 1
			end,
			OFF = function(light)
				light.Brightness = 0
			end
		})

		-- This can be used to turn any light on or off:
		setLightTo(TOGGLE.ON, game.Workspace.RoomLight) -- Light turns on

		-- But will catch an invalid enum value:
		setLightTo("Dim", game.Workspace.RoomLight)
		--!> BadInput: enumValue must be an instance of enum
]]
--: <T: Iterable<K>, V>(Enum<T>, {[K]: () -> V}) -> K -> V
function Classes.match(enum, strategies)
	assert(t.table(enum), "BadInput: enum should be a table")
	assert(
		Tables.deepEqual(Arrays.sort(Tables.values(enum)), Arrays.sort(Tables.keys(strategies))),
		"BadInput: keys for strategies must match values for enum"
	)
	assert(t.values(t.callback)(strategies), "BadInput: strategies values must be functions")

	return function(enumValue, ...)
		assert(Classes.isA(enumValue, enum), "BadInput: enumValue must be an instance of enum")
		local strategy = strategies[enumValue]
		return strategy(...)
	end
end

--[[
	`_.finalize` takes _object_ and makes updating or accessing missing keys throw `FinalObject`.
	@example
		local drink = {
			mixer = "coke",
			spirit = "rum"
		}
		_.finalize(drink)
		drink.mixer = "soda"
		drink.mixer --> "soda"
		print(drink.syrup)
		--!> "FinalObject: Attempt to read missing key syrup to final object"
		drink.syrup = "peach"
		--!> "FinalObject: Attempt to add key mixer on final object"
]]
--: <T: table>(mut T -> T)
function Classes.finalize(object)
	local backend = getmetatable(object)
	local proxy = {
		__index = function(child, key)
			-- If there is an __index property use this to lookup and see if it exists first.
			if backend and backend.__index then
				local value
				if type(backend.__index) == "function" then
					value = backend.__index(child, key)
				else
					value = backend.__index[key]
				end
				if value ~= nil then
					return value
				end
			end
			error(string.format("FinalObject: Attempt to read missing key %s in final object", key))
		end,
		__newindex = function(child, key)
			error(string.format("FinalObject: Attempt to add key %s to final object", key))
		end
	}
	if backend then
		setmetatable(proxy, backend)
	end

	setmetatable(object, proxy)

	return object
end

--[[
	Create a symbol with a specified _name_.
	
	Symbols are useful when you want a value that isn't equal to any other type, for example if you
	want to store a unique property on an object that won't be accidentally accessed with a simple
	string lookup.
]]
--: <T>(string -> Symbol<T>)
function Classes.symbol(name)
	local symbol = {
		__symbol = name
	}
	setmetatable(
		symbol,
		{
			__tostring = function()
				return "Symbol(" .. name .. ")"
			end
		}
	)
	return symbol
end

--[[
	`_.freeze` takes _object_ and returns a new read-only version which prevents any values from
	being changed.
	
	Unfortunately you cannot iterate using `pairs` or `ipairs` on frozen objects because Lua 5.1
	does not support overwriting these in metatables. However, you can use `_.iterator` to get
	an iterator 

	Iterating functions in Rodash such as `_.map`, `_.filter` etc. can iterate over frozen objects
	without this. If you want to treat the objects as arrays use `_.iterator(frozenObjet, true)`
	explicitly.
	@example
		local drink = _.freeze({
			mixer = "coke",
			spirit = "rum"
		})
		print(drink.mixer) --> "coke"
		drink.mixer = "soda"
		--!> "ReadonlyKey: Attempt to write to a frozen key mixer"
		print(drink.syrup) --> nil
		drink.syrup = "peach"
		--!> "ReadonlyKey: Attempt to write to a frozen key peach"
	@see _.iterator
]]
--: <T: table>(T -> T)
function Classes.freeze(object)
	local proxy = {}
	setmetatable(
		proxy,
		{
			__index = function(child, key)
				return object[key]
			end,
			__newindex = function(child, key)
				error(string.format("ReadonlyKey: Attempt to write to a frozen key %s", key))
			end,
			__len = function(child)
				return #object
			end,
			__tostring = function(child)
				return "Freeze(" .. tostring(object) .. ")"
			end,
			__call = function(child, ...)
				return object(...)
			end,
			iterable = object
		}
	)
	return proxy
end

--[[
	Returns `true` if _value_ is an instance of _type_.

	Type can currently be either an _Enum_ or a _Class_ table. For instances of classes,
	`_.isA` will also return true if the instance is an instance of any sub-class.

	The function will catch any errors thrown during this check, returning false if so.

	@example
		local Vehicle = _.class("Vehicle", function( wheelCount ) return 
			{
				speed = 0,
				wheelCount = wheelCount
			}
		end)
		local car = Vehicle.new(4)
		Vehicle.isA(car) --> true
		Vehicle.isA(5) --> false

	@example
		local TOGGLE = _.enum("ON", "OFF")
		TOGGLE.isA("ON") --> true
		TOGGLE.isA(5) --> false

	@usage This is useful if you no nothing about _value_.
]]
--: <T>(any, Type<T> -> bool)
function Classes.isA(value, Type)
	local ok, isAType =
		pcall(
		function()
			local isEnum = type(value) == "string"
			if isEnum then
				local isEnumKeyDefined = type(Type[value]) == "string"
				return isEnumKeyDefined
			elseif type(value) == "table" then
				if value.__symbol and Type[value.__symbol] == value then
					return true
				end
				local metatable = getmetatable(value)
				while metatable do
					if metatable.__index == Type then
						return true
					end
					metatable = getmetatable(metatable.__index)
				end
			end
			return false
		end
	)
	return ok and isAType
end

return Classes
]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX9e04096f9bb249afa56dc2996127509c">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Functions</string>
					<string name="ScriptGuid">{b3faec9d-0959-43f1-9d5f-659306ae974b}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	Utility functions and building blocks for functional programming styles.
]]
local Tables = require(script.Parent.Tables)
local t = require(script.Parent.Parent.t)

local Functions = {}

--[[
	A simple function that does nothing, and returns nil.
	@usage Shorthand for `function() end`.
]]
--: () -> nil
function Functions.noop()
end

--[[
	A simple function that does nothing, but returns its input parameters.
	@trait Chainable
	@usage This is typically referred to as the "identity" function.
]]
--: <A>(...A -> ...A)
function Functions.id(...)
	return ...
end

--[[
	Returns a function that when called, returns the original input parameters.
	@trait Chainable
	@example
		findPlayer("builderman"):andThen(_.returns("Found Dave!"))
		--> "Found Dave!" (soon after)
	@usage Useful for when you want a callback to discard the arguments passed in and instead use static ones.
]]
--: <A>(...A -> () -> ...A)
function Functions.returns(...)
	local args = {...}
	return function()
		return unpack(args)
	end
end

--[[
	Return `true` if the _value_ is a function or a table with a `__call` entry in its metatable.
	@usage This is a more general test than checking purely for a function type.
]]
--: any -> bool
function Functions.isCallable(value)
	return type(value) == "function" or
		(type(value) == "table" and getmetatable(value) and getmetatable(value).__call ~= nil)
end

--[[
	Returns a function that wraps the input _fn_ but only passes the first argument to it.
]]
--: <A, B>((A -> B) -> A -> B)
function Functions.unary(fn)
	assert(Functions.isCallable(fn), "BadInput: fn must be callable")
	return function(first)
		return fn(first)
	end
end

--[[
	Returns a function that when called, throws the original message.
	@example
		findPlayer("builderman"):andThen(_.throws("DaveNotFound"))
		--!> "DaveNotFound" (soon after)
	@usage Useful for when you want a callback to discard the arguments passed in and instead use static ones.
]]
--: string -> () -> fail
function Functions.throws(errorMessage)
	assert(t.string(errorMessage), "BadInput: errorMessage must be a string")
	return function()
		error(errorMessage)
	end
end

--[[
	Takes a function _fn_ and binds _arguments_ to the head of the _fn_ argument list.
	Returns a function which executes _fn_, passing the bound arguments supplied, followed by any
	dynamic arguments.
	@example
		local function damagePlayer( player, amount )
			player:Damage(amount)
		end
		local damageLocalPlayer = _.bind(damagePlayer, game.Players.LocalPlayer)
		damageLocalPlayer(5)
]]
--: <A, B, R>(((A..., B... -> R), ...A) -> ...B -> R)
function Functions.bind(fn, ...)
	assert(Functions.isCallable(fn), "BadInput: fn must be callable")
	local args = {...}
	return function(...)
		return fn(unpack(args), ...)
	end
end

--[[
	Takes a chainable function _fn_ and binds _arguments_ to the tail of the _fn_ argument list.
	Returns a function which executes _fn_, passing a subject ahead of the bound arguments supplied.
	@example
		local filterHurtPlayers = _.bindTail(_.filter, function(player)
			return player.Health < player.MaxHealth
		end)
		local getName = _.bindTail(_.map, function(player)
			return player.Name
		end)
		local filterHurtNames = _.compose(filterHurtPlayers, getName)
		filterHurtNames(game.Players) --> {"Frodo", "Boromir"}	
	@usage Chainable rodash function feeds are mapped to `_.fn`, such as `_.fn.map(handler)`.
]]
--: <T, A>(Chainable<T, A>, ...A) -> T -> T
function Functions.bindTail(fn, ...)
	assert(Functions.isCallable(fn), "BadInput: fn must be callable")
	local args = {...}
	return function(subject)
		return fn(subject, unpack(args))
	end
end

--[[
	Returns a function that when called, only calls _fn_ the first time the function is called.
	For subsequent calls, the initial return of _fn_ is returned, even if it is `nil`.
	@returns the function with method `:clear()` that resets the cached value.
	@trait Chainable
	@example
		local fry = _.once(function(item)
			return "fried " .. tiem
		end)
		fry("sardine") --> "fried sardine"
		fry("squid") --> "fried sardine"
		fry:clear()
		fry("squid") --> "fried squid"
		fry("owl") --> "fried squid"
	@throws _passthrough_ - any error thrown when called will cause `nil` to cache and pass through the error.
	@usage Useful for when you want to lazily compute something expensive that doesn't change.
]]
--: <...A, B>((...A -> B), B?) -> Clearable & () -> B
function Functions.once(fn)
	assert(Functions.isCallable(fn), "BadInput: fn must be callable")
	local called = false
	local result = nil
	local once = {
		clear = function()
			called = false
			result = nil
		end
	}
	setmetatable(
		once,
		{
			__call = function(_, ...)
				if called then
					return result
				else
					called = true
					result = fn(...)
					return result
				end
			end
		}
	)
	return once
end

--[[
	Calls the supplied _fn_ on the subject and any additional arguments, returing the result.
	@trait Chainable
]]
-- <T, A, R>(T, (T, ...A -> R), ...A -> R)
function Functions.call(subject, fn, ...)
	assert(Functions.isCallable(fn), "BadInput: fn must be callable")
	return fn(subject, ...)
end

--[[
	Chain takes a dictionary of chainable functions and returns a Chain instance with
	methods mapped to the input functions.

	Chaining is useful when you want to simplify operating on data in a common form and perform
	sequences of operations on some data with a very concise syntax. An _actor_ function can
	check the value of the data at each step and change how the chain proceeds.
	
	Calling a _Chain_ with a subject reduces the chained operations in order on the subject. 
	@param actor called for each result in the chain to determine how the next operation should process it. (default = `_.invoke`)
	@example
		-- Define a simple chain that can operate a list of numbers.
		-- A chain function is called with the subject being processed as first argument,
		-- and any arguments passed in the chain as subsequent arguments.
		local numberChain = _.chain({
			addN = function(list, n)
				return _.map(list, function(element)
					return element + n
				end)
			end,
			sum = function(list)
				return _.sum(list)
			end
		})
		local op = numberChain:addN(2):sum()
		op({1, 2, 3}) --> 12
	@example
		-- Get the name of a player
		local function getName(player)
			return player.Name
		end)

		-- Create a chain that filters for hurt players and finds their name
		local filterHurtNames = _.fn:filter(function(player)
			return player.Health < player.MaxHealth
		end):map(getName)

		-- Run the chain on the current game players
		filterHurtNames(game.Players) --> {"Frodo Baggins", "Boromir"}

		-- For fun, let's encapsulate the functionality above by
		-- defining a chain of operations on players...
		local players = _.chain({
			filterHurtPlayers = _.fn:filter(function(player)
				return player.Health < player.MaxHealth
			end),
			-- Filter players by getting their name and checking it ends with 'Baggins'
			filterBaggins = _.fn:filter(_.fn:call(getName):endsWith("Baggins"))
		})

		local hurtHobbits = players:filterHurtPlayers():filterBaggins()
		hurtHobbits(game.Players) --> {{Name = "Frodo Baggins", ...}}

		local names = _.fn:map(getName)

		-- Chains are themselves chainable, so you can compose two chains together
		local filterHurtHobbitNames = _.compose(hurtHobbits, names)

		filterHurtHobbitNames(game.Players) --> {"Frodo Baggins"}
	@trait Chainable
	@usage The "Rodash" chain: `_.chain(_)` is aliased to `_.fn`, so instead of writing
	`_.chain(_):filter` you can simply write `_.fn:filter`, or any other chainable method.
	@usage A chained function can be made using `_.chain` or built inductively using other chained
		methods of `_.fn`.
	@usage A chainable method is one that has the subject which is passed through a chain as the
		first argument, and subsequent arguments
	@see _.chainFn - Makes a function chainable if it returns a chain.
	@see _.invoke - the identity actor
	@see _.continue - an actor for chains of asynchronous functions
	@see _.maybe - an actor for chains of partial functions
]]
--: <T>(T{}, Actor<T>) -> Chain<T>
function Functions.chain(fns, actor)
	if actor == nil then
		actor = Functions.invoke
	end
	assert(Functions.isCallable(actor), "BadInput: actor must be callable")
	local chain = {}
	setmetatable(
		chain,
		{
			__index = function(self, name)
				local fn = fns[name]
				assert(Functions.isCallable(fn), "BadFn: Chain key " .. tostring(name) .. " is not callable")
				local feeder = function(parent, ...)
					assert(type(parent) == "table", "BadCall: Chain functions must be called with ':'")
					local stage = {}
					local op = Functions.bindTail(fn, ...)
					setmetatable(
						stage,
						{
							__index = chain,
							__call = function(self, subject)
								local value = parent(subject)
								return actor(op, value)
							end,
							__tostring = function()
								return tostring(parent) .. "::" .. name
							end
						}
					)
					return stage
				end
				return feeder
			end,
			__newindex = function()
				error("ReadonlyKey: Cannot assign to a chain, create one with _.chain instead.")
			end,
			__call = function(_, subject)
				return subject
			end,
			__tostring = function()
				return "Chain"
			end
		}
	)
	return chain
end

--[[
	Wraps a function, making it chainable if it returns a chain itself.

	This allows you to define custom functions in terms of the arguments they will take when called
	in a chain, and return a chained function which performs the operation, rather than explicitly
	taking the subject as first argument.
	@example
		-- In the chain example addN was defined like so:
		local function addN(list, n)
			return _.map(list, function(element)
				return element + n
			end)
		end
		numberChain = _.chain({
			addN = addN
		})
		local op = numberChain:addN(2):sum()
		op({1, 2, 3}) --> 12

		-- It is more natural to define addN as a function taking one argument,
		-- to match the way it is called in the chain:
		local function addN(n)
			-- Methods on _.fn are themselves chained, so "list" can be dropped.
			return _.fn:map(function(element)
				return element + n
			end)
		end
		-- The _.chainFn is used to wrap any functions which return chains.
		numberChain = _.chain({
			addN = _.chainFn(addN)
		})
		local op = numberChain:addN(2):sum()
		op({1, 2, 3}) --> 12

	@see _.chain
]]
-- <T, A, R>((...A -> T -> R) -> T, ...A -> R)
function Functions.chainFn(fn)
	assert(Functions.isCallable(fn), "BadInput: fn must be callable")
	return function(source, ...)
		return fn(...)(source)
	end
end

--[[
	An actor which calls the supplied _fn_ with the argument tail.
	@usage This is the default _actor_ for `_.chain` and acts as an identity, meaning it has no effect on the result.
]]
--: <T>(Actor<T>)
function Functions.invoke(fn, ...)
	assert(Functions.isCallable(fn), "BadInput: fn must be callable")
	return fn(...)
end

--[[
	An actor which cancels execution of a chain if a method returns nil, evaluating the chain as nil.

	Can wrap any other actor which handles values that are non-nil.
	@example 
		-- We can define a chain of Rodash functions that will skip after a nil is returned.
		local maybeFn = _.chain(_, _.maybe())
		local getName = function(player)
			return player.Name
		end
		local players
		players =
			_.chain(
			{
				-- Any chainable functions can be used
				call = _.call,
				endsWith = _.endsWith,
				filterHurt = _.fn:filter(
					function(player)
						return player.Health < 100
					end
				),
				filterBaggins = _.chainFn(
					function()
						-- If getName returns nil here, endsWith will be skipped
						return _.fn:filter(maybeFn:call(getName):endsWith("Baggins"))
					end
				)
			}
		)
		local hurtHobbits = players:filterHurt():filterBaggins()
		local mapNames = _.fn:map(getName)
		local filterHurtBagginsNames = _.compose(hurtHobbits, mapNames)
		-- Here, one player record doesn't have a Name property, so it is skipped.
		local crew = {
			{
				Name = "Frodo Baggins",
				Health = 50
			},
			{
				Name = "Bilbo Baggins",
				Health = 100
			},
			{
				Health = 0
			}
		}
]]
--: <T>(Actor<T>) -> Actor<T>
function Functions.maybe(actor)
	actor = actor or Functions.invoke
	assert(Functions.isCallable(actor), "BadInput: actor must be callable")
	return function(fn, ...)
		local args = {...}
		if args[1] == nil then
			return
		else
			return actor(fn, ...)
		end
	end
end

--[[
	An actor getter which awaits on any promises returned by chain methods, and continues execution
	when the promise completes.

	This allows any asynchronous methods to be used in chains without modifying any of the chain's
	synchronous methods, removing any boilerplate needed to handle promises in the main code body.
	
	Can wrap any other actor which handles values after any promise resolution.
	@param actor (default = `_.invoke`) The actor to wrap.
	@example
		-- Let's define a function which returns an answer after a delay
		local getName = function(player)
			return _.delay(1):andThen(_.returns(player.Name))
		end
		local players
		players =
			_.chain(
			{
				-- Any chainable function can be used
				filter = _.filter,
				-- A chain which evaluates a promise of the player names
				mapNames = _.fn:map(getName):parallel(),
				filterHurt = _.fn:filter(
					function(player)
						return player.Health < 100
					end
				),
				mapNameIf = _.chainFn(
					function(expectedName)
						-- Methods on self work as expected
						return players:mapNames():filter(_.fn:endsWith(expectedName))
					end
				)
			},
			_.continue()
		)
		local filterHurtHobbitNames = players:filterHurt():mapNameIf("Baggins")
		local crew = {
			{
				Name = "Frodo Baggins",
				Health = 50
			},
			{
				Name = "Bilbo Baggins",
				Health = 100
			},
			{
				Name = "Boromir",
				Health = 0
			}
		}
		filterHurtHobbitNames(crew):await() --> {"Frodo Baggins"} (some time later)
	@rejects passthrough
	@see _.chain
]]
--: <T>(Actor<T>) -> Actor<T>
function Functions.continue(actor)
	actor = actor or Functions.invoke
	assert(Functions.isCallable(actor), "BadInput: actor must be callable")
	return function(fn, value, ...)
		local Async = require(script.Parent.Async)
		return Async.resolve(value):andThen(
			function(...)
				return actor(fn, ...)
			end
		)
	end
end

local getRodashChain =
	Functions.once(
	function(rd)
		return Functions.chain(rd)
	end
)
Functions.fn = {}
setmetatable(
	Functions.fn,
	{
		__index = function(self, key)
			local rd = require(script.Parent)
			return getRodashChain(rd)[key]
		end,
		__call = function(self, subject)
			return subject
		end,
		__tostring = function()
			return "fn"
		end
	}
)

--[[
	Returns a function that calls the argument functions in left-right order on an input, passing
	the return of the previous function as argument(s) to the next.
	@example
		local function fry(item) return "fried " .. item end
		local function cheesify(item) return "cheesy " .. item end
		local prepare = _.compose(fry, cheesify)
		prepare("nachos") --> "cheesy fried nachos"
	@usage Useful for when you want to lazily compute something expensive that doesn't change.
	@trait Chainable
]]
--: <A>((...A -> ...A)[]) -> ...A -> A
function Functions.compose(...)
	local fnCount = select("#", ...)
	if fnCount == 0 then
		return Functions.id
	end
	local fns = {...}
	return function(...)
		local result = {fns[1](...)}
		for i = 2, fnCount do
			result = {fns[i](unpack(result))}
		end
		return unpack(result)
	end
end

--[[
	Like `_.once`, but caches non-nil results of calls to _fn_ keyed by some serialization of the
	input arguments to _fn_. By default, all the args are serialized simply using `tostring`.

	Optionally memoize takes `function serializeArgs(args, cache)`, a function that should return a string key which a
	result should be cached at for a given signature. Return nil to avoid caching the result.

	@param serializeArgs (default = `_.serialize`)
	@returns the function with method `:clear(...)` that resets the cache for the argument specified, or `:clearAll()` to clear the entire cache.
	@example
		local menu = {"soup", "bread", "butter"}
		local heat = _.memoize(function(index)
			return "hot " ... menu[index]
		end)

		heat(1) --> "hot soup"

		menu = {"caviar"}
		heat(1) --> "hot soup"
		heat(2) --> nil

		menu = {"beef", "potatoes"}
		heat(1) --> "hot soup"
		heat(2) --> "hot potatoes"

		heat:clear(1)
		heat(1) --> "hot beef"
	@see _.serialize
	@see _.serializeDeep if you want to recursively serialize arguments.
]]
--: <...A, B>((...A -> B), ...A -> string?) -> Clearable<...A> & AllClearable & (...A) -> B
function Functions.memoize(fn, serializeArgs)
	assert(Functions.isCallable(fn), "BadInput: fn must be callable")
	serializeArgs = serializeArgs or Functions.unary(Tables.serialize)
	assert(Functions.isCallable(serializeArgs), "BadInput: serializeArgs must be callable or nil")
	local cache = {}
	local clearable = {
		clear = function(_, ...)
			local cacheKey = serializeArgs({...}, cache)
			if cacheKey then
				cache[cacheKey] = nil
			end
		end,
		clearAll = function()
			cache = {}
		end
	}
	setmetatable(
		clearable,
		{
			__call = function(_, ...)
				local cacheKey = serializeArgs({...}, cache)
				if cacheKey == nil then
					return fn(...)
				else
					if cache[cacheKey] == nil then
						cache[cacheKey] = fn(...)
					end
					return cache[cacheKey]
				end
			end
		}
	)
	return clearable
end

--[[
	Like `delay`, this calls _fn_ after _delayInSeconds_ time has passed, with the added benefit of being cancelable.
	@returns an instance which `:clear()` can be called on to prevent _fn_ from firing.
]]
--: (() -> nil), number -> Clearable
function Functions.setTimeout(fn, delayInSeconds)
	assert(Functions.isCallable(fn), "BadInput: fn must be callable")
	assert(t.number(delayInSeconds), "BadInput: delayInSeconds must be a number")
	local cleared = false
	local timeout
	delay(
		delayInSeconds,
		function()
			if not cleared then
				fn(timeout)
			end
		end
	)
	timeout = {
		clear = function()
			cleared = true
		end
	}
	return timeout
end

--[[
	Like `_.setTimeout` but calls _fn_ after every interval of _intervalInSeconds_ time has passed.
	@param delayInSeconds (default = _intervalInSeconds_) The delay before the initial call.
	@returns an instance which `:clear()` can be called on to prevent _fn_ from firing.
]]
--: (() -> nil), number, number? -> Clearable
function Functions.setInterval(fn, intervalInSeconds, delayInSeconds)
	assert(Functions.isCallable(fn), "BadInput: fn must be callable")
	assert(t.number(intervalInSeconds), "BadInput: intervalInSeconds must be a number")
	assert(t.optional(t.number)(delayInSeconds), "BadInput: delayInSeconds must be a number")
	local timeout
	local callTimeout
	local function handleTimeout()
		callTimeout()
		fn(timeout)
	end
	callTimeout = function()
		timeout = Functions.setTimeout(handleTimeout, intervalInSeconds)
	end
	if delayInSeconds ~= nil then
		timeout = Functions.setTimeout(handleTimeout, delayInSeconds)
	else
		callTimeout()
	end

	return {
		clear = function()
			timeout:clear()
		end
	}
end

--[[
	Creates a debounced function that delays calling _fn_ until after _delayInSeconds_ seconds have
	elapsed since the last time the debounced function was attempted to be called.
	@returns the debounced function with method `:clear()` can be called on to cancel any scheduled call.
	@usage A nice [visualisation of debounce vs. throttle](http://demo.nimius.net/debounce_throttle/), 
		the illustrated point being debounce will only call _fn_ at the end of a spurt of events.
]]
--: <A, B>((...A) -> B), number -> Clearable & (...A) -> B
function Functions.debounce(fn, delayInSeconds)
	assert(Functions.isCallable(fn), "BadInput: fn must be callable")
	assert(type(delayInSeconds) == "number", "BadInput: delayInSeconds must be a number")

	local lastResult = nil
	local timeout

	local debounced = {
		clear = function()
			if timeout then
				timeout:clear()
			end
		end
	}
	setmetatable(
		debounced,
		{
			__call = function(_, ...)
				local args = {...}
				if timeout then
					timeout:clear()
				end
				timeout =
					Functions.setTimeout(
					function()
						lastResult = fn(unpack(args))
					end,
					delayInSeconds
				)
				return lastResult
			end
		}
	)
	return debounced
end

--[[
	Creates a throttle function that drops any repeat calls within a cooldown period and instead
	returns the result of the last call.
	@usage A nice [visualisation of debounce vs. throttle](http://demo.nimius.net/debounce_throttle/),
		the illustrated point being throttle will call _fn_ every period during a spurt of events.
]]
--: <A, B>((...A) -> B), number -> ...A -> B
function Functions.throttle(fn, cooldownInSeconds)
	assert(Functions.isCallable(fn), "BadInput: fn must be callable")
	assert(type(cooldownInSeconds) == "number", "BadInput: cooldownInSeconds must be a number > 0")
	assert(cooldownInSeconds > 0, "BadInput: cooldownInSeconds must be a number > 0")

	local cached = false
	local lastResult = nil
	return function(...)
		if not cached then
			cached = true
			lastResult = fn(...)
			Functions.setTimeout(
				function()
					cached = false
				end,
				cooldownInSeconds
			)
		end
		return lastResult
	end
end

return Functions
]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX908b4924fc8b452c9ca0dbf1a86d3216">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Strings</string>
					<string name="ScriptGuid">{8191d0f6-0cff-452f-9ece-58fb065c5697}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	Useful functions to manipulate strings, based on similar implementations in other standard libraries.
]]
local t = require(script.Parent.Parent.t)
local Functions = require(script.Parent.Functions)
local Tables = require(script.Parent.Tables)
local Strings = {}
local insert = table.insert
local concat = table.concat

local function assertStrIsString(str)
	assert(t.string(str), "BadInput: str must be a string")
end

--[[
	Convert `str` to camel-case.
	@example _.camelCase('Pepperoni Pizza') --> 'pepperoniPizza'
	@example _.camelCase('--pepperoni-pizza--') --> 'pepperoniPizza'
	@example _.camelCase('__PEPPERONI_PIZZA') --> 'pepperoniPizza'
	@trait Chainable
]]
--: string -> string
function Strings.camelCase(str)
	assertStrIsString(str)
	return str:gsub(
		"(%a)([%w]*)",
		function(head, tail)
			return head:upper() .. tail:lower()
		end
	):gsub("%A", ""):gsub("^%u", string.lower)
end

--[[
	Convert `str` to kebab-case, making all letters lowercase.
	@example _.kebabCase('strongStilton') --> 'strong-stilton'
	@example _.kebabCase(' Strong Stilton ') --> 'strong-stilton'
	@example _.kebabCase('__STRONG_STILTON__') --> 'strong-stilton'
	@usage Chain with `:upper()` if you need an upper kebab-case string.
	@trait Chainable
]]
--: string -> string
function Strings.kebabCase(str)
	assertStrIsString(str)
	return str:gsub(
		"(%l)(%u)",
		function(a, b)
			return a .. "-" .. b
		end
	):gsub("%A", "-"):gsub("^%-+", ""):gsub("%-+$", ""):lower()
end

--[[
	Convert `str` to snake-case, making all letters uppercase.
	@example _.snakeCase('sweetChickenCurry') --> 'SWEET_CHICKEN_CURRY'
	@example _.snakeCase(' Sweet Chicken  Curry ') --> 'SWEET_CHICKEN__CURRY'
	@example _.snakeCase('--sweet-chicken--curry--') --> 'SWEET_CHICKEN__CURRY'
	@usage Chain with `:lower()` if you need a lower snake-case string.
	@trait Chainable
]]
function Strings.snakeCase(str)
	assertStrIsString(str)
	return str:gsub(
		"(%l)(%u)",
		function(a, b)
			return a .. "_" .. b
		end
	):gsub("%A", "_"):gsub("^_+", ""):gsub("_+$", ""):upper()
end

--[[
	Convert `str` to title-case, where the first letter of each word is capitalized.
	@example _.titleCase("jello world") --> "Jello World"
	@example _.titleCase("yellow-jello with_sprinkles") --> "Yellow-jello With_sprinkles"
	@example _.titleCase("yellow jello's don’t mellow") --> "Yellow Jello's Dont’t Mellow"
	@usage Dashes, underscores and apostraphes don't break words.
	@trait Chainable
]]
function Strings.titleCase(str)
	assertStrIsString(str)
	return str:gsub(
		"(%a)([%w_%-'’]*)",
		function(head, tail)
			return head:upper() .. tail
		end
	)
end

--[[
	Capitalize the first letter of `str`.
	@example _.capitalize("hello mould") --> "Hello mould"
	@trait Chainable
]]
function Strings.capitalize(str)
	assertStrIsString(str)
	return str:gsub("^%l", string.upper)
end

--[==[
	Converts the characters `&<>"'` in `str` to their corresponding HTML entities.
	@example _.encodeHtml([[Pease < Bacon > "Fish" & 'Chips']]) --> "Peas &lt; Bacon &gt; &quot;Fish&quot; &amp; &apos;Chips&apos;"
	@trait Chainable
]==]
function Strings.encodeHtml(str)
	assertStrIsString(str)
	local entities = {["<"] = "lt", [">"] = "gt", ["&"] = "amp", ['"'] = "quot", ["'"] = "apos"}
	local result = str:gsub(
		".",
		function(char)
			return entities[char] and ("&" .. entities[char] .. ";") or char
		end
	)
	return result
end

--[==[
	The inverse of `_.encodeHtml`.
	Converts any HTML entities in `str` to their corresponding characters.
	@example _.decodeHtml("&lt;b&gt;&#34;Smashed&quot;&lt;/b&gt; &apos;Avocado&#39; &#x1F60F;") --> [[<b>"Smashed"</b> 'Avocado' 😏]]
	@trait Chainable
]==]
function Strings.decodeHtml(str)
	assertStrIsString(str)
	local entities = {lt = "<", gt = ">", amp = "&", quot = '"', apos = "'"}
	local result = str:gsub(
		"(&(#?x?)([%d%a]+);)",
		function(original, hashPrefix, code)
			return (hashPrefix == "" and entities[code]) or
				(hashPrefix == "#x" and tonumber(code, 16)) and utf8.char(tonumber(code, 16)) or
				(hashPrefix == "#" and tonumber(code)) and utf8.char(code) or
				original
		end
	)
	return result
end

--[[
	Splits `str` into parts based on a pattern delimiter and returns a table of the parts, followed
	by a table of the matched delimiters.
	@example _.splitOn("rice") --> {"r", "i", "c", "e"}, {"", "", "", ""}
	@example _.splitOn("one.two::flour", "[.:]") --> {"one", "two", "", "flour"}, {".", ":", ":"}
	@usage This method is useful only when you need a _pattern_ as a delimiter.
	@usage Use the Roblox native `string.split` if you are splitting on a simple string.
	@param delimiter (default = "")
	@trait Chainable
]]
--: string, pattern -> string[], string[]
function Strings.splitOn(str, pattern)
	assertStrIsString(str)
	assert(t.optional(t.string)(pattern), "BadInput: pattern must be a string or nil")
	local result = {}
	local delimiters = {}
	local from = 1
	if not pattern then
		for i = 1, #str do
			insert(result, str:sub(i, i))
		end
		return result
	end
	local delimiterStart, delimiterEnd = str:find(pattern, from)
	while delimiterStart do
		insert(delimiters, str:sub(delimiterStart, delimiterEnd))
		insert(result, str:sub(from, delimiterStart - 1))
		from = delimiterEnd + 1
		delimiterStart, delimiterEnd = str:find(pattern, from)
	end
	insert(result, str:sub(from))
	return result, delimiters
end

--[[
	Removes any spaces from the start and end of `str`.
	@example _.trim("  roast veg  ") --> "roast veg"
	@trait Chainable
]]
--: string -> string
function Strings.trim(str)
	assertStrIsString(str)
	return str:match("^%s*(.-)%s*$")
end

--[[
	Checks if `str` starts with the string `start`.
	@example _.startsWith("Fun Roblox Games", "Fun") --> true
	@example _.startsWith("Chess", "Fun") --> false
	@trait Chainable
]]
--: string, string -> bool
function Strings.startsWith(str, prefix)
	assertStrIsString(str)
	assert(t.string(prefix), "BadInput: prefix must be a string")
	return str:sub(1, prefix:len()) == prefix
end

--[[
	Checks if `str` ends with the string `suffix`.
	@example _.endsWith("Fun Roblox Games", "Games") --> true
	@example _.endsWith("Bad Roblox Memes", "Games") --> false
	@trait Chainable
]]
--: string, string -> bool
function Strings.endsWith(str, suffix)
	assertStrIsString(str)
	assert(t.string(suffix), "BadInput: suffix must be a string")
	return str:sub(-suffix:len()) == suffix
end

--[[
	Makes a string of `length` from `str` by repeating characters from `prefix` at the start of the string.
	@example _.leftPad("toast", 6) --> " toast"
	@example _.leftPad("2", 2, "0") --> "02"
	@example _.leftPad("toast", 10, ":)") --> ":):):toast"
	@param prefix (default = `" "`)
	@trait Chainable
]]
--: string, number, string -> string
function Strings.leftPad(str, length, prefix)
	assertStrIsString(str)
	assert(t.number(length), "BadInput: length must be a number")
	assert(t.optional(t.string)(prefix), "BadInput: prefix must be a string or nil")
	prefix = prefix or " "
	local padLength = length - #str
	local remainder = padLength % #prefix
	local repetitions = (padLength - remainder) / #prefix
	return string.rep(prefix or " ", repetitions) .. prefix:sub(1, remainder) .. str
end

--[[
	Makes a string of `length` from `str` by repeating characters from `suffix` at the end of the string.
	@example _.rightPad("toast", 6) --> "toast "
	@example _.rightPad("2", 2, "!") --> "2!"
	@example _.rightPad("toast", 10, ":)") --> "toast:):):"
	@param suffix (default = `" "`)
	@trait Chainable
]]
--: string, number, string -> string
function Strings.rightPad(str, length, suffix)
	assertStrIsString(str)
	assert(t.number(length), "BadInput: length must be a number")
	assert(t.optional(t.string)(suffix), "BadInput: suffix must be a string or nil")
	suffix = suffix or " "
	local padLength = length - #str
	local remainder = padLength % #suffix
	local repetitions = (padLength - remainder) / #suffix
	return str .. string.rep(suffix or " ", repetitions) .. suffix:sub(1, remainder)
end

--[[
	This function first calls `_.format` on the arguments provided and then outputs the response
	to the debug target, set using `_.setDebug`. By default, this function does nothing, allowing
	developers to leave the calls in the source code if that is beneficial.
	@param subject the format match string
	@usage A common pattern would be to `_.setDebug()` to alias to `print` during local development,
		and call e.g. `_.setDebug(_.bind(HttpService.PostAsync, "https://example.com/log"))`
		on a production build to allow remote debugging.
]]
function Strings.debug(subject, ...)
	if Strings.debugTarget == nil then
		return
	end
	Strings.debugTarget(Strings.format(...))
end

--[[
	Hooks up any debug methods to invoke _fn_. By default, `_.debug` does nothing.
	@param fn (default = `print`)
	@usage Calling `_.setDebug()` will simply print all calls to `_.debug` with formatted arguments.
]]
function Strings.setDebug(fn)
	Strings.debugTarget = fn
end

--[[
	Converts _char_ into a hex representation
	@param format (optional) a string passed to `_.format` which formats the hex value of each of the character's code points.
	@param useBytes (default = false) whether to use the character's bytes, rather than UTF-8 code points.
	@example _.charToHex("<") --> "3C"
	@example _.charToHex("<", "&#{};") --> "&#3C;"
	@example _.charToHex("😏") --> "1F60F"
	@example _.charToHex("😏", "0x{}") --> "0x1F60F"
	@example _.charToHex("🤷🏼‍♀️", "&#x{};") --> "&#x1F937;&#x1F3FC;&#x200D;&#x2640;&#xFE0F;"
	@example _.charToHex("🤷🏼‍♀️", "%{}", true) --> "%F0%9F%A4%B7%F0%9F%8F%BC%E2%80%8D%E2%99%80%EF%B8%8F"
]]
--: char -> str, str?, boolean?
function Strings.charToHex(char, format, useBytes)
	assert(t.string(char), "BadInput: char must be a single utf8 character string")
	local values = {}
	if useBytes then
		for i = 1, char:len() do
			insert(values, char:byte(i))
		end
	else
		for position, codePoint in utf8.codes(char) do
			insert(values, codePoint)
		end
	end
	return concat(
		Tables.map(
			values,
			function(value)
				local hexValue = string.format("%X", value)
				return format and Strings.format(format, hexValue) or hexValue
			end,
			""
		)
	)
end

--[[
	Generates a character from its _hex_ representation.
	@example _.hexToChar("1F60F") --> "😏"
	@example _.hexToChar("%1F60F") --> "😏"
	@example _.hexToChar("#1F60F") --> "😏"
	@example _.hexToChar("0x1F60F") --> "😏"
	@throws _MalformedInput_ if _char_ is not a valid encoding.
]]
--: str -> char
function Strings.hexToChar(hex)
	assert(t.string(hex), "BadInput: hex must be a string")
	if hex:sub(0, 1) == "%" or hex:sub(0, 1) == "#" then
		hex = hex:sub(2)
	elseif hex:sub(0, 2) == "0x" then
		hex = hex:sub(3)
	end
	return utf8.char(tonumber(hex, 16)) or error("MalformedInput")
end

--[[
	Encodes _str_ for use as a URL, for example as an entire URL.
	@trait Chainable
	@example
		_.encodeUrl("https://example.com/Egg+Fried Rice!?🤷🏼‍♀️")
		--> "https://example.com/Egg+Fried%20Rice!?%F0%9F%A4%B7%F0%9F%8F%BC%E2%80%8D%E2%99%80%EF%B8%8F"
	@usage
		This method is designed to act like `encodeURI` in JavaScript.
]]
--: string -> string
function Strings.encodeUrl(str)
	assertStrIsString(str)
	local result = {}
	for _, codePoint in utf8.codes(str) do
		local char = utf8.char(codePoint)
		if char:match("^[%;%,%/%?%:%@%&%=%+%$%w%-%_%.%!%~%*%'%(%)%#]$") then
			table.insert(result, char)
		else
			table.insert(result, Strings.charToHex(char, "%{}", true))
		end
	end
	return table.concat(result, "")
end

--[[
	Encodes _str_ for use in a URL, for example as a query parameter of a URL.
	@trait Chainable
	@example
		_.encodeUrlComponent("https://example.com/Egg+Fried Rice!?🤷🏼‍♀️")
		--> "https%3A%2F%2Fexample.com%2FEgg%2BFried%20Rice!%3F%F0%9F%A4%B7%F0%9F%8F%BC%E2%80%8D%E2%99%80%EF%B8%8F"
	@usage
		This method is designed to act like `encodeURIComponent` in JavaScript.
	@usage
		This is very similar to `HttpService.EncodeUrl`, but is included for parity and conforms closer to the standard (e.g. EncodeUrl unnecessarily encodes `!`).
]]
--: string -> string
function Strings.encodeUrlComponent(str)
	assertStrIsString(str)
	local result = {}
	for _, codePoint in utf8.codes(str) do
		local char = utf8.char(codePoint)
		if char:match("^[%;%,%/%?%:%@%&%=%+%$%w%-%_%.%!%~%*%'%(%)%#]$") then
			table.insert(result, char)
		else
			table.insert(result, Strings.charToHex(char, "%{}", true))
		end
	end
	return table.concat(result, "")
end

local calculateDecodeUrlExceptions =
	Functions.once(
	function()
		local exceptions = {}
		for char in ("#$&+,/:;=?@"):gmatch(".") do
			exceptions[string.byte(char)] = true
		end
		return exceptions
	end
)

--[[
	The inverse of `_.encodeUrl`.
	@trait Chainable
	@example
		_.decodeUrl("https://Egg+Fried%20Rice!?")
		--> "https://Egg+Fried Rice!?"
	@usage
		This method is designed to act like `decodeURI` in JavaScript.
]]
--: string -> string
function Strings.decodeUrl(str)
	assertStrIsString(str)
	local exceptions = calculateDecodeUrlExceptions()
	return str:gsub(
		"%%(%x%x)",
		function(term)
			local charId = tonumber(term, 16)
			if not exceptions[charId] then
				return utf8.char(charId)
			end
		end
	)
end

--[[
	The inverse of `_.encodeUrlComponent`.
	@trait Chainable
	@example
		_.decodeUrlComponent("https%3A%2F%2FEgg%2BFried%20Rice!%3F")
		--> "https://Egg+Fried Rice!?"
	@usage This method is designed to act like `decodeURIComponent` in JavaScript.
	@throws _MalformedInput_ if _str_ contains characters encoded incorrectly.
]]
--: string -> string
function Strings.decodeUrlComponent(str)
	assertStrIsString(str)
	return str:gsub("%%(%x%x)", Strings.hexToChar)
end

--[[
	Takes a _query_ dictionary of key-value pairs and builds a query string that can be concatenated
	to the end of a url.
	
	@example
		_.encodeQueryString({
			time = 11,
			biscuits = "hob nobs",
			chocolatey = true
		})) --> "?biscuits=hob+nobs&time=11&chocolatey=true"

	@usage A query string which contains duplicate keys with different values is technically valid, but this function doesn't provide a way to produce them.
]]
--: <K,V>(Iterable<K,V> -> string)
function Strings.encodeQueryString(query)
	assert(t.table(query), "BadInput: query must be a table")
	local fields =
		Tables.mapValues(
		query,
		function(value, key)
			return Strings.encodeUrlComponent(tostring(key)) .. "=" .. Strings.encodeUrlComponent(tostring(value))
		end
	)
	return ("?" .. concat(fields, "&"))
end

--[[
	Returns the _format_ string with placeholders `{...}` substituted with readable representations
	of the subsequent arguments.

	This function is a simpler & more powerful version of `string.format`, inspired by `format!`
	in Rust.
	
	* `{}` formats and prints the next argument using `:format()` if available, or a suitable
		default representation depending on its type.
	* `{2}` formats and prints the 2nd argument.
	* `{#2}` prints the length of the 2nd argument.

	Display parameters can be combined after a `:` in the curly braces. Any format parameters used
	in `string.format` can be used here, along with these extras:

	* `{:?}` formats any value using `_.serializeDeep`.
	* `{:#?}` formats any value using `_.pretty`.
	* `{:b}` formats a number in its binary representation.
	@example
		local props = {"teeth", "claws", "whiskers", "tail"}
		_.format("{:?} is in {:#?}", "whiskers", props)
		-> '"whiskers" is in {"teeth", "claws", "whiskers", "tail"}'
	@example
		_.format("{} in binary is {1:b}", 125) -> "125 in binary is 110100"
	@example
		_.format("The time is {:02}:{:02}", 2, 4) -> "The time is 02:04"
	@example
		_.format("The color blue is #{:06X}", 255) -> "The color blue is #0000FF"
	@usage Escape `{` with `{{` and `}` similarly with `}}`.
	@usage See [https://developer.roblox.com/articles/Format-String](https://developer.roblox.com/articles/Format-String)
		for complete list of formating options and further use cases.
	@see _.serializeDeep
	@see _.pretty
]]
--: string, ...any -> string
function Strings.format(format, ...)
	local args = {...}
	local argIndex = 1
	local texts, subs = Strings.splitOn(format, "{[^{}]*}")
	local result = {}
	for i, text in pairs(texts) do
		local unescaped = text:gsub("{{", "{"):gsub("}}", "}")
		insert(result, unescaped)
		local placeholder = subs[i] and subs[i]:sub(2, -2)
		if placeholder then
			local escapeMatch = text:gmatch("{+$")()
			local isEscaped = escapeMatch and #escapeMatch % 2 == 1
			if not isEscaped then
				local placeholderSplit = Strings.splitOn(placeholder, ":")
				local isLength = Strings.startsWith(placeholderSplit[1], "#")
				local argString = isLength and placeholderSplit[1]:sub(2) or placeholderSplit[1]
				local nextIndex = tonumber(argString)
				local displayString = placeholderSplit[2]
				local arg
				if nextIndex then
					arg = args[nextIndex]
				else
					arg = args[argIndex]
					argIndex = argIndex + 1
				end
				if isLength then
					arg = #arg
				end
				insert(result, Strings.formatValue(arg, displayString or ""))
			else
				local unescapedSub = placeholder
				insert(result, unescapedSub)
			end
		end
	end
	return table.concat(result, "")
end

local function octalToBinary(number)
	local binaryEight = {
		["1"] = "000",
		["2"] = "001",
		["3"] = "010",
		["4"] = "011",
		["5"] = "100",
		["6"] = "101",
		["7"] = "110",
		["8"] = "111"
	}
	return string.format("%o", number):gsub(
		".",
		function(char)
			return binaryEight[char]
		end
	):gsub("^0+", "")
end

--[[
	Format a specific _value_ using the specified _displayString_.
]]
--: any, DisplayString -> string
function Strings.formatValue(value, displayString)
	local displayTypeStart, displayTypeEnd = displayString:find("[A-Za-z#?]+")
	if displayTypeStart then
		local displayType = displayString:sub(displayTypeStart, displayTypeEnd)
		local formatAsString =
			"%" .. displayString:sub(1, displayTypeStart - 1) .. displayString:sub(displayTypeEnd + 1) .. "s"
		if displayType == "#?" then
			return string.format(formatAsString, Strings.pretty(value))
		elseif displayType == "?" then
			return string.format(formatAsString, Tables.serializeDeep(value))
		elseif displayType == "#b" then
			local result = octalToBinary(value)
			return string.format(formatAsString, "0b" .. result)
		elseif displayType == "b" then
			local result = octalToBinary(value)
			return string.format(formatAsString, result)
		end
		return string.format("%" .. displayString, value)
	else
		local displayType = "s"
		if type(value) == "number" then
			local _, fraction = math.modf(value)
			displayType = fraction == 0 and "d" or "f"
		end
		return string.format("%" .. displayString .. displayType, tostring(value))
	end
end

--[[
	Returns a human-readable string for the given _value_. If _multiline_ is `true`, the string
	will be formatted across multiple lines if a descendant element gets longer than `80`
	characters.

	@usage This format may be improved in the future, so use `_.serializeDeep` if need a format
		which won't change.
	@see _.serializeDeep
]]
--: any, bool -> string
function Strings.pretty(value, serializeOptions)
	local function serializeValue(value, options)
		if type(value) == "table" then
			local className = ""
			if value.Class then
				className = value.Class.name .. " "
			end
			return className .. Tables.serialize(value, options)
		else
			return Tables.defaultSerializer(value, options)
		end
	end

	return Tables.serialize(
		value,
		Tables.assign(
			{
				serializeValue = serializeValue,
				serializeKey = function(key, options)
					if type(key) == "string" then
						return key
					else
						return "[" .. serializeValue(key, options) .. "]"
					end
				end,
				serializeElement = function(key, value)
					local shortString = key .. " = " .. value
					if #shortString < 80 or shortString:match("\n") then
						return shortString
					end
					return key .. " =\n\t" .. value
				end or nil,
				serializeTable = function(contents, ref, options)
					local shortString = ref .. "{" .. table.concat(contents, ", ") .. "}"
					if #shortString < 80 then
						return shortString
					end
					return ref ..
						"{\n" ..
							table.concat(
								Tables.map(
									contents,
									function(element)
										return "\t" .. element:gsub("\n", "\n\t")
									end
								),
								",\n"
							) ..
								"\n}"
				end or nil,
				keyDelimiter = " = ",
				valueDelimiter = ", ",
				omitKeys = {"Class"}
			},
			serializeOptions or {}
		)
	)
end

return Strings
]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXf4643e91cad242958df8c432071169a3">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Tables</string>
					<string name="ScriptGuid">{434140cc-bd6d-47aa-94e7-52c79fac66cb}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	A collection of functions that operate on Lua tables. These can operate on arrays,
	dictionaries and any collection types implemented with tables.

	Functions can also iterate over custom iterator functions.

	These functions typically act on immutable tables and return new tables in functional style.
	Note that mutable arguments in Rodash are explicitly typed as such.
]]
local t = require(script.Parent.Parent.t)

local Tables = {}

local function assertHandlerIsFn(handler)
	local Functions = require(script.Parent.Functions)
	assert(Functions.isCallable(handler), "BadInput: handler must be a function")
end

--[[
	Determines a suitable iterator to use for _source_, allowing _source_ to be either a plain
	table, a table that has a metatable with an `iterable` key, or a function.

	By default, the iterator is unordered, but passing _asArray_ as true uses `ipairs` to iterate
	through natural keys _1..n_ in order.
]]
function Tables.iterator(source, asArray)
	local metatable = getmetatable(source)
	local iterable = metatable and metatable.iterable or source
	if type(source) == "function" then
		return source
	else
		assert(type(source) == "table", "BadInput: Can only iterate over a table or an iterator function")
		if asArray then
			return ipairs(iterable)
		else
			return pairs(iterable)
		end
	end
end

--[[
	Get a child or descendant of a table, returning nil if any errors are generated.
	@param key The key of the child.
	@param ... Further keys to address any descendent.
	@example
		local upperTorso = _.get(game.Players, "LocalPlayer", "Character", "UpperTorso")
		upperTorso --> Part (if player's character and its UpperTorso are defined)
	@example
		-- You can also bind a lookup to get later on:
		local getUpperTorso = _.bindTail(_.get, "Character", "UpperTorso")
		getUpperTorso(players.LocalPlayer) --> Part
	@trait Chainable
]]
--: <T: {[K]: V}>(T, ...K) -> V
function Tables.get(source, ...)
	local path = {...}
	local ok, value =
		pcall(
		function()
			local result = source
			for _, key in ipairs(path) do
				result = result[key]
			end
			return result
		end
	)
	if ok then
		return value
	end
end

--[[
	Set a child or descendant of a table. Returns `true` if the operation completed without error.

	If any values along the path are not tables, `_.set` will do nothing and return `false`.
	@example
		_.set(game.Players, {"LocalPlayer", "Character", "UpperTorso", "Color"}, Color3.new(255, 255, 255))
		--> true (if the set worked)
	@trait Chainable
]]
--: <T: Iterable<K, V>>(T, K[], V) -> ()
function Tables.set(source, path, value)
	local ok =
		pcall(
		function()
			local result = source
			for i = 1, #path - 1 do
				result = result[path[i]]
			end
			result[path[#path]] = value
		end
	)
	return ok
end

--[[
	Return new table from _source_ with each value at the same key, but replaced by the return from
	the _handler_ function called for each value and key in the table.
	@example
		-- Use map to get the same property of each value:
		local playerNames = _.map(game.Players:GetChildren(), function(player)
			return player.Name
		end)
		playerNames --> {"Frodo Baggins", "Bilbo Baggins", "Boromir"}
	@example
		-- Use map to remove elements while preserving keys:
		local ingredients = {veg = "carrot", sauce = "tomato", herb = "basil"}
		local carrotsAndHerbs = _.map(ingredients, function( value, key )
			if value == "carrot" or key == "herb" then
				return value
			end
		end)
		carrotsAndHerbs --> {veg = "carrot", herb = "basil"}
	@example
		-- Use map with multiple values of a table at once:
		local numbers = {1, 1, 2, 3, 5} 
		local nextNumbers = _.map(numbers, function( value, key )
			return value + (numbers[key - 1] or 0)
		end)
		nextNumbers --> {1, 2, 3, 5, 8}
	@see filter if you want to 
]]
--: <T: Iterable<K,V>, R: Iterable<K,V2>((T, (element: V, key: K) -> V2) -> R)
function Tables.map(source, handler)
	assertHandlerIsFn(handler)
	local result = {}
	for i, v in Tables.iterator(source) do
		result[i] = handler(v, i)
	end
	return result
end

--[[
	Like `_.map`, but returns an array of the transformed values in the order that they are
	iterated over, dropping the original keys.
	@example
		local ingredients = {veg = "carrot", sauce = "tomato", herb = "basil"}
		local list = _.mapValues(function(value)
			return _.format("{} x2", value)
		end)
		list --> {"carrot x2", "tomato x2", "basil x2"} (in some order)
]]
--: <T: Iterable<K,V>, V2>((T, (element: V, key: K) -> V2) -> V2[])
function Tables.mapValues(source, handler)
	assertHandlerIsFn(handler)
	local result = {}
	for i, v in Tables.iterator(source) do
		table.insert(result, handler(v, i))
	end
	return result
end

--[[
	Like `_.map`, but the return of the _handler_ is used to transform the key of each element,
	while the value is preserved.

	If the _handler_ returns nil, the element is dropped from the result.
	@example
		local playerSet = {Frodo = true, Bilbo = true, Boromir = true}
		local healthSet = _.keyBy(playerSet, function(name)
			return _.get(game.Players, name, "Health")
		end)
		healthSet --> {100 = true, 50 = true, 0 = true}
]]
--: <T: Iterable<K,V>, R: Iterable<K,V2>((T, (element: V, key: K) -> V2) -> R)
function Tables.keyBy(source, handler)
	assertHandlerIsFn(handler)
	local result = {}
	for i, v in Tables.iterator(source) do
		local key = handler(v, i)
		if key ~= nil then
			result[key] = v
		end
	end
	return result
end

--[[
	Like `_.mapValues` but _handler_ must return an array. These elements are then insterted into
	the the resulting array returned.

	You can return an empty array `{}` from handler to avoid inserting anything for a particular
	element.

	@example
		local tools = _.flatMap(game.Players:GetChildren(), function(player)
			return player.Backpack:GetChildren()
		end)
		tools --> {Spoon, Ring, Sting, Book}
]]
--: <T: Iterable<K,V>, U>((T, (element: V, key: K) -> U[]) -> U[])
function Tables.flatMap(source, handler)
	assertHandlerIsFn(handler)
	local Arrays = require(script.Parent.Arrays)
	local result = {}
	for i, v in Tables.iterator(source) do
		local list = handler(v, i)
		assert(t.table(list), "BadResult: Handler must return an array")
		Arrays.append(result, list)
	end
	return result
end

--[[
	Returns an array of any values in _source_ that the _handler_ function returned `true` for,
	in order of iteration.

	@example
		local myTools = game.Players.LocalPlayer.Backpack:GetChildren()
		local mySpoons = _.filter(myTools, function(tool)
			return _.endsWith(tool.Name, "Spoon")
		end)
		mySpoons --> {SilverSpoon, TableSpoon}
	@see _.map if you would like to remove elements but preserve table keys
]]
--: <T: Iterable<K,V>>(T, (element: V, key: K -> bool) -> V[])
function Tables.filter(source, handler)
	assertHandlerIsFn(handler)
	local result = {}
	for i, v in Tables.iterator(source) do
		if handler(v, i) then
			table.insert(result, v)
		end
	end
	return result
end

--[[
	Returns an array of elements in _source_ with any elements of _value_ removed.
	@example
		local points = {0, 10, 3, 0, 5}
		local nonZero = _.without(points, 0)
		nonZero --> {10, 3, 5}
	@example
		local ingredients = {veg = "carrot", sauce = "tomato", herb = "basil"}
		local withoutCarrots = _.without(ingredients, "carrot")
		withoutCarrots --> {"tomato", "basil"} (in some order)
]]
--: <T: Iterable<K,V>>(T, V -> V[])
function Tables.without(source, value)
	return Tables.filter(
		source,
		function(child)
			return child ~= value
		end
	)
end

--[[
	Returns an array of elements from a sparse array _source_ with the returned elements provided
	in original key-order.

	@example
		local names = {
			[3] = "Boromir",
			[1] = "Frodo",
			[8] = "Bilbo"
		}
		local inOrderNames = _.compact(names)
		inOrderNames --> {"Frodo", "Boromir", "Bilbo"}
]]
--: <T: Iterable<K,V>>(T -> V[])
function Tables.compact(source)
	local Arrays = require(script.Parent.Arrays)
	local sortedKeys = Arrays.sort(Tables.keys(source))
	return Tables.map(
		sortedKeys,
		function(key)
			return source[key]
		end
	)
end

--[[
	Return `true` if _handler_ returns true for every element in _source_ it is called with.

	If no handler is provided, `_.all` returns true if every element is non-nil.
	@param handler (default = `_.id`)
	@example
		local names = {
			[3] = "Boromir",
			[1] = "Frodo",
			[8] = "Bilbo"
		}
		local allNamesStartWithB = _.all(names, function(name)
			return _.startsWith(name, "B")
		end)
		allNamesStartWithB --> false
]]
--: <T: Iterable<K,V>>(T, (value: V, key: K -> bool)?) -> bool
function Tables.all(source, handler)
	if not handler then
		handler = function(x)
			return x
		end
	end
	assertHandlerIsFn(handler)
	for key, value in Tables.iterator(source) do
		if not handler(value, key) then
			return false
		end
	end
	return true
end

--[[
	Return `true` if _handler_ returns true for at least one element in _source_ it is called with.

	If no handler is provided, `_.any` returns true if some element is non-nil.
	@param handler (default = `_.id`)
	@example
		local names = {
			[3] = "Boromir",
			[1] = "Frodo",
			[8] = "Bilbo"
		}
		local anyNameStartsWithB = _.any(names, function(name)
			return _.startsWith(name, "B")
		end)
		anyNameStartsWithB --> true
]]
--: <T: Iterable<K,V>>(T -> bool)
function Tables.any(source, handler)
	if not handler then
		handler = function(x)
			return x
		end
	end
	assertHandlerIsFn(handler)
	-- Use double negation to coerce the type to a boolean, as there is
	-- no toboolean() or equivalent in Lua.
	for key, value in Tables.iterator(source) do
		if handler(value, key) then
			return true
		end
	end
	return false
end

--[[
	Returns a copy of _source_, ensuring each key starts with an underscore `_`.
	Keys which are already prefixed with an underscore are left unchanged.
	@example
		local privates = _.privatize({
			[1] = 1,
			public = 2,
			_private = 3
		})
		privates --> {_1 = 1, _public = 2, _private = 3}
]]
-- <T>(T{} -> T{})
function Tables.privatize(source)
	local Strings = require(script.Parent.Strings)
	return Tables.keyBy(
		source,
		function(_, key)
			local stringKey = tostring(key)
			return Strings.startsWith(stringKey, "_") and stringKey or "_" .. stringKey
		end
	)
end

--[[
	Returns a table with elements from _source_ with their keys and values flipped.
	@example
		local teams = {red = "Frodo", blue = "Bilbo", yellow = "Boromir"}
		local players = _.invert(teams)
		players --> {Frodo = "red", Bilbo = "blue", Boromir = "yellow"}
]]
--: <K: Key, V>(Iterable<K,V> -> Iterable<V,K>)
function Tables.invert(source)
	local result = {}
	for i, v in Tables.iterator(source) do
		result[v] = i
	end
	return result
end

--[[
	Like `_.map`, but the return of the _handler_ is used to transform the key of each element,
	while the value is preserved.

	If the _handler_ returns nil, the element is dropped from the result.
	@example
		local playerSet = {Frodo = true, Bilbo = true, Boromir = true}
		local healthSet = _.mapKeys(playerSet, function(name)
			return _.get(game.Players, name, "Health")
		end)
		healthSet --> {100 = true, 50 = true, 0 = true}
]]
--: <T: Iterable<K,V>, I: Key>((value: T, key: K) -> I) -> Iterable<I, Iterable<K,V>>)
function Tables.groupBy(source, handler)
	assertHandlerIsFn(handler)
	local result = {}
	for i, v in Tables.iterator(source) do
		local key = handler(v, i)
		if key ~= nil then
			if not result[key] then
				result[key] = {}
			end
			table.insert(result[key], v)
		end
	end
	return result
end

--[=[
	Mutates _target_ by iterating recursively through elements of the subsequent
	arguments in order and inserting or replacing the values in target with each
	element preserving keys.

	If any values are both tables, these are merged recursively using `_.merge`.
	@example
		local someInfo = {
			Frodo = {
				name = "Frodo Baggins",
				team = "blue"
			},
			Boromir = {
				score = 5
			}
		}
		local someOtherInfo = {
			Frodo = {
				team = "red",
				score = 10
			},
			Bilbo = {
				team = "yellow",

			},
			Boromir = {
				score = {1, 2, 3}
			}
		}
		local mergedInfo = _.merge(someInfo, someOtherInfo)
		--[[
			--> {
				Frodo = {
					name = "Frodo Baggins",
					team = "red",
					score = 10
				},
				Bilbo = {
					team = "yellow"
				},
				Boromir = {
					score = {1, 2, 3}
				}
			}
		]]
	@see _.assign
	@see _.defaults
]=]
--: <T: Iterable<K,V>>(mut T, ...T) -> T
function Tables.merge(target, ...)
	-- Use select here so that nil arguments can be supported. If instead we
	-- iterated over ipairs({...}), any arguments after the first nil one
	-- would be ignored.
	for i = 1, select("#", ...) do
		local source = select(i, ...)
		if source ~= nil then
			for key, value in Tables.iterator(source) do
				if type(target[key]) == "table" and type(value) == "table" then
					target[key] = Tables.merge(target[key] or {}, value)
				else
					target[key] = value
				end
			end
		end
	end
	return target
end

--[[
	Returns an array of all the values of the elements in _source_.
	@example _.values({
		Frodo = 1,
		Boromir = 2,
		Bilbo = 3
	}) --> {1, 2, 3} (in some order)
]]
--: <T: Iterable<K,V>>(T -> V[])
function Tables.values(source)
	local result = {}
	for i, v in Tables.iterator(source) do
		table.insert(result, v)
	end
	return result
end

--[[
	Returns an array of all the keys of the elements in _source_.
	@example _.values({
		Frodo = 1,
		Boromir = 2,
		Bilbo = 3
	}) --> {"Frodo", "Boromir", "Bilbo"} (in some order)
]]
--: <T: Iterable<K,V>>(T -> K[])
function Tables.keys(source)
	local result = {}
	for i, v in Tables.iterator(source) do
		table.insert(result, i)
	end
	return result
end

--[[
	Returns an array of all the entries of elements in _source_.

	Each entry is a tuple `(key, value)`.

	@example _.values({
		Frodo = 1,
		Boromir = 2,
		Bilbo = 3
	}) --> {{"Frodo", 1}, {"Boromir", 2}, {"Bilbo", 3}} (in some order)
]]
--: <T: Iterable<K,V>>(T -> {K, V}[])
function Tables.entries(source)
	local result = {}
	for i, v in Tables.iterator(source) do
		table.insert(result, {i, v})
	end
	return result
end

--[[
	Picks a value from the table that _handler_ returns `true` for.

	As tables do not have ordered keys, do not rely on returning any particular value.
	@example
		local names = {
			[3] = "Boromir",
			[1] = "Frodo",
			[8] = "Bilbo"
		}
		local nameWithB = _.find(names, function(name)
			return _.startsWith(name, "B")
		end)
		nameWithB --> "Bilbo", 8 (or "Boromir", 3)

		-- Or use a chain:
		local nameWithF = _.find(names, _.fn:startsWith(name, "B"))
		nameWithF --> "Frodo", 1

		-- Or find the key of a specific value:
		local _, key = _.find(names, _.fn:matches("Bilbo"))
		key --> 8
	@see _.first
	@usage If you need to find the first value of an array that matches, use `_.first`.
]]
--: <T: Iterable<K,V>>((T, (element: V, key: K) -> bool) -> V?)
function Tables.find(source, handler)
	assertHandlerIsFn(handler)
	for i, v in Tables.iterator(source) do
		if (handler(v, i)) then
			return v, i
		end
	end
end

--[[
	Returns `true` if _item_ exists as a value in the _source_ table.
	@example
		local names = {
			[3] = "Boromir",
			[1] = "Frodo",
			[8] = "Bilbo"
		}
		_.includes(names, "Boromir") --> true
		_.includes(names, 1) --> false
]]
--: <T: Iterable<K,V>>(T, V -> bool)
function Tables.includes(source, item)
	return Tables.find(
		source,
		function(value)
			return value == item
		end
	) ~= nil
end

--[[
	Returns the number of elements in _source_.
	@example
		local names = {
			[3] = "Boromir",
			[1] = "Frodo",
			[8] = "Bilbo"
		}
		_.len(names) --> 3
]]
--: <T: Iterable<K,V>>(T -> int)
function Tables.len(source)
	local count = 0
	for _ in Tables.iterator(source) do
		count = count + 1
	end
	return count
end

local function assign(shouldOverwriteTarget, target, ...)
	-- Use select here so that nil arguments can be supported. If instead we
	-- iterated over ipairs({...}), any arguments after the first nil one
	-- would be ignored.
	for i = 1, select("#", ...) do
		local source = select(i, ...)
		if source ~= nil then
			for key, value in Tables.iterator(source) do
				if shouldOverwriteTarget or target[key] == nil then
					target[key] = value
				end
			end
		end
	end
	return target
end

--[=[
	Adds new elements in _target_ from subsequent table arguments in order, with elements in later
	tables replacing earlier ones if their keys match.
	@param ... any number of other tables
	@example
		local someInfo = {
			Frodo = {
				name = "Frodo Baggins",
				team = "blue"
			},
			Boromir = {
				score = 5
			}
		}
		local someOtherInfo = {
			Frodo = {
				team = "red",
				score = 10
			},
			Bilbo = {
				team = "yellow",

			},
			Boromir = {
				score = {1, 2, 3}
			}
		}
		local assignedInfo = _.assign(someInfo, someOtherInfo)
		--[[
			--> {
				Frodo = {
					team = "red",
					score = 10
				},
				Bilbo = {
					team = "yellow"
				},
				Boromir = {
					score = {1, 2, 3}
				}
			}
		]]
	@see _.defaults
	@see _.merge
]=]
--: <T: Iterable<K,V>>(mut T, ...T) -> T
function Tables.assign(target, ...)
	return assign(true, target, ...)
end

--[=[
	Adds new elements in _target_ from subsequent table arguments in order, with elements in
	earlier tables replacing earlier ones if their keys match.
	@param ... any number of other tables
	@example
		local someInfo = {
			Frodo = {
				name = "Frodo Baggins",
				team = "blue"
			},
			Boromir = {
				score = 5
			}
		}
		local someOtherInfo = {
			Frodo = {
				team = "red",
				score = 10
			},
			Bilbo = {
				team = "yellow",

			},
			Boromir = {
				score = {1, 2, 3}
			}
		}
		local assignedInfo = _.assign(someInfo, someOtherInfo)
		--[[
			--> {
				Frodo = {
					name = "Frodo Baggins",
					team = "blue"
				},
				Boromir = {
					score = 5
				}
				Bilbo = {
					team = "yellow"
				}
			}
		]]
	@see _.assign
	@see _.merge
]=]
--: <T: Iterable<K,V>>(mut T, ...T) -> T
function Tables.defaults(target, ...)
	return assign(false, target, ...)
end

--[[
	Returns a shallow copy of _source_.
	@example
		local Hermione = {
			name = "Hermione Granger",
			time = 12
		}
		local PastHermione = _.clone(Hermione)
		PastHermione.time = 9
		Hermione.time --> 12
	@see _.cloneDeep - if you also want to clone descendants of the table, though this can be costly.
	@see `_.map` - if you want to return different values for each key.
	@see _.Clone - use this to derive a default `:clone()` method for class instances.
]]
--: <T: Iterable<K,V>>(T -> T)
function Tables.clone(source)
	return Tables.assign({}, source)
end

--[[
	Recursively clones descendants of _source_, returning the cloned object. If references to the
	same table are found, the same clone is used in the result. This means that `_.cloneDeep` is
	cycle-safe.

	Elements which are not tables are not modified.
	@example
		local Harry = {
			patronus = "stag",
			age = 12
		}
		local Headwig = {
			animal = "owl",
			owner = Harry
		}
		Harry.pet = Headwig
		local clonedHarry = _.cloneDeep(Harry)
		Harry.age = 13
		-- The object clonedHarry is completely independent of any changes to Harry:
		_.pretty(clonedHarry) --> '<1>{age = 12, patronus = "stag", pet = {animal = "owl", owner = &1}}'
	@see _.clone - if you simply want to perform a shallow clone.
	@see _.CloneDeep - use this to derive a default `:clone()` method for class instances that clones children recursively.
]]
--: <T: Iterable<K,V>>(T -> T)
function Tables.cloneDeep(source)
	local visited = {}
	local function cloneVisit(input)
		if type(input) == "table" then
			if visited[input] == nil then
				visited[input] = {}
				Tables.assign(visited[input], Tables.map(input, cloneVisit))
			end
			return visited[input]
		else
			return input
		end
	end
	return cloneVisit(source)
end

--[[
	Returns `true` if all the values in _a_ match corresponding values in _b_ recursively.

	* For elements which are not tables, they match if they are equal.
	* If they are tables they match if the right is a subset of the left.

	@example
		local car = {
			speed = 10,
			wheels = 4,
			lightsOn = {
				indicators = true,
				headlights = false
			}
		}
		_.isSubset(car, {}) --> true
		_.isSubset(car, car) --> true
		_.isSubset(car, {speed = 10, lightsOn = {indicators = true}}) --> true
		_.isSubset(car, {speed = 12}) --> false
		_.isSubset({}, car) --> false
]]
-- <T>(T{}, T{}) -> bool
function Tables.isSubset(a, b)
	if type(a) ~= "table" or type(b) ~= "table" then
		return false
	else
		for key, aValue in pairs(a) do
			local bValue = b[key]
			if type(aValue) ~= type(bValue) then
				return false
			elseif aValue ~= bValue then
				if type(aValue) == "table" then
					-- The values are tables, so we need to recurse for a deep comparison.
					if not Tables.isSubset(aValue, bValue) then
						return false
					end
				else
					return false
				end
			end
		end
	end
	return true
end

--[[
	Returns `true` if _source_ has no keys.
	@example
		_.isEmpty({}) --> true
		_.isEmpty({false}) --> false
		_.isEmpty({a = 1}) --> false
]]
--: <T: Iterable<K,V>>(T -> bool)
function Tables.isEmpty(source)
	return Tables.iterator(source)(source) == nil
end

--[[
	Returns an element from _source_, if it has one.
	@example
		_.one({}) --> nil
		_.one({a = 1, b = 2, c = 3}) --> b, 2 (or any another element)
]]
--: <T: Iterable<K,V>>(T -> (V, K)?)
function Tables.one(source)
	local key, value = Tables.iterator(source)(source)
	return value, key
end

--[[
	Returns `true` if every element in _a_ recursively matches every element _b_.

	* For elements which are not tables, they match if they are equal.
	* If they are tables they match if the left is recursively deeply-equal to the right.

	@example
		local car = {
			speed = 10,
			wheels = 4,
			lightsOn = {
				indicators = true,
				headlights = false
			}
		}
		local car2 = {
			speed = 10,
			wheels = 4,
			lightsOn = {
				indicators = false,
				headlights = false
			}
		}
		_.deepEqual(car, {}) --> false
		_.deepEqual(car, car) --> true
		_.deepEqual(car, _.clone(car)) --> true
		_.deepEqual(car, _.cloneDeep(car)) --> true
		_.deepEqual(car, car2) --> false
	@see _.isSubset
	@see _.shallowEqual
]]
function Tables.deepEqual(a, b)
	return Tables.isSubset(a, b) and Tables.isSubset(b, a)
end

--[[
	Returns `true` if _left_ and _right_ are equal, or if they are tables and the elements in one
	are present and have equal values to those in the other.
	@example
		local car = {
			speed = 10,
			wheels = 4,
			lightsOn = {
				indicators = true,
				headlights = false
			}
		}
		_.shallowEqual(car, {}) --> false
		_.shallowEqual(car, car) --> true
		_.shallowEqual(car, _.clone(car)) --> true
		_.shallowEqual(car, _.cloneDeep(car)) --> false

	Based on https://developmentarc.gitbooks.io/react-indepth/content/life_cycle/update/using_should_component_update.html
	@see _.deepEqual
]]
function Tables.shallowEqual(left, right)
	if type(left) ~= "table" or type(right) ~= "table" then
		return left == right
	end
	local leftKeys = Tables.keys(left)
	local rightKeys = Tables.keys(right)
	if #leftKeys ~= #rightKeys then
		return false
	end
	return Tables.all(
		left,
		function(value, key)
			return value == right[key]
		end
	)
end

--[[
	Returns `true` is _source_ is made up only of natural keys `1..n`.
	@example
		_.isArray({1, 2, 3}) --> true
		_.isArray({a = 1, b = 2, c = 3}) --> false
		-- Treating sparse arrays as natural arrays will only complicate things:
		_.isArray({1, 2, nil, nil, 3}) --> false
		_.isArray(_.compact({1, 2, nil, nil, 3})) --> true
]]
--: <T: Iterable<K,V>>(T -> bool)
function Tables.isArray(source)
	return #Tables.keys(source) == #source
end

local function serializeVisit(source, options)
	local Arrays = require(script.Parent.Arrays)
	local isArray = Tables.isArray(source)
	local ref = ""
	local cycles = options.cycles
	if cycles.refs[source] then
		if cycles.visits[source] then
			return "&" .. cycles.visits[source]
		else
			cycles.count = cycles.count + 1
			cycles.visits[source] = cycles.count
			ref = "<" .. cycles.count .. ">"
		end
	end
	local filteredKeys =
		Tables.map(
		Tables.filter(
			-- Sort optimistically so references are more likely to be generated in print order
			options.keys or Arrays.sort(Tables.keys(source)),
			function(key)
				return not Tables.includes(options.omitKeys, key)
			end
		),
		function(key)
			return {key, options.serializeKey(key, options)}
		end
	)

	local contents =
		Tables.map(
		-- Sort keys again in case the serialization doesn't preserve order.
		-- Don't rely on the string value of the object as e.g. a table hash will change its value
		-- between runs.
		Arrays.sort(
			filteredKeys,
			function(left, right)
				return left[2] < right[2]
			end
		),
		function(pair)
			local value = source[pair[1]]
			local stringValue = options.serializeValue(value, options)
			if isArray then
				return stringValue
			else
				return options.serializeElement(pair[2], stringValue, options)
			end
		end
	)
	return options.serializeTable(contents, ref, options)
end

--[[
	A function which provides a simple, shallow string representation of a value.
]]
function Tables.defaultSerializer(input)
	if input == nil then
		return "nil"
	elseif type(input) == "number" or type(input) == "boolean" then
		return tostring(input)
	elseif type(input) == "string" then
		return '"' .. input:gsub("\\", "\\\\"):gsub('"', '\\"'):gsub("\n", "\\n") .. '"'
	else
		return "<" .. tostring(input) .. ">"
	end
end

local function countOccurences(source, counts)
	for key, value in Tables.iterator(source) do
		if type(value) == "table" then
			if counts[value] then
				counts[value] = counts[value] + 1
			else
				counts[value] = 1
				countOccurences(value, counts)
			end
		end
	end
end

local function getDefaultSerializeOptions()
	return {
		serializeValue = Tables.defaultSerializer,
		serializeKey = Tables.defaultSerializer,
		serializeElement = function(key, value, options)
			return key .. options.keyDelimiter .. value
		end,
		serializeTable = function(contents, ref, options)
			return ref .. "{" .. table.concat(contents, options.valueDelimiter) .. "}"
		end,
		keyDelimiter = ":",
		valueDelimiter = ",",
		cycles = {
			count = 0,
			visits = {}
		},
		omitKeys = {}
	}
end

--[[
	Returns a string representation of _source_ including all elements with sorted keys.
	
	`_.serialize` preserves the properties of being unique, stable and cycle-safe if the serializer
	functions provided also obey these properties.

	@param serializeValue (default = `_.defaultSerializer`) return a string representation of a value
	@param serializeKey (default = `_.defaultSerializer`) return a string representation of a value

	@example _.serialize({1, 2, 3}) --> "{1,2,3}"
	@example _.serialize({a = 1, b = true, [3] = "hello"}) --> '{"a":1,"b":true,3:"hello"}'
	@example 
		_.serialize({a = function() end, b = {a = "table"})
		--> '{"a":<function: 0x...>,"b"=<table: 0x...>}'
	@usage Use `_.serialize` when you need a representation of a table which doesn't need to be
		human-readable, or you need to customize the way serialization works. `_.pretty` is more
		appropriate when you need a human-readable string.
	@see _.serializeDeep
	@see _.defaultSerializer
	@see _.pretty
]]
--: <T: Iterable<K,V>>(T, (V, Cycles<V> -> string), (K, Cycles<V> -> string) -> string)
function Tables.serialize(source, options)
	options = Tables.defaults({}, options, getDefaultSerializeOptions())
	assert(t.string(options.valueDelimiter), "BadInput: valueDelimiter must be a string if defined")
	assert(t.string(options.keyDelimiter), "BadInput: keyDelimiter must be a string if defined")
	local Functions = require(script.Parent.Functions)
	assert(Functions.isCallable(options.serializeValue), "BadInput: options.serializeValue must be a function if defined")
	assert(Functions.isCallable(options.serializeKey), "BadInput: options.serializeKey must be a function if defined")
	if type(source) ~= "table" then
		return options.serializeValue(source, options)
	end

	-- Find tables which appear more than once, and assign each an index
	if not options.cycles.refs then
		options.cycles.refs =
			Tables.map(
			Tables.occurences(source),
			function(value)
				return value > 1 and value or nil
			end
		)
	end
	return serializeVisit(source, options)
end

--[[
	Like `_.serialize`, but if a child element is a table it is serialized recursively.

	Returns a string representation of _source_ including all elements with sorted keys.
	
	This function preserves uniqueness, stability and cycle-safety.

	@param serializeValue (default = `_.defaultSerializer`) return a string representation of a value
	@param serializeKey (default = `_.defaultSerializer`) return a string representation of a value

	@example 
		_.serializeDeep({a = {b = "table"}) --> '{"a":{"b":"table"}}'
	@example 
		local kyle = {name = "Kyle"}
		kyle.child = kyle
		_.serializeDeep(kyle) --> '<0>{"child":<&0>,"name":"Kyle"}'
	@see _.serialize
	@see _.defaultSerializer
]]
--: <T: Iterable<K,V>>(T, (V, Cycles<V> -> string), (K, Cycles<V> -> string) -> string)
function Tables.serializeDeep(source, options)
	options = Tables.defaults({}, options, getDefaultSerializeOptions())
	local Functions = require(script.Parent.Functions)
	assert(Functions.isCallable(options.serializeValue), "BadInput: options.serializeValue must be a function if defined")
	assert(Functions.isCallable(options.serializeKey), "BadInput: options.serializeKey must be a function if defined")
	local function deepSerializer(fn, value, internalOptions)
		if type(value) == "table" then
			return Tables.serialize(value, internalOptions)
		else
			return fn(value, internalOptions)
		end
	end
	local serializeOptions =
		Tables.defaults(
		{
			serializeKey = Functions.bind(deepSerializer, options.serializeKey),
			serializeValue = Functions.bind(deepSerializer, options.serializeValue)
		},
		options
	)
	return Tables.serialize(source, serializeOptions)
end

--[[
	Return a set of the tables that appear as descendants of _source_, mapped to the number of
	times each table has been found with a unique parent.

	Repeat occurences are not traversed, so the function is cycle-safe. If any tables in the
	result have a count of two or more, they may form cycles in the _source_.
	@example
		local plate = {veg = "potato", pie = {"stilton", "beef"}}
		_.occurences(plate) --> {
			[{veg = "potato", pie = {"stilton", "beef"}}] = 1
			[{"stilton", "beef"}] = 1
		}
	@example
		local kyle = {name = "Kyle"}
		kyle.child = kyle
		_.occurences(kyle) --> {
			[{name = "Kyle", child = kyle}] = 2
		}
]]
-- <T: Iterable<K,V>>(T -> Iterable<T,int>)
function Tables.occurences(source)
	assert(t.table(source), "BadInput: source must be a table")
	local counts = {[source] = 1}
	countOccurences(source, counts)
	return counts
end

--[[
	Returns an array of the values in _source_, without any repetitions.

	Values are considered equal if the have the same key representation.

	@example
		local list = {1, 2, 2, 3, 5, 1}
		_.unique(list) --> {1, 2, 3, 5} (or another order)
]]
function Tables.unique(source)
	return Tables.keys(Tables.invert(source))
end

return Tables
]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
	</Item>
	<Item class="LuaWebService" referent="RBX0b735b6c1c754e4daa7de5b95ba2e7b7">
		<Properties>
			<string name="Name">Instance</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Lighting" referent="1">
		<Properties>
			<Color3 name="Ambient">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<float name="Brightness">2</float>
			<Color3 name="ColorShift_Bottom">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<Color3 name="ColorShift_Top">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<float name="ExposureCompensation">0</float>
			<Color3 name="FogColor">
				<R>0.75</R>
				<G>0.75</G>
				<B>0.75</B>
			</Color3>
			<float name="FogEnd">100000</float>
			<float name="FogStart">0</float>
			<float name="GeographicLatitude">41.7332993</float>
			<bool name="GlobalShadows">true</bool>
			<bool name="LegacyOutlines">false</bool>
			<string name="Name">Lighting</string>
			<Color3 name="OutdoorAmbient">
				<R>0.5</R>
				<G>0.5</G>
				<B>0.5</B>
			</Color3>
			<bool name="Outlines">false</bool>
			<float name="ShadowSoftness">0.5</float>
			<BinaryString name="Tags"></BinaryString>
			<token name="Technology">1</token>
			<string name="TimeOfDay">14:00:00</string>
		</Properties>
	</Item>
	<Item class="HttpService" referent="0">
		<Properties>
			<bool name="HttpEnabled">true</bool>
			<string name="Name">HttpService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="TestService" referent="RBX5987a1234ebb47e59deee68a546b0f43">
		<Properties>
			<bool name="AutoRuns">true</bool>
			<string name="Description"></string>
			<bool name="ExecuteWithStudioRun">false</bool>
			<bool name="Is30FpsThrottleEnabled">true</bool>
			<bool name="IsPhysicsEnvironmentalThrottled">true</bool>
			<bool name="IsSleepAllowed">true</bool>
			<string name="Name">TestService</string>
			<int name="NumberOfPlayers">0</int>
			<double name="SimulateSecondsLag">0</double>
			<BinaryString name="Tags"></BinaryString>
			<double name="Timeout">10</double>
		</Properties>
	</Item>
</roblox>