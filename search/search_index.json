{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Rodash is a collection of functions designed to aid everyday game programming in Roblox. It borrows ideas from lodash in JS, some simpler functionality of Penlight and standalone helper scripts in circulation among the Roblox community. See the Getting Started page for examples of how you can use Rodash. Installation Using the latest release Download the latest rbxmx model from the Github releases page . Drag the model file from your Downloads folder into a Roblox Studio project. Open the Packages folder which is created and drag Rodash and its siblings into ReplicatedStorage . Using Rojo If you are familiar with Git and Rojo you can also clone the Rodash repo and incorporate the dependencies from the default.project.json file into your own project. Usage Require Rodash in any of your scripts: local dash = require ( game . ReplicatedStorage . Rodash ) local list = { cheese } dash . append ( list , { nachos }, {}, { chillies , bbq sauce }) list -- { cheese , nachos , chillies , bbq sauce } If you prefer, you can alias specific Rodash functions yourself: local dash = require ( game . ReplicatedStorage . Rodash ) local append = dash . append Discussion If you have any queries or feedback, please join the discussion on the Studio+ discord server! Please report any bugs to the Issue Tracker . Design Principles The Rodash design principles make it quick and easy to use the library to write concise operations, or incrementally simplify existing Roblox code. Functions: Avoid abstractions , working on native lua types to avoid enforcing specific coding styles Only do one thing by avoiding parameter overloading or flags Enforce type safety to avoid silent error propagation Prefer immutability to promote functional design and reduce race conditions Avoid duplication , mimicking existing functionality or aliasing other functions Maintain backwards compatibility with older versions of the library","title":"Home"},{"location":"#installation","text":"","title":"Installation"},{"location":"#using-the-latest-release","text":"Download the latest rbxmx model from the Github releases page . Drag the model file from your Downloads folder into a Roblox Studio project. Open the Packages folder which is created and drag Rodash and its siblings into ReplicatedStorage .","title":"Using the latest release"},{"location":"#using-rojo","text":"If you are familiar with Git and Rojo you can also clone the Rodash repo and incorporate the dependencies from the default.project.json file into your own project.","title":"Using Rojo"},{"location":"#usage","text":"Require Rodash in any of your scripts: local dash = require ( game . ReplicatedStorage . Rodash ) local list = { cheese } dash . append ( list , { nachos }, {}, { chillies , bbq sauce }) list -- { cheese , nachos , chillies , bbq sauce } If you prefer, you can alias specific Rodash functions yourself: local dash = require ( game . ReplicatedStorage . Rodash ) local append = dash . append","title":"Usage"},{"location":"#discussion","text":"If you have any queries or feedback, please join the discussion on the Studio+ discord server! Please report any bugs to the Issue Tracker .","title":"Discussion"},{"location":"#design-principles","text":"The Rodash design principles make it quick and easy to use the library to write concise operations, or incrementally simplify existing Roblox code. Functions: Avoid abstractions , working on native lua types to avoid enforcing specific coding styles Only do one thing by avoiding parameter overloading or flags Enforce type safety to avoid silent error propagation Prefer immutability to promote functional design and reduce race conditions Avoid duplication , mimicking existing functionality or aliasing other functions Maintain backwards compatibility with older versions of the library","title":"Design Principles"},{"location":"getting-started/","text":"To understand how Rodash can be helpful in your game, here is an example code snippet which periodically prints the names of players online. We'll simplify it by using Rodash functions: spawn ( function () while true do local playerNames = {} for player in pairs ( game . Players : GetChildren ()) do table.insert ( playerNames , player . Name ) end local nameList = table.concat ( playerNames , , ) print ( string.format ( Players online = %s: %s ), # playerNames , nameList ) wait ( 1 ) end end ) Running a piece of code periodically is simplest with dash.setInterval : local dash = require ( game . ReplicatedStorage . Rodash ) dash . setInterval ( function () local playerNames = {} for player in pairs ( game . Players : GetChildren ()) do table.insert ( playerNames , player . Name ) end local nameList = table.concat ( playerNames , , ) print ( string.format ( Players online = %s: %s ), # playerNames , nameList ) end ) You can also cancel an interval when you need to, or use dash.setTimeout if you want to run a function after a delay that you can cancel. A cleaner way to get the player names from the list of players is using map : local dash = require ( game . ReplicatedStorage . Rodash ) dash . setInterval ( function () local playerNames = dash . map ( game . Players : GetChildren (), function ( name ) return player . Name end ) local nameList = table.concat ( playerNames , , ) print ( string.format ( Players online = %s: %s ), # playerNames , nameList ) end ) Rodash has lots of different methods to operate on tables and arrays. Some other examples are dash.filter , dash.find , dash.groupBy and dash.slice . Rodash also has lots of primitive functions such as dash.noop , dash.id , dash.get and dash.bindTail . We can use these to simplify small functions you write all the time: local dash = require ( game . ReplicatedStorage . Rodash ) dash . setInterval ( function () local playerNames = dash . map ( game . Players : GetChildren (), dash . bindTail ( dash . get , Name )) local nameList = table.concat ( playerNames , , ) print ( string.format ( Players online = %s: %s ), # playerNames , nameList ) end ) Here dash.bindTail takes dash.get which looks up a key (or array of keys) in an object, and returns a function which will get the \"Name\" property of any object passed to it. This seems unnecessary, but it's often useful to separate functions from the data they act on as the functions can then be used with different inputs. Fortunately, we can write this much more simply. All of the Rodash functions which act on data such as dash.map , dash.filter and dash.get are available beneath dash.fn as chained functions, which means that they can be strung together in a concise way to form a function which performs the desired action on any input. local dash = require ( game . ReplicatedStorage . Rodash ) local fn = dash . fn dash . setInterval ( function () local getNames = fn : map ( fn : get ( Name )) local playerNames = getNames ( game . Players : GetChildren ()) local nameList = table.concat ( playerNames , , ) print ( string.format ( Players online = %s: %s ), # playerNames , nameList ) end , 1 ) The function dash.format can be used to quickly print values that you need from Lua. Specifically, format can print variables using {} regardless of what type they are. Here, we can quickly get the length of the playerNames array, and then print the array with dash.pretty using the #? formatter: local dash = require ( game . ReplicatedStorage . Rodash ) local fn = dash . fn dash . setInterval ( function () local getNames = fn : map ( fn : get ( Name )) local playerNames = getNames ( game . Players : GetChildren ()) print ( dash . format ( Players online = {#}: {1:#?} , playerNames )) end , 1 ) For example, this might print Players online = 1: {\"builderman\"} every second.","title":"Getting Started"},{"location":"glossary/","text":"Glossary all any append assign async asyncAll await bind bindTail call camelCase capitalize chain chainFn charToHex class Class.__le Class.__lt Class._init Class.clone Class.equals Class.extend Class.extendWithInterface Class.interface Class.isInstance Class.new Class.toString classWithInterface clone Cloneable cloneDeep compact compose continue cycles.count debounce debug debugTarget decodeHtml decodeUrl decodeUrlComponent decorate deepEqual defaultComparator defaults defaultSerializer delay encodeHtml encodeQueryString encodeUrl encodeUrlComponent endsWith entries enum filter finalize finally find first flatMap fn format Formatable formatValue freeze get groupBy hexToChar id includes instance.Class invert invoke isA isArray isCallable isEmpty isPromise isSubset iterator kebabCase keyBy keys last leftPad len map mapValues match maybe memoize merge mixin never noop occurences once one parallel parallelAll PartialOrd pretty privatize race reduce resolve retryWithBackoff returns reverse rightPad serialize serializeDeep series set setDebug setInterval setTimeout ShallowEq shallowEqual shuffle slice snakeCase sort splitOn startsWith sum symbol throttle throws timeout titleCase trim unary undefined.refs unique values without","title":"Glossary"},{"location":"glossary/#glossary","text":"all any append assign async asyncAll await bind bindTail call camelCase capitalize chain chainFn charToHex class Class.__le Class.__lt Class._init Class.clone Class.equals Class.extend Class.extendWithInterface Class.interface Class.isInstance Class.new Class.toString classWithInterface clone Cloneable cloneDeep compact compose continue cycles.count debounce debug debugTarget decodeHtml decodeUrl decodeUrlComponent decorate deepEqual defaultComparator defaults defaultSerializer delay encodeHtml encodeQueryString encodeUrl encodeUrlComponent endsWith entries enum filter finalize finally find first flatMap fn format Formatable formatValue freeze get groupBy hexToChar id includes instance.Class invert invoke isA isArray isCallable isEmpty isPromise isSubset iterator kebabCase keyBy keys last leftPad len map mapValues match maybe memoize merge mixin never noop occurences once one parallel parallelAll PartialOrd pretty privatize race reduce resolve retryWithBackoff returns reverse rightPad serialize serializeDeep series set setDebug setInterval setTimeout ShallowEq shallowEqual shuffle slice snakeCase sort splitOn startsWith sum symbol throttle throws timeout titleCase trim unary undefined.refs unique values without","title":"Glossary"},{"location":"types/","text":"Every function in Rodash is dynamically and statically typed. This means you know what arguments Rodash functions can take and what they can return when you write your code, and Rodash will also check that you've passed in valid values when you run it. Dynamic Typing Dynamic typing means checking that the values passed into a function are valid when the function is run. Rodash functions will throw a BadInput error if any arguments are invalid, allowing you to catch errors quickly and fail fast during development. Rodash uses the \"t\" library by Osyris to perform runtime type assertions, which we recommend using in your own code during development and production code. Static Typing Lua is a dynamically-typed language, which means that you can't tell from normal Lua source code what type of values you should use when calling functions, unless you understand how the function internals work. Rodash uses a type language that borrows heavily from the Typescript type language. Types are added using optional annotations, which are added using --: . For example: --: string, string - bool function endsWith ( str , suffix ) This states that dash.endsWith takes two string arguments and returns a boolean. Lua primitives These types correspond to basic Lua types: Name Type Description Number number A Lua number String string A Lua string Boolean bool A Lua boolean Nil nil The Lua nil Userdata userdata A Lua userdata object Table table A Lua table i.e. with type(value) == \"table\" Extended primitives Name Usage Description Any any A type representing all of the valid types (excluding fail) Some some A type representing all of the valid non-nil types Character char A single character of a string Pattern pattern A string representing a valid Lua pattern Integer int An integer Unsigned integer uint An unsigned (positive) integer Float float A floating point number Never never A Promise that never resolves Void void or () An empty tuple, typically to represent an empty return type or empty function-arguments Fail fail A return value which means that the function will always throw an error Modifying types Name Usage Description Mutable parameter mut X A function which takes a value of type mut X may modify the value of type X during execution Yield return yield X A function which returns yield X may yield when executed before returning a value of type X Self self X A function which takes self X as a parameter must be defined using : and called as a method on a value of type X . Only required if the method should be called on a different type to the one it is defined under Structural types Like many scripting languages, Lua has a general structure type table which can be used to represent arrays, dictionaries, sets, classes, and many other data types. The type language uses a strict set of definitions for different ways tables can be used: Name Usage Description Tuple (X, Y, Z) Values of particular types separated by commas, such as an argument or return list in a Lua function Array X[] A Lua table that has a finite number of Ordered keys with values of type X Fixed array {X, Y, Z} An array with a fixed number of values, where the first value has type X , the second type Y etc. Dictionary X{} a Lua table which has values of type X Map {[X]: Y} A Lua table with keys of type X mapping to values of type Y Multi-dimensional table X[][] X{}{} X{}[]{} A 2d or higher dimensional table, with values being arrays, dictionaries or multi-dimensional tables themselves Rodash methods use more general types where possible, specifically Ordered and Iterable values. This let's you operate on iterators as well as tables. Function types Name Type Description Function X, Y - Z A callable value taking parameters with type X and Y and returning a value of type Z Multiple returns X - Y, Z A callable value taking a parameter of type X and returning two values of type Y and Z respectively Void function () - () A function that takes no parameters and returns nothing Rest function ...X - ...Y A function that takes any number of parameters of type X and returns any number values of type Y Callable Any value that can be called has a function type. In practice, a value is callable if and only if it is one of the following: A Lua function A Lua CFunction A Lua table with a metatable that has a valid __call property defined This is more general than just checking if a value has a function type. Usage You can test if a value is callable using dash.isCallable . Composite types Name Type Description Optional X? Equivalent to the type X | nil , meaning a value of this type either has type X or nil Union X | Y Values of this type can either be of type X or of type Y (or both) Intersection X Y Values of this type must be of both types X and Y . For example, if X and Y are interfaces the value must implement both of them. Generic types Generics allow the same function to be used with different types. Known types are replaced with type variables, which are usually single capital letters such as T or K , but can be any word beginning with a capital letter. When a generic function is called, the same type variable must refer to the same type everywhere it appears in the type definition. Name Type Description Generic function T (T - T) A generic function that takes a parameter of type T and returns a value of the same type T Generic arguments A (...A - A) A generic function that takes any number of parameters of type A and returns a value of the same type A Generic bounds T: X (T - T) A function that has a type variable T which must be of the type X Parameterized object X T An object of type X that is parameterized to type T Examples The dash.last function returns the last element of an array, and has a type signature of T (T[] - T) . If you call it with an array of strings with type string[] , then T = string and the function becomes parameterized, meaning its type string[] - string . This shows you that the function will return a string . If you simply used any[] - any without using a generics, you couldn't know that the function always returned a value of the same type. Like T[] was parameterized as a string array when T = string , any structural types like dictionaries or Classes can also parameterized. Usage Note that using ...X when X refers to a tuple expands the elements from the tuple in-order, as a value can't have a tuple type itself. For example, dash.id has the type signature A (...A - ...A) . If you call id(1, \"Hello\") then A = (number, string) and the function becomes typed as: number, string - number, string . Iterable types Iterators An iterator is a function which returns (key, value) pairs when it is called. You might not use them often in your own code but they are very common in Lua - any loop you write takes an iterator. For example ipairs(object) in the code: for key , value in ipairs ( object ) do They are more abstract than using a concrete table to store data which means you can use them to: Represent an infinite list, such as countable sequences of numbers like the naturals. Represent a stream, such as a random stream or events coming from an input source. Avoid calculating all the elements of a list at once, such as a lazy list retrieving elements from an HTTP endpoint You cannot modify the source of values in an iterator, so they are safer to use if you don't want a function changing the underlying source. Type type Iterator K,V = (props: any, previousKey: K?) - K, V Stateful Iterator function statefulIterator () -- K, V Stateful iterators take no arguments and simply return the next (key, value) pair when called. These are simple to make and prevent code from skipping or seeking to arbitrary elements in the underlying source. You can use dash.iterator to create your own iterator for a table. This is useful where you cannot use pairs or ipairs natively such as when using read-only objects - see dash.freeze . Type K,V (() - K, V) Generics K - some - the primary key type (can be any non-nil value) V - some - the secondary key type (can be any non-nil value) Examples -- Calling range returns a stateful iterator that counts from a to b. function range ( a , b ) local key = 0 return function () local value = a + key key = key + 1 if value = b then return key , value end end end Usage Stateful iterators that you write can be used in any Rodash function that takes an Iterable . Stateless Iterator function statelessIterator ( props , previousKey ) -- K, V Stateless iterators take two arguments (props, previousKey) which are used to address a (key, value) pair to return. A stateless iterator should return the first (key, value) pair if the previousKey nil is passed in. Type K,V ((any, K?) - K, V) Properties props - any - any value - the static properties that the iterator uses previousKey - K? - the iterator state type (optional) - (default = nil ) the previous key acts as the state for the iterator so it doesn't need to store its own state Generics K - some - the primary key type (can be any non-nil value) V - some - the secondary key type (can be any non-nil value) S - some - the iterator state type (can be any non-nil value) Examples -- This function is a stateless iterator function evenNumbers ( _ , previousKey ) local key = ( previousKey or 0 ) + 1 return key , key * 2 end Usage Stateless iterators that you write can be used in any Rodash function that takes an Iterable . Iterable An iterable value is either a dictionary or an Iterator . Many Rodash functions can operate on iterator functions as well as tables. Type type Iterable K,V = {[K]:V} | Iterator K,V Generics K - any - the primary key type (can be any value) V - any - the primary value type (can be any value) See Iterator Ordered An ordered value is either an array or an ordered Iterator . For something to be ordered, the keys returned during iteration must be the natural numbers. This means the first key must be 1 , the second 2 , the third 3 , etc. Type type Ordered V = V[] | Iterator number,V Generics V - any - the primary value type (can be any value) Usage For example, you could write an ordered iterator of numbers, and dash.first will to return the first number which matches a particular condition. See Iterator Asynchronous types Promise Any promise value created using the Roblox Lua Promise library has Promise T type. See the documentation of this library for examples on how to use promises. Type interface Promise T Generics T - any - the primary type (can be any value) Yieldable A marker type for a function which may yield. We recommend you use promises instead of writing your own yielding functions as they can have unpredictable behavior, such as causing threads to block outside your control. Because of this, only functions which are marked as yieldable are assumed to be capable of yielding. Type type Yieldable T = ... - yield T Generics T - any - the primary type (can be any value) Async A marker type for a function which returns a promise. Type type Async T = ... - Promise T Generics T - any - the primary type (can be any value) Class types Class Constructor Enum Symbol Decorator types Decorator Cloneable PartialOrd ShallowEq Chaining types Actor Chainable Chain Library types Clearable A stateful object with a clear method that resets the object state. Type interface Clearable A Generics A - any - the primary arguments Properties Property Type Description clear(...) ...A - () reset the object state addressed by the arguments provided See dash.setTimeout dash.setInterval dash.memoize AllClearable A stateful object with a clearAll method that resets the all parts of the object state. Type interface AllClearable Properties Property Type Description clearAll() () - () reset the entire object state See dash.memoize DisplayString A DisplayString is a string that is a valid argument to dash.formatValue . Examples include: #b - prints a number in its binary representation #? - pretty prints a table using dash.pretty Usage See dash.format for a full description of valid display strings. SerializeOptions Customize how dash.serialize , dash.serializeDeep and dash.pretty convert objects into strings using these options: Type interface SeralizeOptions T: Iterable K,V Generics K - any - the primary key type (can be any value) V - any - the primary value type (can be any value) T - Iterable K,V - An Iterable (of the primary key type and the primary value type) Properties Property Type Description keys K[]? (optional) if defined, only the keys present in this array will be serialized omitKeys K[]? (optional) an array of keys which should not be serialized serializeValue(value) V - string (default = dash.defaultSerializer ) returns the string representation for a value in the object serializeKey(key) K - string (default = dash.defaultSerializer ) returns the string representation for a key in the object serializeElement(keyString, valueString, options) string, string, SerializeOptions T - string returns the string representation for a serialized key-value pair serializeTable(contents, ref, options) string[], string?, SerializeOptions T - string (default = returns \"{elements}\") given an array of serialized table elements and an optional reference, this returns the string representation for a table keyDelimiter \":\" The string that is put between a serialized key and value pair valueDelimiter \",\" The string that is put between each element of the object BackoffOptions Customize the function of dash.retryWithBackoff using these options: Type interface SeralizeOptions T Generics T - any - the primary type Properties Property Type Description maxTries int how many tries (including the first one) the function should be called retryExponentInSeconds number customize the backoff exponent retryConstantInSeconds number customize the backoff constant randomStream Random use a Roblox \"Random\" instance to control the backoff shouldRetry(response) T - bool called if maxTries 1 to determine whether a retry should occur onRetry(waitTime, errorMessage) (number, string) - nil a hook for when a retry is triggered, with the delay before retry and error message which caused the failure onDone(response, durationInSeconds) (T, number) - nil a hook for when the promise resolves onFail(errorMessage) string - nil a hook for when the promise has failed and no more retries are allowed","title":"Types"},{"location":"types/#dynamic-typing","text":"Dynamic typing means checking that the values passed into a function are valid when the function is run. Rodash functions will throw a BadInput error if any arguments are invalid, allowing you to catch errors quickly and fail fast during development. Rodash uses the \"t\" library by Osyris to perform runtime type assertions, which we recommend using in your own code during development and production code.","title":"Dynamic Typing"},{"location":"types/#static-typing","text":"Lua is a dynamically-typed language, which means that you can't tell from normal Lua source code what type of values you should use when calling functions, unless you understand how the function internals work. Rodash uses a type language that borrows heavily from the Typescript type language. Types are added using optional annotations, which are added using --: . For example: --: string, string - bool function endsWith ( str , suffix ) This states that dash.endsWith takes two string arguments and returns a boolean.","title":"Static Typing"},{"location":"types/#lua-primitives","text":"These types correspond to basic Lua types: Name Type Description Number number A Lua number String string A Lua string Boolean bool A Lua boolean Nil nil The Lua nil Userdata userdata A Lua userdata object Table table A Lua table i.e. with type(value) == \"table\"","title":"Lua primitives"},{"location":"types/#extended-primitives","text":"Name Usage Description Any any A type representing all of the valid types (excluding fail) Some some A type representing all of the valid non-nil types Character char A single character of a string Pattern pattern A string representing a valid Lua pattern Integer int An integer Unsigned integer uint An unsigned (positive) integer Float float A floating point number Never never A Promise that never resolves Void void or () An empty tuple, typically to represent an empty return type or empty function-arguments Fail fail A return value which means that the function will always throw an error","title":"Extended primitives"},{"location":"types/#modifying-types","text":"Name Usage Description Mutable parameter mut X A function which takes a value of type mut X may modify the value of type X during execution Yield return yield X A function which returns yield X may yield when executed before returning a value of type X Self self X A function which takes self X as a parameter must be defined using : and called as a method on a value of type X . Only required if the method should be called on a different type to the one it is defined under","title":"Modifying types"},{"location":"types/#structural-types","text":"Like many scripting languages, Lua has a general structure type table which can be used to represent arrays, dictionaries, sets, classes, and many other data types. The type language uses a strict set of definitions for different ways tables can be used: Name Usage Description Tuple (X, Y, Z) Values of particular types separated by commas, such as an argument or return list in a Lua function Array X[] A Lua table that has a finite number of Ordered keys with values of type X Fixed array {X, Y, Z} An array with a fixed number of values, where the first value has type X , the second type Y etc. Dictionary X{} a Lua table which has values of type X Map {[X]: Y} A Lua table with keys of type X mapping to values of type Y Multi-dimensional table X[][] X{}{} X{}[]{} A 2d or higher dimensional table, with values being arrays, dictionaries or multi-dimensional tables themselves Rodash methods use more general types where possible, specifically Ordered and Iterable values. This let's you operate on iterators as well as tables.","title":"Structural types"},{"location":"types/#function-types","text":"Name Type Description Function X, Y - Z A callable value taking parameters with type X and Y and returning a value of type Z Multiple returns X - Y, Z A callable value taking a parameter of type X and returning two values of type Y and Z respectively Void function () - () A function that takes no parameters and returns nothing Rest function ...X - ...Y A function that takes any number of parameters of type X and returns any number values of type Y","title":"Function types"},{"location":"types/#callable","text":"Any value that can be called has a function type. In practice, a value is callable if and only if it is one of the following: A Lua function A Lua CFunction A Lua table with a metatable that has a valid __call property defined This is more general than just checking if a value has a function type. Usage You can test if a value is callable using dash.isCallable .","title":"Callable"},{"location":"types/#composite-types","text":"Name Type Description Optional X? Equivalent to the type X | nil , meaning a value of this type either has type X or nil Union X | Y Values of this type can either be of type X or of type Y (or both) Intersection X Y Values of this type must be of both types X and Y . For example, if X and Y are interfaces the value must implement both of them.","title":"Composite types"},{"location":"types/#generic-types","text":"Generics allow the same function to be used with different types. Known types are replaced with type variables, which are usually single capital letters such as T or K , but can be any word beginning with a capital letter. When a generic function is called, the same type variable must refer to the same type everywhere it appears in the type definition. Name Type Description Generic function T (T - T) A generic function that takes a parameter of type T and returns a value of the same type T Generic arguments A (...A - A) A generic function that takes any number of parameters of type A and returns a value of the same type A Generic bounds T: X (T - T) A function that has a type variable T which must be of the type X Parameterized object X T An object of type X that is parameterized to type T Examples The dash.last function returns the last element of an array, and has a type signature of T (T[] - T) . If you call it with an array of strings with type string[] , then T = string and the function becomes parameterized, meaning its type string[] - string . This shows you that the function will return a string . If you simply used any[] - any without using a generics, you couldn't know that the function always returned a value of the same type. Like T[] was parameterized as a string array when T = string , any structural types like dictionaries or Classes can also parameterized. Usage Note that using ...X when X refers to a tuple expands the elements from the tuple in-order, as a value can't have a tuple type itself. For example, dash.id has the type signature A (...A - ...A) . If you call id(1, \"Hello\") then A = (number, string) and the function becomes typed as: number, string - number, string .","title":"Generic types"},{"location":"types/#iterable-types","text":"","title":"Iterable types"},{"location":"types/#iterators","text":"An iterator is a function which returns (key, value) pairs when it is called. You might not use them often in your own code but they are very common in Lua - any loop you write takes an iterator. For example ipairs(object) in the code: for key , value in ipairs ( object ) do They are more abstract than using a concrete table to store data which means you can use them to: Represent an infinite list, such as countable sequences of numbers like the naturals. Represent a stream, such as a random stream or events coming from an input source. Avoid calculating all the elements of a list at once, such as a lazy list retrieving elements from an HTTP endpoint You cannot modify the source of values in an iterator, so they are safer to use if you don't want a function changing the underlying source. Type type Iterator K,V = (props: any, previousKey: K?) - K, V","title":"Iterators"},{"location":"types/#stateful-iterator","text":"function statefulIterator () -- K, V Stateful iterators take no arguments and simply return the next (key, value) pair when called. These are simple to make and prevent code from skipping or seeking to arbitrary elements in the underlying source. You can use dash.iterator to create your own iterator for a table. This is useful where you cannot use pairs or ipairs natively such as when using read-only objects - see dash.freeze . Type K,V (() - K, V) Generics K - some - the primary key type (can be any non-nil value) V - some - the secondary key type (can be any non-nil value) Examples -- Calling range returns a stateful iterator that counts from a to b. function range ( a , b ) local key = 0 return function () local value = a + key key = key + 1 if value = b then return key , value end end end Usage Stateful iterators that you write can be used in any Rodash function that takes an Iterable .","title":"Stateful Iterator"},{"location":"types/#stateless-iterator","text":"function statelessIterator ( props , previousKey ) -- K, V Stateless iterators take two arguments (props, previousKey) which are used to address a (key, value) pair to return. A stateless iterator should return the first (key, value) pair if the previousKey nil is passed in. Type K,V ((any, K?) - K, V) Properties props - any - any value - the static properties that the iterator uses previousKey - K? - the iterator state type (optional) - (default = nil ) the previous key acts as the state for the iterator so it doesn't need to store its own state Generics K - some - the primary key type (can be any non-nil value) V - some - the secondary key type (can be any non-nil value) S - some - the iterator state type (can be any non-nil value) Examples -- This function is a stateless iterator function evenNumbers ( _ , previousKey ) local key = ( previousKey or 0 ) + 1 return key , key * 2 end Usage Stateless iterators that you write can be used in any Rodash function that takes an Iterable .","title":"Stateless Iterator"},{"location":"types/#iterable","text":"An iterable value is either a dictionary or an Iterator . Many Rodash functions can operate on iterator functions as well as tables. Type type Iterable K,V = {[K]:V} | Iterator K,V Generics K - any - the primary key type (can be any value) V - any - the primary value type (can be any value) See Iterator","title":"Iterable"},{"location":"types/#ordered","text":"An ordered value is either an array or an ordered Iterator . For something to be ordered, the keys returned during iteration must be the natural numbers. This means the first key must be 1 , the second 2 , the third 3 , etc. Type type Ordered V = V[] | Iterator number,V Generics V - any - the primary value type (can be any value) Usage For example, you could write an ordered iterator of numbers, and dash.first will to return the first number which matches a particular condition. See Iterator","title":"Ordered"},{"location":"types/#asynchronous-types","text":"","title":"Asynchronous types"},{"location":"types/#promise","text":"Any promise value created using the Roblox Lua Promise library has Promise T type. See the documentation of this library for examples on how to use promises. Type interface Promise T Generics T - any - the primary type (can be any value)","title":"Promise"},{"location":"types/#yieldable","text":"A marker type for a function which may yield. We recommend you use promises instead of writing your own yielding functions as they can have unpredictable behavior, such as causing threads to block outside your control. Because of this, only functions which are marked as yieldable are assumed to be capable of yielding. Type type Yieldable T = ... - yield T Generics T - any - the primary type (can be any value)","title":"Yieldable"},{"location":"types/#async","text":"A marker type for a function which returns a promise. Type type Async T = ... - Promise T Generics T - any - the primary type (can be any value)","title":"Async"},{"location":"types/#class-types","text":"","title":"Class types"},{"location":"types/#class","text":"","title":"Class"},{"location":"types/#constructor","text":"","title":"Constructor"},{"location":"types/#enum","text":"","title":"Enum"},{"location":"types/#symbol","text":"","title":"Symbol"},{"location":"types/#decorator-types","text":"","title":"Decorator types"},{"location":"types/#decorator","text":"","title":"Decorator"},{"location":"types/#cloneable","text":"","title":"Cloneable"},{"location":"types/#partialord","text":"","title":"PartialOrd"},{"location":"types/#shalloweq","text":"","title":"ShallowEq"},{"location":"types/#chaining-types","text":"","title":"Chaining types"},{"location":"types/#actor","text":"","title":"Actor"},{"location":"types/#chainable","text":"","title":"Chainable"},{"location":"types/#chain","text":"","title":"Chain"},{"location":"types/#library-types","text":"","title":"Library types"},{"location":"types/#clearable","text":"A stateful object with a clear method that resets the object state. Type interface Clearable A Generics A - any - the primary arguments Properties Property Type Description clear(...) ...A - () reset the object state addressed by the arguments provided See dash.setTimeout dash.setInterval dash.memoize","title":"Clearable"},{"location":"types/#allclearable","text":"A stateful object with a clearAll method that resets the all parts of the object state. Type interface AllClearable Properties Property Type Description clearAll() () - () reset the entire object state See dash.memoize","title":"AllClearable"},{"location":"types/#displaystring","text":"A DisplayString is a string that is a valid argument to dash.formatValue . Examples include: #b - prints a number in its binary representation #? - pretty prints a table using dash.pretty Usage See dash.format for a full description of valid display strings.","title":"DisplayString"},{"location":"types/#serializeoptions","text":"Customize how dash.serialize , dash.serializeDeep and dash.pretty convert objects into strings using these options: Type interface SeralizeOptions T: Iterable K,V Generics K - any - the primary key type (can be any value) V - any - the primary value type (can be any value) T - Iterable K,V - An Iterable (of the primary key type and the primary value type) Properties Property Type Description keys K[]? (optional) if defined, only the keys present in this array will be serialized omitKeys K[]? (optional) an array of keys which should not be serialized serializeValue(value) V - string (default = dash.defaultSerializer ) returns the string representation for a value in the object serializeKey(key) K - string (default = dash.defaultSerializer ) returns the string representation for a key in the object serializeElement(keyString, valueString, options) string, string, SerializeOptions T - string returns the string representation for a serialized key-value pair serializeTable(contents, ref, options) string[], string?, SerializeOptions T - string (default = returns \"{elements}\") given an array of serialized table elements and an optional reference, this returns the string representation for a table keyDelimiter \":\" The string that is put between a serialized key and value pair valueDelimiter \",\" The string that is put between each element of the object","title":"SerializeOptions"},{"location":"types/#backoffoptions","text":"Customize the function of dash.retryWithBackoff using these options: Type interface SeralizeOptions T Generics T - any - the primary type Properties Property Type Description maxTries int how many tries (including the first one) the function should be called retryExponentInSeconds number customize the backoff exponent retryConstantInSeconds number customize the backoff constant randomStream Random use a Roblox \"Random\" instance to control the backoff shouldRetry(response) T - bool called if maxTries 1 to determine whether a retry should occur onRetry(waitTime, errorMessage) (number, string) - nil a hook for when a retry is triggered, with the delay before retry and error message which caused the failure onDone(response, durationInSeconds) (T, number) - nil a hook for when the promise resolves onFail(errorMessage) string - nil a hook for when the promise has failed and no more retries are allowed","title":"BackoffOptions"},{"location":"api/Arrays/","text":"Arrays A collection of functions that operate specifically on arrays, defined as tables with just keys 1..n . -- Examples of valid arrays: {} { red , green , blue } { winter , { is = coming }, [ 3 ] = again } { 1966 , nil , nil } -- Examples of invalid arrays: { 1994 , nil , 2002 } { you = { know , nothing }} {[ 5 ] = gold rings } 42 These functions can iterate over any Ordered values. Functions append function dash . append ( target , ...) -- T[] Inserts into the target array the elements from all subsequent arguments in order. Type T (mut T[], ...Ordered T - T[]) Generics T - any - the primary type (extends any value) Parameters target - mut T[] - an array (of the primary type) (which can be mutated) ... - ...Ordered T - Ordereds (of the primary type) - any number of other arrays Returns T[] - an array (of the primary type) Examples dash . append ({}, { 1 , 2 , 3 }, { 4 , 5 , 6 }) -- {1, 2, 3, 4, 5, 6} dash . append ({ 1 , 2 , 3 }) -- {1, 2, 3} local list = { cheese } dash . append ( list , { nachos }, {}, { chillies }) list -- { cheese , nachos , chillies } defaultComparator function dash . defaultComparator ( a , b ) -- bool Given two values a and b , this function return true if a is typically considered lower than b . The default comparator is used by dash.sort and can sort elements of different types, in the order: boolean, number, string, function, CFunction, userdata, and table. Elements which cannot be sorted naturally will be sorted by their string value. Type T ((T, T) - bool) Generics T - any - the primary type (extends any value) Parameters a - T - the primary type b - T - the primary type Returns bool - a boolean See dash.sort first function dash . first ( source , predicate ) -- V? Returns the earliest value from the array that predicate returns true for. If the predicate is not specified, dash.first simply returns the first element of the array. Type T: Iterable K,V (T, (element: V, key: K - bool) - V?) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type predicate - (element: V, key: K) - bool - a function (taking element (the primary value type) and key (the primary key type), and returning a boolean) - (default = dash.returns(true) ) Returns V? - the primary value type (optional) Examples local names = { Boromir , Frodo , Bilbo } dash . first ( names ) -- Boromir , 1 -- Find a particular value: local firstNameWithF = dash . first ( names , function ( name ) return dash . startsWith ( name , F ) end ) firstNameWithF -- Frodo , 2 -- What about a value which doesn t exist? local firstNameWithC = dash . first ( names , function ( name ) return dash . startsWith ( name , C ) end ) firstNameWithC -- nil -- Find the index of a value: local _ , index = dash . first ( names , dash . fn : matches ( Bilbo )) index -- 2 Usage If you need to find a value in a table which isn't an array, use dash.find . See dash.find last function dash . last ( source , predicate ) -- V? Returns the last value from the array that predicate returns true for. If the predicate is not specified, dash.last simply returns the last element of the array. Type T: Iterable K,V (T, (element: V, key: K - bool) - V?) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type predicate - (element: V, key: K) - bool - a function (taking element (the primary value type) and key (the primary key type), and returning a boolean) - (default = dash.returns(true) ) Returns V? - the primary value type (optional) Examples local names = { Boromir , Frodo , Bilbo } dash . last ( names ) -- Bilbo , 3 local lastNameWithB = dash . last ( names , dash . fn : startsWith ( B )) lastNameWithB -- Bilbo , 3 local _ , key = dash . last ( names , dash . fn : matches ( Frodo )) key -- 2 See dash.find dash.first reduce function dash . reduce ( source , handler , initial ) -- R Runs the handler on each element of source in turn, passing the result of the previous call (or initial for the first element) as the first argument, and the current element as a value and key as subsequent arguments. Type T, R (Ordered T , (result: R, value: T, key: int - R), R) - R Generics T - any - the primary type (extends any value) R - any - the result type (extends any value) Parameters source - Ordered T - an Ordered (of the primary type) handler - (result: R, value: T, key: int) - R - a function (taking result (the result type), value (the primary type) and key (an integer), and returning the result type) initial - R - the result type Returns R - the result type Examples local sum = dash . reduce ({ 1 , 2 , 3 }, function ( result , value ) return result + value end , 0 ) sum -- 6 local recipe = { first = cheese , second = nachos , third = chillies } local unzipRecipe = dash . reduce ( recipe , function ( result , value , key ) table.insert ( result [ 1 ], key ) table.insert ( result [ 2 ], value ) return result end , {{}, {}}) -- (in some order) unzipRecipe -- {{ first , third , second }, { cheese , chillies , nachos }} reverse function dash . reverse ( source ) -- T[] Swaps the order of elements in source . Type T (T[] - T[]) Generics T - any - the primary type (extends any value) Parameters source - T[] - an array (of the primary type) Returns T[] - an array (of the primary type) Examples dash . reverse ({ 1 , 2 , 4 , 3 , 5 }) -- {5, 3, 4, 2, 1} shuffle function dash . shuffle ( source ) -- T[] Returns a new array with the order of the values from source randomized. Type T (T[] - T[]) Generics T - any - the primary type (extends any value) Parameters source - T[] - an array (of the primary type) Returns T[] - an array (of the primary type) Examples local teamColors = { red , red , red , blue , blue , blue } -- (in some order) dash . shuffle ( teamColors ) -- { blue , blue , red , blue , red , red } slice function dash . slice ( source , first , last , step ) -- T[] Returns a copied portion of the source , between the first and last elements inclusive and jumping step each time if provided. Type T (T[], int?, int?, int? - T[]) Generics T - any - the primary type (extends any value) Parameters source - T[] - an array (of the primary type) first - int? - an integer (optional) - (default = 1) The index of the first element to include. last - int? - an integer (optional) - (default = #source ) The index of the last element to include. step - int? - an integer (optional) - (default = 1) What amount to step the index by during iteration. Returns T[] - an array (of the primary type) Examples dash . slice ({ 10 , 20 , 30 , 40 }) -- {10, 20, 30, 40} dash . slice ({ 10 , 20 , 30 , 40 }, 2 ) -- {20, 30, 40} dash . slice ({ 10 , 20 , 30 , 40 }, 2 , 3 ) -- {20, 30} dash . slice ({ 10 , 20 , 30 , 40 }, 2 , 4 , 2 ) -- {20, 40} sort function dash . sort ( input , comparator ) -- T[] Returns a sorted array from the input array, based on a comparator function. Unlike dash.sort , the comparator to dash.sort is optional, but if defined it can also return a numeric weight or nil as well as a boolean to provide an ordering of the elements. Type T (T[], (T - bool | number | nil)? - T[]) Generics T - any - the primary type (extends any value) Parameters input - T[] - an array (of the primary type) comparator - (T) - bool | number | nil? - a function (taking the primary type, and returning a boolean or a number or nil) (optional) - should return true or n 0 if the first element should be before the second in the resulting array, or 0 or nil if the elements have the same order. Returns T[] - an array (of the primary type) Examples dash . sort ({ 2 , 5 , 3 }) -- {2, 3, 5} dash . sort ({ use , the , force , Luke }) -- { Luke , force , the , use } dash . sort ({ name = Luke , health = 50 }, { name = Yoda , health = 9001 }, { name = Jar Jar Binks , health = 0 }, function ( a , b ) return a . health b . health end ) -- the characters sorted in ascending order by their health sum function dash . sum ( source ) -- number Sums all the values in the source array. Type Ordered number - number Parameters source - Ordered number - an Ordered (of number) Returns number - a number Examples dash . sum ({ 1 , 2 , 3 }) -- 6","title":"Arrays"},{"location":"api/Arrays/#arrays","text":"A collection of functions that operate specifically on arrays, defined as tables with just keys 1..n . -- Examples of valid arrays: {} { red , green , blue } { winter , { is = coming }, [ 3 ] = again } { 1966 , nil , nil } -- Examples of invalid arrays: { 1994 , nil , 2002 } { you = { know , nothing }} {[ 5 ] = gold rings } 42 These functions can iterate over any Ordered values.","title":"Arrays"},{"location":"api/Arrays/#functions","text":"","title":"Functions"},{"location":"api/Arrays/#append","text":"function dash . append ( target , ...) -- T[] Inserts into the target array the elements from all subsequent arguments in order. Type T (mut T[], ...Ordered T - T[]) Generics T - any - the primary type (extends any value) Parameters target - mut T[] - an array (of the primary type) (which can be mutated) ... - ...Ordered T - Ordereds (of the primary type) - any number of other arrays Returns T[] - an array (of the primary type) Examples dash . append ({}, { 1 , 2 , 3 }, { 4 , 5 , 6 }) -- {1, 2, 3, 4, 5, 6} dash . append ({ 1 , 2 , 3 }) -- {1, 2, 3} local list = { cheese } dash . append ( list , { nachos }, {}, { chillies }) list -- { cheese , nachos , chillies }","title":"append"},{"location":"api/Arrays/#defaultcomparator","text":"function dash . defaultComparator ( a , b ) -- bool Given two values a and b , this function return true if a is typically considered lower than b . The default comparator is used by dash.sort and can sort elements of different types, in the order: boolean, number, string, function, CFunction, userdata, and table. Elements which cannot be sorted naturally will be sorted by their string value. Type T ((T, T) - bool) Generics T - any - the primary type (extends any value) Parameters a - T - the primary type b - T - the primary type Returns bool - a boolean See dash.sort","title":"defaultComparator"},{"location":"api/Arrays/#first","text":"function dash . first ( source , predicate ) -- V? Returns the earliest value from the array that predicate returns true for. If the predicate is not specified, dash.first simply returns the first element of the array. Type T: Iterable K,V (T, (element: V, key: K - bool) - V?) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type predicate - (element: V, key: K) - bool - a function (taking element (the primary value type) and key (the primary key type), and returning a boolean) - (default = dash.returns(true) ) Returns V? - the primary value type (optional) Examples local names = { Boromir , Frodo , Bilbo } dash . first ( names ) -- Boromir , 1 -- Find a particular value: local firstNameWithF = dash . first ( names , function ( name ) return dash . startsWith ( name , F ) end ) firstNameWithF -- Frodo , 2 -- What about a value which doesn t exist? local firstNameWithC = dash . first ( names , function ( name ) return dash . startsWith ( name , C ) end ) firstNameWithC -- nil -- Find the index of a value: local _ , index = dash . first ( names , dash . fn : matches ( Bilbo )) index -- 2 Usage If you need to find a value in a table which isn't an array, use dash.find . See dash.find","title":"first"},{"location":"api/Arrays/#last","text":"function dash . last ( source , predicate ) -- V? Returns the last value from the array that predicate returns true for. If the predicate is not specified, dash.last simply returns the last element of the array. Type T: Iterable K,V (T, (element: V, key: K - bool) - V?) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type predicate - (element: V, key: K) - bool - a function (taking element (the primary value type) and key (the primary key type), and returning a boolean) - (default = dash.returns(true) ) Returns V? - the primary value type (optional) Examples local names = { Boromir , Frodo , Bilbo } dash . last ( names ) -- Bilbo , 3 local lastNameWithB = dash . last ( names , dash . fn : startsWith ( B )) lastNameWithB -- Bilbo , 3 local _ , key = dash . last ( names , dash . fn : matches ( Frodo )) key -- 2 See dash.find dash.first","title":"last"},{"location":"api/Arrays/#reduce","text":"function dash . reduce ( source , handler , initial ) -- R Runs the handler on each element of source in turn, passing the result of the previous call (or initial for the first element) as the first argument, and the current element as a value and key as subsequent arguments. Type T, R (Ordered T , (result: R, value: T, key: int - R), R) - R Generics T - any - the primary type (extends any value) R - any - the result type (extends any value) Parameters source - Ordered T - an Ordered (of the primary type) handler - (result: R, value: T, key: int) - R - a function (taking result (the result type), value (the primary type) and key (an integer), and returning the result type) initial - R - the result type Returns R - the result type Examples local sum = dash . reduce ({ 1 , 2 , 3 }, function ( result , value ) return result + value end , 0 ) sum -- 6 local recipe = { first = cheese , second = nachos , third = chillies } local unzipRecipe = dash . reduce ( recipe , function ( result , value , key ) table.insert ( result [ 1 ], key ) table.insert ( result [ 2 ], value ) return result end , {{}, {}}) -- (in some order) unzipRecipe -- {{ first , third , second }, { cheese , chillies , nachos }}","title":"reduce"},{"location":"api/Arrays/#reverse","text":"function dash . reverse ( source ) -- T[] Swaps the order of elements in source . Type T (T[] - T[]) Generics T - any - the primary type (extends any value) Parameters source - T[] - an array (of the primary type) Returns T[] - an array (of the primary type) Examples dash . reverse ({ 1 , 2 , 4 , 3 , 5 }) -- {5, 3, 4, 2, 1}","title":"reverse"},{"location":"api/Arrays/#shuffle","text":"function dash . shuffle ( source ) -- T[] Returns a new array with the order of the values from source randomized. Type T (T[] - T[]) Generics T - any - the primary type (extends any value) Parameters source - T[] - an array (of the primary type) Returns T[] - an array (of the primary type) Examples local teamColors = { red , red , red , blue , blue , blue } -- (in some order) dash . shuffle ( teamColors ) -- { blue , blue , red , blue , red , red }","title":"shuffle"},{"location":"api/Arrays/#slice","text":"function dash . slice ( source , first , last , step ) -- T[] Returns a copied portion of the source , between the first and last elements inclusive and jumping step each time if provided. Type T (T[], int?, int?, int? - T[]) Generics T - any - the primary type (extends any value) Parameters source - T[] - an array (of the primary type) first - int? - an integer (optional) - (default = 1) The index of the first element to include. last - int? - an integer (optional) - (default = #source ) The index of the last element to include. step - int? - an integer (optional) - (default = 1) What amount to step the index by during iteration. Returns T[] - an array (of the primary type) Examples dash . slice ({ 10 , 20 , 30 , 40 }) -- {10, 20, 30, 40} dash . slice ({ 10 , 20 , 30 , 40 }, 2 ) -- {20, 30, 40} dash . slice ({ 10 , 20 , 30 , 40 }, 2 , 3 ) -- {20, 30} dash . slice ({ 10 , 20 , 30 , 40 }, 2 , 4 , 2 ) -- {20, 40}","title":"slice"},{"location":"api/Arrays/#sort","text":"function dash . sort ( input , comparator ) -- T[] Returns a sorted array from the input array, based on a comparator function. Unlike dash.sort , the comparator to dash.sort is optional, but if defined it can also return a numeric weight or nil as well as a boolean to provide an ordering of the elements. Type T (T[], (T - bool | number | nil)? - T[]) Generics T - any - the primary type (extends any value) Parameters input - T[] - an array (of the primary type) comparator - (T) - bool | number | nil? - a function (taking the primary type, and returning a boolean or a number or nil) (optional) - should return true or n 0 if the first element should be before the second in the resulting array, or 0 or nil if the elements have the same order. Returns T[] - an array (of the primary type) Examples dash . sort ({ 2 , 5 , 3 }) -- {2, 3, 5} dash . sort ({ use , the , force , Luke }) -- { Luke , force , the , use } dash . sort ({ name = Luke , health = 50 }, { name = Yoda , health = 9001 }, { name = Jar Jar Binks , health = 0 }, function ( a , b ) return a . health b . health end ) -- the characters sorted in ascending order by their health","title":"sort"},{"location":"api/Arrays/#sum","text":"function dash . sum ( source ) -- number Sums all the values in the source array. Type Ordered number - number Parameters source - Ordered number - an Ordered (of number) Returns number - a number Examples dash . sum ({ 1 , 2 , 3 }) -- 6","title":"sum"},{"location":"api/Async/","text":"Async Building upon the functionality of Roblox Lua Promise and borrowing ideas from Bluebird , these functions improve the experience of working with asynchronous code in Roblox. Promises can be thought of as a variable whose value might not be known immediately when they are defined. They allow you to pass around a \"promise\" to the value, rather than yielding or waiting until the value has resolved. This means you can write functions which pass any promises to right places in your code, and delay running any code which requires the value until it is ready. Functions async function dash . async ( fn ) -- (...A) - Promise T Wraps a function which may yield in a promise. When run, async calls the the function in a coroutine and resolves with the output of the function after any asynchronous actions, and rejects if the function throws an error. Type T, A (Yieldable T, A ) - ...A - Promise T Generics T - any - the primary type (extends any value) A - any - the primary arguments (extends any value) Parameters fn - Yieldable T, A - a Yieldable (of the primary type and the primary arguments) Returns (...A) - Promise T - a function (taking the primary arguments, and returning a Promise (of the primary type)) Rejects passthrough - The returned promise will reject if promises passed as arguments reject. Examples local fetch = dash . async ( function ( url ) local HttpService = game : GetService ( HttpService ) return HttpService : GetAsync ( url ) end ) fetch ( http://example.com/burger ): andThen ( function ( meal ) print ( Meal: , meal ) end ) -- Meal: Cheeseburger (ideal response) Usage With promise:await the dash.async function can be used just like the async-await pattern in languages like JS. See dash.parallel asyncAll function dash . asyncAll ( dictionary ) -- (...A) - Promise T {} Wraps any functions in dictionary with dash.async , returning a new dictionary containing functions that return promises when called rather than yielding. Type T, A (Yieldable T, A {}) - (...A - Promise T ){} Generics T - any - the primary type (extends any value) A - any - the primary arguments (extends any value) Parameters dictionary - Yieldable T, A {} - a dictionary (of Yieldables (of the primary type and the primary arguments)) Returns (...A) - Promise T {} - a dictionary (of functions (taking the primary arguments, and returning a Promise (of the primary type))) Examples local http = dash . asyncAll ( game : GetService ( HttpService )) http : GetAsync ( http://example.com/burger ): andThen ( function ( meal ) print ( Meal , meal ) end ) -- Meal: Cheeseburger (some time later) local buyDinner = dash . async ( function () local http = dash . asyncAll ( game : GetService ( HttpService )) local order = dash . parallelAll ({ main = http : GetAsync ( http://example.com/burger ), side = http : GetAsync ( http://example.com/fries ) }) return http : PostAsync ( http://example.com/purchase , order : await ()) end ) buyDinner (): await () -- Purchased! (some time later) See dash.async dash.parallelAll Yieldable await function dash . await ( value ) -- T Yields completion of a promise promise:await() , but returns immediately with the value if it isn't a promise. Type T (Promise T | T - yield T) Generics T - any - the primary type (extends any value) Parameters value - Promise T | T - a Promise (of the primary type) or the primary type Returns T - the primary type Examples local heat = function ( item ) return dash . delay ( 1 ). returns ( hot .. item ) end local recipe = { wrap , heat ( steak ), heat ( rice )} local burrito = dash . map ( recipe , dash . await ) dash . debug ( {:#?} , burrito ) -- { wrap , hot steak , hot rice } (2 seconds) delay function dash . delay ( delayInSeconds ) -- Promise nil Returns a promise which resolves after the given delayInSeconds. Type number - Promise nil Parameters delayInSeconds - number - a number Returns Promise nil - a Promise (of nil) Examples dash . delay ( 1 ): andThen ( function () print ( Delivered ) end ) -- Delivered (1 second later) finally function dash . finally ( promise , fn ) -- Promise R Returns a promise which completes after the promise input has completed, regardless of whether it has resolved or rejected. The fn is passed true if the promise did not error, otherwise false , and the promise's result as the second argument. Type T, R (Promise T , (bool, T) - R) - Promise R Generics T - any - the primary type (extends any value) R - any - the result type (extends any value) Parameters promise - (Promise T , bool, T) - R - a function (taking a Promise (of the primary type) and a tuple (a boolean and the primary type), and returning the result type) fn - any - any value - function(ok, result) Returns Promise R - a Promise (of the result type) Examples local getHunger = dash . async ( function ( player ) if player . health == 0 then error ( Player is dead! ) else return game . ReplicatedStorage . GetHunger : InvokeServer ( player ) end end ) local localPlayer = game . Players . LocalPlayer local isHungry = getHunger ( localPlayer ): finally ( function ( isAlive , result ) return isAlive and result 5 end ) isPromise function dash . isPromise ( value ) -- bool Wraps Promise.is but catches any errors thrown in attempting to ascertain if value is a promise, which will occur if the value throws when trying to access missing keys. Type T (T - bool) Generics T - any - the primary type (extends any value) Parameters value - T - the primary type Returns bool - a boolean never function dash . never () -- never Returns a promise which never resolves or rejects. Type () - never Returns never - a promise that never resolves Usage Useful in combination with dash.race where a resolution or rejection should be ignored. parallel function dash . parallel ( array ) -- Promise T[] Given an array of values, this function returns a promise which resolves once all of the array elements have resolved, or rejects if any of the array elements reject. Type T ((Promise T | T)[] - Promise T[] ) Generics T - any - the primary type (extends any value) Parameters array - Promise T | T[] - an array (of Promises (of the primary type) or the primary type) Returns Promise T[] - a Promise (of array (of the primary type)) - an array mapping the input to resolved elements. Rejects passthrough - The returned promise will reject if promises passed as arguments reject. Examples local heat = function ( item ) local oven = dash . parallel ({ item , dash . delay ( 1 )}) return oven : andThen ( function ( result ) return hot- .. result [ 1 ] end ) end local meal = dash . parallel ({ heat ( cheese ), tomato }) meal : await () -- { hot-cheese , tomato } (1 second later) Usage This function is like dash.all but allows objects in the array which aren't promises. These are considered resolved immediately. Promises that return nil values will cause the return array to be sparse. See Promise parallelAll function dash . parallelAll ( dictionary ) -- Promise T{} Given a dictionary of values, this function returns a promise which resolves once all of the values in the dictionary have resolved, or rejects if any of them are promises that reject. Type T ((Promise T | T){}) - Promise T{} Generics T - any - the primary type (extends any value) Parameters dictionary - Promise T | T{} - a dictionary (of Promises (of the primary type) or the primary type) Returns Promise T{} - a Promise (of dictionary (of the primary type)) - a dictionary mapping the input to resolved elements. Rejects passthrough - The returned promise will reject if promises passed as arguments reject. Examples local heat = function ( item ) local oven = dash . parallel ({ item , dash . delay ( 1 )}) return oven : andThen ( function ( result ) return hot- .. result [ 1 ] end ) end local toastie = dash . parallelAll ({ bread = brown , filling = heat ( cheese ) }) toastie : await () -- {bread = brown , filling = hot-cheese } (1 second later) local fetch = dash . async ( function ( url ) local HttpService = game : GetService ( HttpService ) return HttpService : GetAsync ( url ) end ) dash . parallelAll ({ main = fetch ( http://example.com/burger ), side = fetch ( http://example.com/fries ) }): andThen ( function ( meal ) print ( Meal , dash . pretty ( meal )) end ) Usage Values which are not promises are considered resolved immediately. race function dash . race ( array , n ) -- Promise T[] Returns a promise which completes after the first promise in the array input completes, or first n promises if specified. If any promise rejects, race rejects with the first rejection. Type T (Promise T [], uint?) - Promise T[] Generics T - any - the primary type (extends any value) Parameters array - Promise T [] - an array (of Promises (of the primary type)) n - uint? - an unsigned integer (optional) - the number of promises required (default = 1) Returns Promise T[] - a Promise (of array (of the primary type)) - an array containing the first n resolutions, in the order that they resolved. Throws OutOfBoundsError - if the number of required promises is greater than the input length. Rejects passthrough - The returned promise will reject if promises passed as arguments reject. Examples -- Here promise resolves to the result of fetch, or resolves to No burger for you if the -- fetch takes more than 2 seconds. local fetch = dash . async ( function ( url ) local HttpService = game : GetService ( HttpService ) return HttpService : GetAsync ( url ) end ) local promise = dash . race ( dash . delay ( 2 ): andThen ( dash . returns ( No burger for you ), fetch ( http://example.com/burger ) ) Usage Note that Promises which return nil values will produce a sparse array. The size of array must be equal to or larger than n . See dash.async resolve function dash . resolve (...) -- Promise T Like dash.resolve but can take any number of arguments. Type T - Promise T Parameters ... - T - the type of self Returns Promise T - a Promise (of the type of self ) Examples local function mash ( veg ) return dash . resolve ( mashed , veg ) end mash ( potato ): andThen ( function ( style , veg ) dash . debug ( {} was {} , veg , style ) end ) -- potato was mashed Usage As dash.resolve(promise) -- promise , this function can also be used to ensure a value is a promise. retryWithBackoff function dash . retryWithBackoff ( asyncFn , backoffOptions ) -- Promise T Try running a function which returns a promise and retry if the function throws and error or the promise rejects. The retry behavior can be adapted using backoffOptions, which can customize the maximum number of retries and the backoff timing of the form [0, x^attemptNumber] + y where x is an exponent that produces a random exponential delay and y is a constant delay. Type T (Async T , BackoffOptions T ) - Promise T Generics T - any - the primary type (extends any value) Parameters asyncFn - Async T - an Async (of the primary type) backoffOptions - BackoffOptions T - a BackoffOptions (of the primary type) Returns Promise T - a Promise (of the primary type) Rejects passthrough - The returned promise will reject if promises passed as arguments reject. Examples -- Use dash.retryWithBackoff to retry a GET request repeatedly. local fetchPizza = dash . async ( function () local HttpService = game : GetService ( HttpService ) return HttpService : GetAsync ( https://example.com/pizza ) end ) dash . retryWithBackoff ( fetchPizza , { maxTries = 3 , onRetry = function ( waitTime , errorMessage ) print ( Failed to fetch due to , errorMessage ) print ( Retrying in , waitTime ) end }): andThen ( function ( resultingPizza ) print ( Great, you have: , resultingPizza ) end ) series function dash . series (...) -- (...A) - Promise A Like dash.compose but takes functions that can return a promise. Returns a promise that resolves once all functions have resolved. Like compose, functions receive the resolution of the previous promise as argument(s). Type A ((...A - Promise A )[]) - ...A - Promise A Generics A - any - the primary arguments (extends any value) Parameters ... - (...A) - Promise A [] - an array (of functions (taking the primary arguments, and returning a Promise (of the primary arguments))) Returns (...A) - Promise A - a function (taking the primary arguments, and returning a Promise (of the primary arguments)) Examples local function fry ( item ) return dash . delay ( 1 ): andThen ( dash . returns ( fried .. item )) end local function cheesify ( item ) return dash . delay ( 1 ): andThen ( dash . returns ( cheesy .. item )) end local prepare = dash . series ( fry , cheesify ) prepare ( nachos ): await () -- cheesy fried nachos (after 2s) See dash.parallel dash.delay timeout function dash . timeout ( promise , deadlineInSeconds , timeoutMessage ) -- Promise T Resolves to the result of promise if it resolves before the deadline, otherwise rejects with an error, which can be optionally customized. Type T (Promise T , number, string?) - Promise T Generics T - any - the primary type (extends any value) Parameters promise - Promise T - a Promise (of the primary type) deadlineInSeconds - number - a number timeoutMessage - string? - a string (optional) - (default = \"TimeoutError\") Returns Promise T - a Promise (of the primary type) Rejects TimeoutError - or timeoutMessage Examples let eatGreens = function () return dash . never end dash . timeout ( eatGreens (), 10 , TasteError ): await () -- throws TasteError (after 10s)","title":"Async"},{"location":"api/Async/#async","text":"Building upon the functionality of Roblox Lua Promise and borrowing ideas from Bluebird , these functions improve the experience of working with asynchronous code in Roblox. Promises can be thought of as a variable whose value might not be known immediately when they are defined. They allow you to pass around a \"promise\" to the value, rather than yielding or waiting until the value has resolved. This means you can write functions which pass any promises to right places in your code, and delay running any code which requires the value until it is ready.","title":"Async"},{"location":"api/Async/#functions","text":"","title":"Functions"},{"location":"api/Async/#async_1","text":"function dash . async ( fn ) -- (...A) - Promise T Wraps a function which may yield in a promise. When run, async calls the the function in a coroutine and resolves with the output of the function after any asynchronous actions, and rejects if the function throws an error. Type T, A (Yieldable T, A ) - ...A - Promise T Generics T - any - the primary type (extends any value) A - any - the primary arguments (extends any value) Parameters fn - Yieldable T, A - a Yieldable (of the primary type and the primary arguments) Returns (...A) - Promise T - a function (taking the primary arguments, and returning a Promise (of the primary type)) Rejects passthrough - The returned promise will reject if promises passed as arguments reject. Examples local fetch = dash . async ( function ( url ) local HttpService = game : GetService ( HttpService ) return HttpService : GetAsync ( url ) end ) fetch ( http://example.com/burger ): andThen ( function ( meal ) print ( Meal: , meal ) end ) -- Meal: Cheeseburger (ideal response) Usage With promise:await the dash.async function can be used just like the async-await pattern in languages like JS. See dash.parallel","title":"async"},{"location":"api/Async/#asyncall","text":"function dash . asyncAll ( dictionary ) -- (...A) - Promise T {} Wraps any functions in dictionary with dash.async , returning a new dictionary containing functions that return promises when called rather than yielding. Type T, A (Yieldable T, A {}) - (...A - Promise T ){} Generics T - any - the primary type (extends any value) A - any - the primary arguments (extends any value) Parameters dictionary - Yieldable T, A {} - a dictionary (of Yieldables (of the primary type and the primary arguments)) Returns (...A) - Promise T {} - a dictionary (of functions (taking the primary arguments, and returning a Promise (of the primary type))) Examples local http = dash . asyncAll ( game : GetService ( HttpService )) http : GetAsync ( http://example.com/burger ): andThen ( function ( meal ) print ( Meal , meal ) end ) -- Meal: Cheeseburger (some time later) local buyDinner = dash . async ( function () local http = dash . asyncAll ( game : GetService ( HttpService )) local order = dash . parallelAll ({ main = http : GetAsync ( http://example.com/burger ), side = http : GetAsync ( http://example.com/fries ) }) return http : PostAsync ( http://example.com/purchase , order : await ()) end ) buyDinner (): await () -- Purchased! (some time later) See dash.async dash.parallelAll Yieldable","title":"asyncAll"},{"location":"api/Async/#await","text":"function dash . await ( value ) -- T Yields completion of a promise promise:await() , but returns immediately with the value if it isn't a promise. Type T (Promise T | T - yield T) Generics T - any - the primary type (extends any value) Parameters value - Promise T | T - a Promise (of the primary type) or the primary type Returns T - the primary type Examples local heat = function ( item ) return dash . delay ( 1 ). returns ( hot .. item ) end local recipe = { wrap , heat ( steak ), heat ( rice )} local burrito = dash . map ( recipe , dash . await ) dash . debug ( {:#?} , burrito ) -- { wrap , hot steak , hot rice } (2 seconds)","title":"await"},{"location":"api/Async/#delay","text":"function dash . delay ( delayInSeconds ) -- Promise nil Returns a promise which resolves after the given delayInSeconds. Type number - Promise nil Parameters delayInSeconds - number - a number Returns Promise nil - a Promise (of nil) Examples dash . delay ( 1 ): andThen ( function () print ( Delivered ) end ) -- Delivered (1 second later)","title":"delay"},{"location":"api/Async/#finally","text":"function dash . finally ( promise , fn ) -- Promise R Returns a promise which completes after the promise input has completed, regardless of whether it has resolved or rejected. The fn is passed true if the promise did not error, otherwise false , and the promise's result as the second argument. Type T, R (Promise T , (bool, T) - R) - Promise R Generics T - any - the primary type (extends any value) R - any - the result type (extends any value) Parameters promise - (Promise T , bool, T) - R - a function (taking a Promise (of the primary type) and a tuple (a boolean and the primary type), and returning the result type) fn - any - any value - function(ok, result) Returns Promise R - a Promise (of the result type) Examples local getHunger = dash . async ( function ( player ) if player . health == 0 then error ( Player is dead! ) else return game . ReplicatedStorage . GetHunger : InvokeServer ( player ) end end ) local localPlayer = game . Players . LocalPlayer local isHungry = getHunger ( localPlayer ): finally ( function ( isAlive , result ) return isAlive and result 5 end )","title":"finally"},{"location":"api/Async/#ispromise","text":"function dash . isPromise ( value ) -- bool Wraps Promise.is but catches any errors thrown in attempting to ascertain if value is a promise, which will occur if the value throws when trying to access missing keys. Type T (T - bool) Generics T - any - the primary type (extends any value) Parameters value - T - the primary type Returns bool - a boolean","title":"isPromise"},{"location":"api/Async/#never","text":"function dash . never () -- never Returns a promise which never resolves or rejects. Type () - never Returns never - a promise that never resolves Usage Useful in combination with dash.race where a resolution or rejection should be ignored.","title":"never"},{"location":"api/Async/#parallel","text":"function dash . parallel ( array ) -- Promise T[] Given an array of values, this function returns a promise which resolves once all of the array elements have resolved, or rejects if any of the array elements reject. Type T ((Promise T | T)[] - Promise T[] ) Generics T - any - the primary type (extends any value) Parameters array - Promise T | T[] - an array (of Promises (of the primary type) or the primary type) Returns Promise T[] - a Promise (of array (of the primary type)) - an array mapping the input to resolved elements. Rejects passthrough - The returned promise will reject if promises passed as arguments reject. Examples local heat = function ( item ) local oven = dash . parallel ({ item , dash . delay ( 1 )}) return oven : andThen ( function ( result ) return hot- .. result [ 1 ] end ) end local meal = dash . parallel ({ heat ( cheese ), tomato }) meal : await () -- { hot-cheese , tomato } (1 second later) Usage This function is like dash.all but allows objects in the array which aren't promises. These are considered resolved immediately. Promises that return nil values will cause the return array to be sparse. See Promise","title":"parallel"},{"location":"api/Async/#parallelall","text":"function dash . parallelAll ( dictionary ) -- Promise T{} Given a dictionary of values, this function returns a promise which resolves once all of the values in the dictionary have resolved, or rejects if any of them are promises that reject. Type T ((Promise T | T){}) - Promise T{} Generics T - any - the primary type (extends any value) Parameters dictionary - Promise T | T{} - a dictionary (of Promises (of the primary type) or the primary type) Returns Promise T{} - a Promise (of dictionary (of the primary type)) - a dictionary mapping the input to resolved elements. Rejects passthrough - The returned promise will reject if promises passed as arguments reject. Examples local heat = function ( item ) local oven = dash . parallel ({ item , dash . delay ( 1 )}) return oven : andThen ( function ( result ) return hot- .. result [ 1 ] end ) end local toastie = dash . parallelAll ({ bread = brown , filling = heat ( cheese ) }) toastie : await () -- {bread = brown , filling = hot-cheese } (1 second later) local fetch = dash . async ( function ( url ) local HttpService = game : GetService ( HttpService ) return HttpService : GetAsync ( url ) end ) dash . parallelAll ({ main = fetch ( http://example.com/burger ), side = fetch ( http://example.com/fries ) }): andThen ( function ( meal ) print ( Meal , dash . pretty ( meal )) end ) Usage Values which are not promises are considered resolved immediately.","title":"parallelAll"},{"location":"api/Async/#race","text":"function dash . race ( array , n ) -- Promise T[] Returns a promise which completes after the first promise in the array input completes, or first n promises if specified. If any promise rejects, race rejects with the first rejection. Type T (Promise T [], uint?) - Promise T[] Generics T - any - the primary type (extends any value) Parameters array - Promise T [] - an array (of Promises (of the primary type)) n - uint? - an unsigned integer (optional) - the number of promises required (default = 1) Returns Promise T[] - a Promise (of array (of the primary type)) - an array containing the first n resolutions, in the order that they resolved. Throws OutOfBoundsError - if the number of required promises is greater than the input length. Rejects passthrough - The returned promise will reject if promises passed as arguments reject. Examples -- Here promise resolves to the result of fetch, or resolves to No burger for you if the -- fetch takes more than 2 seconds. local fetch = dash . async ( function ( url ) local HttpService = game : GetService ( HttpService ) return HttpService : GetAsync ( url ) end ) local promise = dash . race ( dash . delay ( 2 ): andThen ( dash . returns ( No burger for you ), fetch ( http://example.com/burger ) ) Usage Note that Promises which return nil values will produce a sparse array. The size of array must be equal to or larger than n . See dash.async","title":"race"},{"location":"api/Async/#resolve","text":"function dash . resolve (...) -- Promise T Like dash.resolve but can take any number of arguments. Type T - Promise T Parameters ... - T - the type of self Returns Promise T - a Promise (of the type of self ) Examples local function mash ( veg ) return dash . resolve ( mashed , veg ) end mash ( potato ): andThen ( function ( style , veg ) dash . debug ( {} was {} , veg , style ) end ) -- potato was mashed Usage As dash.resolve(promise) -- promise , this function can also be used to ensure a value is a promise.","title":"resolve"},{"location":"api/Async/#retrywithbackoff","text":"function dash . retryWithBackoff ( asyncFn , backoffOptions ) -- Promise T Try running a function which returns a promise and retry if the function throws and error or the promise rejects. The retry behavior can be adapted using backoffOptions, which can customize the maximum number of retries and the backoff timing of the form [0, x^attemptNumber] + y where x is an exponent that produces a random exponential delay and y is a constant delay. Type T (Async T , BackoffOptions T ) - Promise T Generics T - any - the primary type (extends any value) Parameters asyncFn - Async T - an Async (of the primary type) backoffOptions - BackoffOptions T - a BackoffOptions (of the primary type) Returns Promise T - a Promise (of the primary type) Rejects passthrough - The returned promise will reject if promises passed as arguments reject. Examples -- Use dash.retryWithBackoff to retry a GET request repeatedly. local fetchPizza = dash . async ( function () local HttpService = game : GetService ( HttpService ) return HttpService : GetAsync ( https://example.com/pizza ) end ) dash . retryWithBackoff ( fetchPizza , { maxTries = 3 , onRetry = function ( waitTime , errorMessage ) print ( Failed to fetch due to , errorMessage ) print ( Retrying in , waitTime ) end }): andThen ( function ( resultingPizza ) print ( Great, you have: , resultingPizza ) end )","title":"retryWithBackoff"},{"location":"api/Async/#series","text":"function dash . series (...) -- (...A) - Promise A Like dash.compose but takes functions that can return a promise. Returns a promise that resolves once all functions have resolved. Like compose, functions receive the resolution of the previous promise as argument(s). Type A ((...A - Promise A )[]) - ...A - Promise A Generics A - any - the primary arguments (extends any value) Parameters ... - (...A) - Promise A [] - an array (of functions (taking the primary arguments, and returning a Promise (of the primary arguments))) Returns (...A) - Promise A - a function (taking the primary arguments, and returning a Promise (of the primary arguments)) Examples local function fry ( item ) return dash . delay ( 1 ): andThen ( dash . returns ( fried .. item )) end local function cheesify ( item ) return dash . delay ( 1 ): andThen ( dash . returns ( cheesy .. item )) end local prepare = dash . series ( fry , cheesify ) prepare ( nachos ): await () -- cheesy fried nachos (after 2s) See dash.parallel dash.delay","title":"series"},{"location":"api/Async/#timeout","text":"function dash . timeout ( promise , deadlineInSeconds , timeoutMessage ) -- Promise T Resolves to the result of promise if it resolves before the deadline, otherwise rejects with an error, which can be optionally customized. Type T (Promise T , number, string?) - Promise T Generics T - any - the primary type (extends any value) Parameters promise - Promise T - a Promise (of the primary type) deadlineInSeconds - number - a number timeoutMessage - string? - a string (optional) - (default = \"TimeoutError\") Returns Promise T - a Promise (of the primary type) Rejects TimeoutError - or timeoutMessage Examples let eatGreens = function () return dash . never end dash . timeout ( eatGreens (), 10 , TasteError ): await () -- throws TasteError (after 10s)","title":"timeout"},{"location":"api/Classes/","text":"Classes These tools provide implementations of and functions for higher-order abstractions such as classes, enumerations and symbols. Functions class function dash . class ( name , constructor , decorators ) -- Class T Create a class called name with the specified constructor . The constructor should return a plain table which will be turned into an instance of Class from a call to Class.new(...) . Optionally, you may provide an array of decorators which compose and reduce the Class, adding additional methods and functionality you may need. Specifically you can: Add standard functionality to the class e.g. dash.Cloneable , dash.ShallowEq Mixin an implementation of an interface e.g. dash.mixin( fns ) Decorate fields or functions e.g. dash.decorate(dash.freeze) Type T (string, Constructor T ?, Decorator T []?) - Class T Generics T - any - the primary type (extends any value) Parameters name - string - a string constructor - Constructor T ? - a Constructor (of the primary type) (optional) - (default = dash.returns({}) ) decorators - Decorator T []? - an array (of Decorators (of the primary type)) (optional) - (default = {} ) Returns Class T - a Class (of the primary type) Examples -- Create a simple Vehicle class local Vehicle = dash . class ( Vehicle , function ( wheelCount ) return { speed = 0 , wheelCount = wheelCount } end ) function Vehicle : drive ( speed ) self . speed = speed end -- Create a car instance local car = Vehicle . new ( 4 ) car . wheelCount -- 4 car . speed -- 0 -- Drive the car car : drive ( 10 ) car . speed -- 10 Usage When using Rodash classes, private fields should be prefixed with _ to avoid accidental access. A private field should only be accessed by a method of the class itself, though Rodash does not restrict this in code. Public fields are recommended when there is no complex access logic e.g. position.x See dash.classWithInterface - recommended for providing runtime type-checking. dash.mixin - extend the class with extra methods. dash.decorate - include methods that run when an instance of the class is constructed. Class.__le function Class . __le ( other ) -- string Returns true if self is considered less than or equal to other . This replaces the = operator on instances of this class, and can be overridden to provide a custom implementation. Type T - string Parameters other - T - the type of self Returns string - a string Class.__lt function Class . __lt ( other ) -- string Returns true if self is considered less than other . This replaces the operator on instances of this class, and can be overridden to provide a custom implementation. Type T - string Parameters other - T - the type of self Returns string - a string Class._init function Class . _init () -- void Run after the instance has been properly initialized, allowing methods on the instance to be used. Type (mut self) - () Returns void - nothing Examples local Vehicle = dash . class ( Vehicle , function ( wheelCount ) return { speed = 0 , wheelCount = wheelCount } end ) -- Let s define a static private function to generate a unique id for each vehicle. function Vehicle . _getNextId () Vehicle . _nextId = Vehicle . _nextId + 1 return Vehicle . _nextId end Vehicle . _nextId = 0 -- A general purpose init function may call other helper methods function Vehicle : _init () self . _id = self : _generateId () end -- Assign an id to the new instance function Vehicle : _generateId () return dash . format ( #{}: {} wheels , Vehicle . _getNextId (), self . wheelCount ) end -- Return the id if the instance is represented as a string function Vehicle : toString () return self . _id end local car = Vehicle . new ( 4 ) tostring ( car ) -- #1: 4 wheels Class.equals function Class . equals ( other ) -- bool Returns true if self is considered equal to other . This replaces the == operator on instances of this class, and can be overridden to provide a custom implementation. Type T - bool Parameters other - T - the type of self Returns bool - a boolean Class.extend function Class . extend ( name , constructor , decorators ) -- Class S Create a subclass of Class with a new name that inherits the metatable of Class , optionally overriding the constructor and providing additional decorators . The super-constructor can be accessed with undefined. Super methods can be accessed using Class.methodName and should be called with self. Type S: T (string, Constructor S ?, Decorator S []?) - Class S Generics S - T - the subject type (extends the type of self ) Parameters name - string - a string constructor - Constructor S ? - a Constructor (of the subject type) (optional) decorators - Decorator S []? - an array (of Decorators (of the subject type)) (optional) Returns Class S - a Class (of the subject type) Examples local Vehicle = dash . class ( Vehicle , function ( wheelCount ) return { speed = 0 , wheelCount = wheelCount } end ) -- Let s define a static private function to generate a unique id for each vehicle. function Vehicle . _getNextId () Vehicle . _nextId = Vehicle . _nextId + 1 return Vehicle . _nextId end Vehicle . _nextId = 0 -- A general purpose init function may call other helper methods function Vehicle : _init () self . id = self : _generateId () end -- Assign an id to the new instance function Vehicle : _generateId () return dash . format ( #{}: {} wheels , Vehicle . _getNextId (), self . wheelCount ) end -- Let s make a Car class which has a special way to generate ids local Car = Vehicle : extend ( Vehicle , function () return Vehicle . constructor ( 4 ) end ) -- Uses the super method to generate a car-specific id function Car : _generateId () self . id = dash . format ( Car {} , Vehicle . _generateId ( self )) end local car = Car . new () car . id -- Car #1: 4 wheels Class.extendWithInterface function Class . extendWithInterface ( name , interface , decorators ) -- Class S Create a subclass of Class with a new name that inherits the metatable of Class , optionally overriding the constructor and providing additional decorators . Type S: T (T: string, S, Decorator[]?) - Class S Generics S - T - the subject type (extends the type of self ) Parameters name - T: string - T (a string) interface - S - the subject type decorators - Decorator[]? - an array (of Decorators ) (optional) Returns Class S - a Class (of the subject type) Examples local Vehicle = dash . classWithInterface ( Vehicle , { color = t . string }) local Car = Vehicle : extendWithInterface ( Car , { bootContents = t . array ( t . string ) }) local car = Car . new ({ color = red , bootContents = tyre , bannana }) dash . pretty ( car ) -- Car {bootContents = { tyre , bannana }, color = red } Usage Interfaces currently silently override super interfaces, even if their types are incompatible. Avoid doing this as more advanced type checking may throw if the types do not unify in the future. See Class.extend dash.classWithInterface The t library - used to check types at runtime. Class.isInstance function Class . isInstance ( value ) -- bool Returns true if value is an instance of Class or any sub-class. Type any - bool Parameters value - any - any value Returns bool - a boolean Examples local Vehicle = dash . class ( Vehicle , function ( wheelCount ) return { speed = 0 , wheelCount = wheelCount } end ) local Car = Vehicle : extend ( Vehicle , function () return Vehicle . constructor ( 4 ) end ) local car = Car . new () car . isInstance ( Car ) -- true car . isInstance ( Vehicle ) -- true car . isInstance ( Bike ) -- false Class.new function Class . new (...) -- S Return a new instance of the class, passing any arguments to the specified constructor. Type S, A (...A - S) Generics S - any - the subject type (extends any value) A - any - the primary arguments (extends any value) Parameters ... - ...A - the primary arguments Returns S - the subject type Examples local Car = dash . class ( Car , function ( speed ) return { speed = speed } end ) local car = Car . new ( 5 ) dash . pretty ( car ) -- Car {speed = 5} Class.toString function Class . toString () -- string Return a string representation of the instance. By default this is the name field (or the Class name if this is not defined), but the method can be overridden. Type () - string Returns string - a string Examples local Car = dash . class ( Car , function ( name ) return { name = name } end ) local car = Car . new () car : toString () -- Car tostring ( car ) -- Car print ( Hello .. car ) -- Hello Car local bob = Car . new ( Bob ) bob : toString () -- Bob tostring ( bob ) -- Bob print ( Hello .. bob ) -- Hello Bob local NamedCar = dash . class ( NamedCar , function ( name ) return { name = name } end ) function NamedCar : toString () return Car called .. self . name end local bob = NamedCar . new ( Bob ) bob : toString () -- Car called Bob tostring ( bob ) -- Car called Bob print ( Hello .. bob ) -- Hello Car called Bob classWithInterface function dash . classWithInterface ( name , interface , decorators ) -- Class T Create a class called name that implements a specific strict interface which is asserted when any instance is created. Instead of using a constructor, an instance is initialized with a table containing the required fields. If an _init method is present on the instance, this is called afterwards, which has the added benefit over a constructor that self and the instance are well-defined. Rodash uses The t library to check types at runtime, meaning the interface must be a dictionary of keys mapped to type assertion functions, such as t.number , dash.isCallable etc. Optionally, you may provide an array of decorators which are reduced with the Class, adding additional functionality in the same way dash.class does. See Decorator for more information. Type T (string, Interface T , Decorator T []? - Class T ) Generics T - any - the primary type (extends any value) Parameters name - string - a string interface - Interface T - an Interface (of the primary type) decorators - Decorator T []? - an array (of Decorators (of the primary type)) (optional) Returns Class T - a Class (of the primary type) Examples local Vehicle = dash . classWithInterface ( Vehicle , { speed = t . number , wheelCount = t . number , color = t . string }) local vehicle = Vehicle . new ({ speed = 5 , wheelCount = 4 , color = red }) dash . pretty ( vehicle ) -- Vehicle {speed = 4, wheelCount = 4, color = red } Usage Rodash uses t by Osyris to perform runtime type assertions, which we recommend using during development and production code to catch errors quickly and fail fast. For more information about t , please visit https://github.com/osyrisrblx/t . If you want to instantiate private fields, we recommend using a static factory with a public interface, See dash.privatize for an example. See dash.class dash.privatize The t library - used to check types at runtime. Cloneable function dash . Cloneable ( Class ) -- Cloneable T A decorator which derives a :clone() method for the Class that returns a shallow clone of the instance when called that has the same metatable as the instance it is called on. Type T (Class T - Cloneable T ) Generics T - any - the primary type (extends any value) Parameters Class - Class T - a Class (of the primary type) Returns Cloneable T - a Cloneable (of the primary type) Examples local Car = Classes . class ( Car , function ( speed ) return { speed = speed } end , { dash . Cloneable } ) function Car : brake () self . speed = 0 end local car = Car . new ( 5 ) local carClone = car : clone () print ( carClone . speed ) -- 5 carClone : brake () print ( carClone . speed ) -- 0 print ( car . speed ) -- 5 decorate function dash . decorate ( fn ) -- (Class T ) - Class T Returns a decorator which runs fn on each instance of the class that is created, returning the result of the function as the class instance. Type T ((self:T, ... - ...) - Class T - Class T ) Generics T - any - the primary type (extends any value) Parameters fn - (self: T, ...any) - ...any - a function (taking self (the primary type) and any values, and returning any values) Returns (Class T ) - Class T - a function (taking a Class (of the primary type), and returning a Class (of the primary type)) Examples -- Create a decorator which freezes all class keys local Frozen = dash . decorate ( dash . freeze ) local StaticCar = dash . class ( StaticCar , function ( speed ) return { speed = speed } end , { Frozen }) function StaticCar : brake () self . speed = 0 end local car = Car . new ( 5 ) print ( car . speed ) -- 5 -- The car cannot change speed because speed is now readonly. car : brake () --! ReadonlyKey: Attempt to write to a frozen key speed Usage Include the return value of this function in the decorators argument when creating a class. See dash.freeze enum function dash . enum ( keys ) -- Enum T Create an enumeration from an array string keys , provided in upper snake-case. An Enum is used when a value should only be one of a limited number of possible states. dash.enum creates a string enum, which uses a name for each state so it is easy to refer to. For ease of use values in the enum are identical to their key. Enums are frozen and will throw if access to a missing key is attempted, helping to eliminate typos. Symbols are not used so that enum values are serializable. Type T (string - Enum T ) Generics T - any - the primary type (extends any value) Parameters keys - string - a string - provided in upper snake-case. Returns Enum T - an Enum (of the primary type) Examples local TOGGLE = dash . enum ( ON , OFF ) local switch = TOGGLE . ON if switch == TOGGLE . ON then game . Workspace . RoomLight . Brightness = 1 else game . Workspace . RoomLight . Brightness = 0 end See dash.match finalize function dash . finalize ( object ) -- T dash.finalize takes object and makes updating or accessing missing keys throw FinalObject . Type T:{} (mut T - T) Generics T - {} - the primary type (extends a table) Parameters object - mut T - the primary type (which can be mutated) Returns T - the primary type Examples local drink = { mixer = coke , spirit = rum } dash . finalize ( drink ) drink . mixer = soda drink . mixer -- soda print ( drink . syrup ) --! FinalObject: Attempt to read missing key syrup to final object drink . syrup = peach --! FinalObject: Attempt to add key mixer on final object Formatable function dash . Formatable ( keys ) -- (Class T ) - Formatable T A decorator which derives a :toString() method for the Class that displays a serialized string of the class name and values of any keys provided. Type T (string[]? - Class T - Formatable T ) Generics T - any - the primary type (extends any value) Parameters keys - string[]? - an array (of strings) (optional) - (default = all the keys of the instance except \"Class\" ) Returns (Class T ) - Formatable T - a function (taking a Class (of the primary type), and returning a Formatable (of the primary type)) Examples local Car = Classes . class ( Car , function ( speed ) return { speed = speed , color = red } end , { dash . Formatable ({ speed })} ) print ( Car . new ( 5 )) -- Car({speed:5}) freeze function dash . freeze ( object ) -- T dash.freeze takes object and returns a new read-only version which prevents any values from being changed. Unfortunately you cannot iterate using pairs or ipairs on frozen objects because Lua 5.1 does not support overwriting these in metatables. However, you can use dash.iterator to get an iterator for the object and use that. Iterating functions in Rodash such as dash.map , dash.filter etc. can iterate over frozen objects without this. If you want to treat the objects as arrays use dash.iterator(frozenObject, true) explicitly. Type T: table (T - T) Generics T - table - the primary type (extends a table ) Parameters object - T - the primary type Returns T - the primary type Examples local drink = dash . freeze ({ flavor = mint , topping = sprinkles }) print ( drink . flavor ) -- mint drink . flavor = vanilla --! ReadonlyKey: Attempt to write to a frozen key flavor print ( drink . syrup ) -- nil drink . topping = flake --! ReadonlyKey: Attempt to write to a frozen key topping dash . values ( drink ) -- { mint , sprinkles } See dash.iterator isA function dash . isA ( value , Type ) -- bool Returns true if value is an instance of type . Type can currently be either an Enum or a Class table. For instances of classes, dash.isA will also return true if the instance is an instance of any sub-class. The function will catch any errors thrown during this check, returning false if so. Type T (any, Type T - bool) Generics T - any - the primary type (extends any value) Parameters value - any - any value Type - Type T - a Type (of the primary type) Returns bool - a boolean Examples local Vehicle = dash . class ( Vehicle , function ( wheelCount ) return { speed = 0 , wheelCount = wheelCount } end ) local car = Vehicle . new ( 4 ) Vehicle . isA ( car ) -- true Vehicle . isA ( 5 ) -- false local TOGGLE = dash . enum ( ON , OFF ) TOGGLE . isA ( ON ) -- true TOGGLE . isA ( 5 ) -- false Usage This is useful if you know nothing about value . match function dash . match ( enum , strategies ) -- (enumValue: T, ...A) - V Given an enum and strategies , a dictionary of functions keyed by enum values, dash.match returns a function that will execute the strategy for any value provided. A strategy for every enum key must be implemented, and this helps prevent missing values from causing problems later on down the line. Type T, ...A, V (Enum T , {[enumValue: T]: Strategy V, A }) - (enumValue: T, ...A) - V Generics T - any - the primary type (extends any value) A - any - the primary arguments (extends any value) V - any - the primary value type (extends any value) Parameters enum - Enum T - an Enum (of the primary type) strategies - {[enumValue: T]: Strategy V, A } - a dictionary mapping enumValue (the primary type) to Strategys (of the primary value type and the primary arguments) Returns (enumValue: T, ...A) - V - a function (taking enumValue (the primary type) and the primary arguments, and returning the primary value type) Examples local TOGGLE = dash . enum ( ON , OFF ) local setLightTo = dash . match ( TOGGLE , { ON = function ( light ) light . Brightness = 1 end , OFF = function ( light ) light . Brightness = 0 end }) -- This can be used to turn any light on or off: setLightTo ( TOGGLE . ON , game . Workspace . RoomLight ) -- Light turns on -- But will catch an invalid enum value: setLightTo ( Dim , game . Workspace . RoomLight ) --! BadInput: enumValue must be an instance of enum mixin function dash . mixin ( fns ) -- (Class T ) - Class T A decorator which adds a dictionary of functions to a Class table. Type T ((T, ... - ...)[] - Class T - Class T ) Generics T - any - the primary type (extends any value) Parameters fns - (T, ...any) - ...any[] - an array (of functions (taking the primary type and any values, and returning any values)) Returns (Class T ) - Class T - a function (taking a Class (of the primary type), and returning a Class (of the primary type)) Examples local CanBrake = { brake = function ( self ) self . speed = 0 end } local Car = dash . class ( Car , function ( speed ) return { speed = speed } end , { dash . mixin ( CanBrake )}) local car = Car . new ( 5 ) print ( car . speed ) -- 5 car : brake () print ( car . speed ) -- 0 Usage Include the return value of this function in the decorators argument when creating a class. PartialOrd function dash . PartialOrd ( keys ) -- (Class T ) - PartialOrd T A decorator which derives an order for the Class , meaning instances of the class can be compared using , = , and = . To do this, it compares values of the two instances at the same keys, as defined by the order of the keys passed in. Type T (string[]? - Class T - PartialOrd T ) Generics T - any - the primary type (extends any value) Parameters keys - string[]? - an array (of strings) (optional) - (default = a sorted array of all the instance's keys) Returns (Class T ) - PartialOrd T - a function (taking a Class (of the primary type), and returning a PartialOrd (of the primary type)) Examples local Car = Classes . class ( Car , function ( speed ) return { speed = speed } end , { dash . PartialOrd ()} ) function Car : brake () self . speed = 0 end local fastCar = Car . new ( 500 ) local fastCar2 = Car . new ( 500 ) local slowCar = Car . new ( 5 ) print ( fastCar == fastCar2 ) -- true print ( fastCar == slowCar ) -- false ShallowEq function dash . ShallowEq ( Class ) -- ShallowEq T A decorator which derives the equality operator for the Class so that any instances of the class which are shallow equal will be considered equal. Type T (Class T - ShallowEq T ) Generics T - any - the primary type (extends any value) Parameters Class - Class T - a Class (of the primary type) Returns ShallowEq T - a ShallowEq (of the primary type) Examples local Car = Classes . class ( Car , function ( speed ) return { speed = speed } end , { dash . ShallowEq } ) function Car : brake () self . speed = 0 end local fastCar = Car . new ( 500 ) local fastCar2 = Car . new ( 500 ) local slowCar = Car . new ( 5 ) print ( fastCar == fastCar2 ) -- true print ( fastCar == slowCar ) -- false Usage If you want to check for equality that includes deep descendants, we recommend you implement a custom :equals method on your class rather than use dash.deepEqual as this may be slow or fail to check the type of instances in the tree. See dash.deepEqual - if you want to consider deep equality Class:equals symbol function dash . symbol ( name ) -- Symbol T Create a symbol with a specified name . We recommend upper snake-case as the symbol is a constant, unless you are linking the symbol conceptually to a different string. Symbols are useful when you want a value that isn't equal to any other type, for example if you want to store a unique property on an object that won't be accidentally accessed with a simple string lookup. Type T (string - Symbol T ) Generics T - any - the primary type (extends any value) Parameters name - string - a string Returns Symbol T - a Symbol (of the primary type) Examples local DOUBLE = dash . symbol ( DOUBLE ) -- This function acts like filter, but doubles any elements in a row for which DOUBLE is -- returned rather than true or false. local function filterWithDouble ( array , fn ) return dash . flatMap ( array , function ( element ) local result = fn ( element ) if result == DOUBLE then return { result , result } elseif result then return { result } else return {} end end ) end local array = { 1 , 2 , 3 , 4 , 5 } local function isEven ( value ) return value % 2 == 0 end filterWithDouble ( array , isEven ) -- {1, 2, 2, 3, 4, 4, 5}","title":"Classes"},{"location":"api/Classes/#classes","text":"These tools provide implementations of and functions for higher-order abstractions such as classes, enumerations and symbols.","title":"Classes"},{"location":"api/Classes/#functions","text":"","title":"Functions"},{"location":"api/Classes/#class","text":"function dash . class ( name , constructor , decorators ) -- Class T Create a class called name with the specified constructor . The constructor should return a plain table which will be turned into an instance of Class from a call to Class.new(...) . Optionally, you may provide an array of decorators which compose and reduce the Class, adding additional methods and functionality you may need. Specifically you can: Add standard functionality to the class e.g. dash.Cloneable , dash.ShallowEq Mixin an implementation of an interface e.g. dash.mixin( fns ) Decorate fields or functions e.g. dash.decorate(dash.freeze) Type T (string, Constructor T ?, Decorator T []?) - Class T Generics T - any - the primary type (extends any value) Parameters name - string - a string constructor - Constructor T ? - a Constructor (of the primary type) (optional) - (default = dash.returns({}) ) decorators - Decorator T []? - an array (of Decorators (of the primary type)) (optional) - (default = {} ) Returns Class T - a Class (of the primary type) Examples -- Create a simple Vehicle class local Vehicle = dash . class ( Vehicle , function ( wheelCount ) return { speed = 0 , wheelCount = wheelCount } end ) function Vehicle : drive ( speed ) self . speed = speed end -- Create a car instance local car = Vehicle . new ( 4 ) car . wheelCount -- 4 car . speed -- 0 -- Drive the car car : drive ( 10 ) car . speed -- 10 Usage When using Rodash classes, private fields should be prefixed with _ to avoid accidental access. A private field should only be accessed by a method of the class itself, though Rodash does not restrict this in code. Public fields are recommended when there is no complex access logic e.g. position.x See dash.classWithInterface - recommended for providing runtime type-checking. dash.mixin - extend the class with extra methods. dash.decorate - include methods that run when an instance of the class is constructed.","title":"class"},{"location":"api/Classes/#class__le","text":"function Class . __le ( other ) -- string Returns true if self is considered less than or equal to other . This replaces the = operator on instances of this class, and can be overridden to provide a custom implementation. Type T - string Parameters other - T - the type of self Returns string - a string","title":"Class.__le"},{"location":"api/Classes/#class__lt","text":"function Class . __lt ( other ) -- string Returns true if self is considered less than other . This replaces the operator on instances of this class, and can be overridden to provide a custom implementation. Type T - string Parameters other - T - the type of self Returns string - a string","title":"Class.__lt"},{"location":"api/Classes/#class_init","text":"function Class . _init () -- void Run after the instance has been properly initialized, allowing methods on the instance to be used. Type (mut self) - () Returns void - nothing Examples local Vehicle = dash . class ( Vehicle , function ( wheelCount ) return { speed = 0 , wheelCount = wheelCount } end ) -- Let s define a static private function to generate a unique id for each vehicle. function Vehicle . _getNextId () Vehicle . _nextId = Vehicle . _nextId + 1 return Vehicle . _nextId end Vehicle . _nextId = 0 -- A general purpose init function may call other helper methods function Vehicle : _init () self . _id = self : _generateId () end -- Assign an id to the new instance function Vehicle : _generateId () return dash . format ( #{}: {} wheels , Vehicle . _getNextId (), self . wheelCount ) end -- Return the id if the instance is represented as a string function Vehicle : toString () return self . _id end local car = Vehicle . new ( 4 ) tostring ( car ) -- #1: 4 wheels","title":"Class._init"},{"location":"api/Classes/#classequals","text":"function Class . equals ( other ) -- bool Returns true if self is considered equal to other . This replaces the == operator on instances of this class, and can be overridden to provide a custom implementation. Type T - bool Parameters other - T - the type of self Returns bool - a boolean","title":"Class.equals"},{"location":"api/Classes/#classextend","text":"function Class . extend ( name , constructor , decorators ) -- Class S Create a subclass of Class with a new name that inherits the metatable of Class , optionally overriding the constructor and providing additional decorators . The super-constructor can be accessed with undefined. Super methods can be accessed using Class.methodName and should be called with self. Type S: T (string, Constructor S ?, Decorator S []?) - Class S Generics S - T - the subject type (extends the type of self ) Parameters name - string - a string constructor - Constructor S ? - a Constructor (of the subject type) (optional) decorators - Decorator S []? - an array (of Decorators (of the subject type)) (optional) Returns Class S - a Class (of the subject type) Examples local Vehicle = dash . class ( Vehicle , function ( wheelCount ) return { speed = 0 , wheelCount = wheelCount } end ) -- Let s define a static private function to generate a unique id for each vehicle. function Vehicle . _getNextId () Vehicle . _nextId = Vehicle . _nextId + 1 return Vehicle . _nextId end Vehicle . _nextId = 0 -- A general purpose init function may call other helper methods function Vehicle : _init () self . id = self : _generateId () end -- Assign an id to the new instance function Vehicle : _generateId () return dash . format ( #{}: {} wheels , Vehicle . _getNextId (), self . wheelCount ) end -- Let s make a Car class which has a special way to generate ids local Car = Vehicle : extend ( Vehicle , function () return Vehicle . constructor ( 4 ) end ) -- Uses the super method to generate a car-specific id function Car : _generateId () self . id = dash . format ( Car {} , Vehicle . _generateId ( self )) end local car = Car . new () car . id -- Car #1: 4 wheels","title":"Class.extend"},{"location":"api/Classes/#classextendwithinterface","text":"function Class . extendWithInterface ( name , interface , decorators ) -- Class S Create a subclass of Class with a new name that inherits the metatable of Class , optionally overriding the constructor and providing additional decorators . Type S: T (T: string, S, Decorator[]?) - Class S Generics S - T - the subject type (extends the type of self ) Parameters name - T: string - T (a string) interface - S - the subject type decorators - Decorator[]? - an array (of Decorators ) (optional) Returns Class S - a Class (of the subject type) Examples local Vehicle = dash . classWithInterface ( Vehicle , { color = t . string }) local Car = Vehicle : extendWithInterface ( Car , { bootContents = t . array ( t . string ) }) local car = Car . new ({ color = red , bootContents = tyre , bannana }) dash . pretty ( car ) -- Car {bootContents = { tyre , bannana }, color = red } Usage Interfaces currently silently override super interfaces, even if their types are incompatible. Avoid doing this as more advanced type checking may throw if the types do not unify in the future. See Class.extend dash.classWithInterface The t library - used to check types at runtime.","title":"Class.extendWithInterface"},{"location":"api/Classes/#classisinstance","text":"function Class . isInstance ( value ) -- bool Returns true if value is an instance of Class or any sub-class. Type any - bool Parameters value - any - any value Returns bool - a boolean Examples local Vehicle = dash . class ( Vehicle , function ( wheelCount ) return { speed = 0 , wheelCount = wheelCount } end ) local Car = Vehicle : extend ( Vehicle , function () return Vehicle . constructor ( 4 ) end ) local car = Car . new () car . isInstance ( Car ) -- true car . isInstance ( Vehicle ) -- true car . isInstance ( Bike ) -- false","title":"Class.isInstance"},{"location":"api/Classes/#classnew","text":"function Class . new (...) -- S Return a new instance of the class, passing any arguments to the specified constructor. Type S, A (...A - S) Generics S - any - the subject type (extends any value) A - any - the primary arguments (extends any value) Parameters ... - ...A - the primary arguments Returns S - the subject type Examples local Car = dash . class ( Car , function ( speed ) return { speed = speed } end ) local car = Car . new ( 5 ) dash . pretty ( car ) -- Car {speed = 5}","title":"Class.new"},{"location":"api/Classes/#classtostring","text":"function Class . toString () -- string Return a string representation of the instance. By default this is the name field (or the Class name if this is not defined), but the method can be overridden. Type () - string Returns string - a string Examples local Car = dash . class ( Car , function ( name ) return { name = name } end ) local car = Car . new () car : toString () -- Car tostring ( car ) -- Car print ( Hello .. car ) -- Hello Car local bob = Car . new ( Bob ) bob : toString () -- Bob tostring ( bob ) -- Bob print ( Hello .. bob ) -- Hello Bob local NamedCar = dash . class ( NamedCar , function ( name ) return { name = name } end ) function NamedCar : toString () return Car called .. self . name end local bob = NamedCar . new ( Bob ) bob : toString () -- Car called Bob tostring ( bob ) -- Car called Bob print ( Hello .. bob ) -- Hello Car called Bob","title":"Class.toString"},{"location":"api/Classes/#classwithinterface","text":"function dash . classWithInterface ( name , interface , decorators ) -- Class T Create a class called name that implements a specific strict interface which is asserted when any instance is created. Instead of using a constructor, an instance is initialized with a table containing the required fields. If an _init method is present on the instance, this is called afterwards, which has the added benefit over a constructor that self and the instance are well-defined. Rodash uses The t library to check types at runtime, meaning the interface must be a dictionary of keys mapped to type assertion functions, such as t.number , dash.isCallable etc. Optionally, you may provide an array of decorators which are reduced with the Class, adding additional functionality in the same way dash.class does. See Decorator for more information. Type T (string, Interface T , Decorator T []? - Class T ) Generics T - any - the primary type (extends any value) Parameters name - string - a string interface - Interface T - an Interface (of the primary type) decorators - Decorator T []? - an array (of Decorators (of the primary type)) (optional) Returns Class T - a Class (of the primary type) Examples local Vehicle = dash . classWithInterface ( Vehicle , { speed = t . number , wheelCount = t . number , color = t . string }) local vehicle = Vehicle . new ({ speed = 5 , wheelCount = 4 , color = red }) dash . pretty ( vehicle ) -- Vehicle {speed = 4, wheelCount = 4, color = red } Usage Rodash uses t by Osyris to perform runtime type assertions, which we recommend using during development and production code to catch errors quickly and fail fast. For more information about t , please visit https://github.com/osyrisrblx/t . If you want to instantiate private fields, we recommend using a static factory with a public interface, See dash.privatize for an example. See dash.class dash.privatize The t library - used to check types at runtime.","title":"classWithInterface"},{"location":"api/Classes/#cloneable","text":"function dash . Cloneable ( Class ) -- Cloneable T A decorator which derives a :clone() method for the Class that returns a shallow clone of the instance when called that has the same metatable as the instance it is called on. Type T (Class T - Cloneable T ) Generics T - any - the primary type (extends any value) Parameters Class - Class T - a Class (of the primary type) Returns Cloneable T - a Cloneable (of the primary type) Examples local Car = Classes . class ( Car , function ( speed ) return { speed = speed } end , { dash . Cloneable } ) function Car : brake () self . speed = 0 end local car = Car . new ( 5 ) local carClone = car : clone () print ( carClone . speed ) -- 5 carClone : brake () print ( carClone . speed ) -- 0 print ( car . speed ) -- 5","title":"Cloneable"},{"location":"api/Classes/#decorate","text":"function dash . decorate ( fn ) -- (Class T ) - Class T Returns a decorator which runs fn on each instance of the class that is created, returning the result of the function as the class instance. Type T ((self:T, ... - ...) - Class T - Class T ) Generics T - any - the primary type (extends any value) Parameters fn - (self: T, ...any) - ...any - a function (taking self (the primary type) and any values, and returning any values) Returns (Class T ) - Class T - a function (taking a Class (of the primary type), and returning a Class (of the primary type)) Examples -- Create a decorator which freezes all class keys local Frozen = dash . decorate ( dash . freeze ) local StaticCar = dash . class ( StaticCar , function ( speed ) return { speed = speed } end , { Frozen }) function StaticCar : brake () self . speed = 0 end local car = Car . new ( 5 ) print ( car . speed ) -- 5 -- The car cannot change speed because speed is now readonly. car : brake () --! ReadonlyKey: Attempt to write to a frozen key speed Usage Include the return value of this function in the decorators argument when creating a class. See dash.freeze","title":"decorate"},{"location":"api/Classes/#enum","text":"function dash . enum ( keys ) -- Enum T Create an enumeration from an array string keys , provided in upper snake-case. An Enum is used when a value should only be one of a limited number of possible states. dash.enum creates a string enum, which uses a name for each state so it is easy to refer to. For ease of use values in the enum are identical to their key. Enums are frozen and will throw if access to a missing key is attempted, helping to eliminate typos. Symbols are not used so that enum values are serializable. Type T (string - Enum T ) Generics T - any - the primary type (extends any value) Parameters keys - string - a string - provided in upper snake-case. Returns Enum T - an Enum (of the primary type) Examples local TOGGLE = dash . enum ( ON , OFF ) local switch = TOGGLE . ON if switch == TOGGLE . ON then game . Workspace . RoomLight . Brightness = 1 else game . Workspace . RoomLight . Brightness = 0 end See dash.match","title":"enum"},{"location":"api/Classes/#finalize","text":"function dash . finalize ( object ) -- T dash.finalize takes object and makes updating or accessing missing keys throw FinalObject . Type T:{} (mut T - T) Generics T - {} - the primary type (extends a table) Parameters object - mut T - the primary type (which can be mutated) Returns T - the primary type Examples local drink = { mixer = coke , spirit = rum } dash . finalize ( drink ) drink . mixer = soda drink . mixer -- soda print ( drink . syrup ) --! FinalObject: Attempt to read missing key syrup to final object drink . syrup = peach --! FinalObject: Attempt to add key mixer on final object","title":"finalize"},{"location":"api/Classes/#formatable","text":"function dash . Formatable ( keys ) -- (Class T ) - Formatable T A decorator which derives a :toString() method for the Class that displays a serialized string of the class name and values of any keys provided. Type T (string[]? - Class T - Formatable T ) Generics T - any - the primary type (extends any value) Parameters keys - string[]? - an array (of strings) (optional) - (default = all the keys of the instance except \"Class\" ) Returns (Class T ) - Formatable T - a function (taking a Class (of the primary type), and returning a Formatable (of the primary type)) Examples local Car = Classes . class ( Car , function ( speed ) return { speed = speed , color = red } end , { dash . Formatable ({ speed })} ) print ( Car . new ( 5 )) -- Car({speed:5})","title":"Formatable"},{"location":"api/Classes/#freeze","text":"function dash . freeze ( object ) -- T dash.freeze takes object and returns a new read-only version which prevents any values from being changed. Unfortunately you cannot iterate using pairs or ipairs on frozen objects because Lua 5.1 does not support overwriting these in metatables. However, you can use dash.iterator to get an iterator for the object and use that. Iterating functions in Rodash such as dash.map , dash.filter etc. can iterate over frozen objects without this. If you want to treat the objects as arrays use dash.iterator(frozenObject, true) explicitly. Type T: table (T - T) Generics T - table - the primary type (extends a table ) Parameters object - T - the primary type Returns T - the primary type Examples local drink = dash . freeze ({ flavor = mint , topping = sprinkles }) print ( drink . flavor ) -- mint drink . flavor = vanilla --! ReadonlyKey: Attempt to write to a frozen key flavor print ( drink . syrup ) -- nil drink . topping = flake --! ReadonlyKey: Attempt to write to a frozen key topping dash . values ( drink ) -- { mint , sprinkles } See dash.iterator","title":"freeze"},{"location":"api/Classes/#isa","text":"function dash . isA ( value , Type ) -- bool Returns true if value is an instance of type . Type can currently be either an Enum or a Class table. For instances of classes, dash.isA will also return true if the instance is an instance of any sub-class. The function will catch any errors thrown during this check, returning false if so. Type T (any, Type T - bool) Generics T - any - the primary type (extends any value) Parameters value - any - any value Type - Type T - a Type (of the primary type) Returns bool - a boolean Examples local Vehicle = dash . class ( Vehicle , function ( wheelCount ) return { speed = 0 , wheelCount = wheelCount } end ) local car = Vehicle . new ( 4 ) Vehicle . isA ( car ) -- true Vehicle . isA ( 5 ) -- false local TOGGLE = dash . enum ( ON , OFF ) TOGGLE . isA ( ON ) -- true TOGGLE . isA ( 5 ) -- false Usage This is useful if you know nothing about value .","title":"isA"},{"location":"api/Classes/#match","text":"function dash . match ( enum , strategies ) -- (enumValue: T, ...A) - V Given an enum and strategies , a dictionary of functions keyed by enum values, dash.match returns a function that will execute the strategy for any value provided. A strategy for every enum key must be implemented, and this helps prevent missing values from causing problems later on down the line. Type T, ...A, V (Enum T , {[enumValue: T]: Strategy V, A }) - (enumValue: T, ...A) - V Generics T - any - the primary type (extends any value) A - any - the primary arguments (extends any value) V - any - the primary value type (extends any value) Parameters enum - Enum T - an Enum (of the primary type) strategies - {[enumValue: T]: Strategy V, A } - a dictionary mapping enumValue (the primary type) to Strategys (of the primary value type and the primary arguments) Returns (enumValue: T, ...A) - V - a function (taking enumValue (the primary type) and the primary arguments, and returning the primary value type) Examples local TOGGLE = dash . enum ( ON , OFF ) local setLightTo = dash . match ( TOGGLE , { ON = function ( light ) light . Brightness = 1 end , OFF = function ( light ) light . Brightness = 0 end }) -- This can be used to turn any light on or off: setLightTo ( TOGGLE . ON , game . Workspace . RoomLight ) -- Light turns on -- But will catch an invalid enum value: setLightTo ( Dim , game . Workspace . RoomLight ) --! BadInput: enumValue must be an instance of enum","title":"match"},{"location":"api/Classes/#mixin","text":"function dash . mixin ( fns ) -- (Class T ) - Class T A decorator which adds a dictionary of functions to a Class table. Type T ((T, ... - ...)[] - Class T - Class T ) Generics T - any - the primary type (extends any value) Parameters fns - (T, ...any) - ...any[] - an array (of functions (taking the primary type and any values, and returning any values)) Returns (Class T ) - Class T - a function (taking a Class (of the primary type), and returning a Class (of the primary type)) Examples local CanBrake = { brake = function ( self ) self . speed = 0 end } local Car = dash . class ( Car , function ( speed ) return { speed = speed } end , { dash . mixin ( CanBrake )}) local car = Car . new ( 5 ) print ( car . speed ) -- 5 car : brake () print ( car . speed ) -- 0 Usage Include the return value of this function in the decorators argument when creating a class.","title":"mixin"},{"location":"api/Classes/#partialord","text":"function dash . PartialOrd ( keys ) -- (Class T ) - PartialOrd T A decorator which derives an order for the Class , meaning instances of the class can be compared using , = , and = . To do this, it compares values of the two instances at the same keys, as defined by the order of the keys passed in. Type T (string[]? - Class T - PartialOrd T ) Generics T - any - the primary type (extends any value) Parameters keys - string[]? - an array (of strings) (optional) - (default = a sorted array of all the instance's keys) Returns (Class T ) - PartialOrd T - a function (taking a Class (of the primary type), and returning a PartialOrd (of the primary type)) Examples local Car = Classes . class ( Car , function ( speed ) return { speed = speed } end , { dash . PartialOrd ()} ) function Car : brake () self . speed = 0 end local fastCar = Car . new ( 500 ) local fastCar2 = Car . new ( 500 ) local slowCar = Car . new ( 5 ) print ( fastCar == fastCar2 ) -- true print ( fastCar == slowCar ) -- false","title":"PartialOrd"},{"location":"api/Classes/#shalloweq","text":"function dash . ShallowEq ( Class ) -- ShallowEq T A decorator which derives the equality operator for the Class so that any instances of the class which are shallow equal will be considered equal. Type T (Class T - ShallowEq T ) Generics T - any - the primary type (extends any value) Parameters Class - Class T - a Class (of the primary type) Returns ShallowEq T - a ShallowEq (of the primary type) Examples local Car = Classes . class ( Car , function ( speed ) return { speed = speed } end , { dash . ShallowEq } ) function Car : brake () self . speed = 0 end local fastCar = Car . new ( 500 ) local fastCar2 = Car . new ( 500 ) local slowCar = Car . new ( 5 ) print ( fastCar == fastCar2 ) -- true print ( fastCar == slowCar ) -- false Usage If you want to check for equality that includes deep descendants, we recommend you implement a custom :equals method on your class rather than use dash.deepEqual as this may be slow or fail to check the type of instances in the tree. See dash.deepEqual - if you want to consider deep equality Class:equals","title":"ShallowEq"},{"location":"api/Classes/#symbol","text":"function dash . symbol ( name ) -- Symbol T Create a symbol with a specified name . We recommend upper snake-case as the symbol is a constant, unless you are linking the symbol conceptually to a different string. Symbols are useful when you want a value that isn't equal to any other type, for example if you want to store a unique property on an object that won't be accidentally accessed with a simple string lookup. Type T (string - Symbol T ) Generics T - any - the primary type (extends any value) Parameters name - string - a string Returns Symbol T - a Symbol (of the primary type) Examples local DOUBLE = dash . symbol ( DOUBLE ) -- This function acts like filter, but doubles any elements in a row for which DOUBLE is -- returned rather than true or false. local function filterWithDouble ( array , fn ) return dash . flatMap ( array , function ( element ) local result = fn ( element ) if result == DOUBLE then return { result , result } elseif result then return { result } else return {} end end ) end local array = { 1 , 2 , 3 , 4 , 5 } local function isEven ( value ) return value % 2 == 0 end filterWithDouble ( array , isEven ) -- {1, 2, 2, 3, 4, 4, 5}","title":"symbol"},{"location":"api/Functions/","text":"Functions Utility functions and building blocks for functional programming styles. Functions bind function dash . bind ( fn , ...) -- (...A2) - R Takes a function fn and binds arguments to the head of the fn argument list. Returns a function which executes fn , passing the bound arguments supplied, followed by any dynamic arguments. Type A, A2, R (((...A, ...A2 - R), ...A) - ...A2 - R) Generics A - any - the primary arguments (extends any value) A2 - any - the secondary arguments (extends any value) R - any - the result type (extends any value) Parameters fn - (...A, ...A2) - R - a function (taking the primary arguments and the secondary arguments, and returning the result type) ... - ...A - the primary arguments Returns (...A2) - R - a function (taking the secondary arguments, and returning the result type) Examples local function damagePlayer ( player , amount ) player : Damage ( amount ) end local damageLocalPlayer = dash . bind ( damagePlayer , game . Players . LocalPlayer ) damageLocalPlayer ( 5 ) bindTail function dash . bindTail ( fn , ...) -- (S) - S Takes a chainable function fn and binds arguments to the tail of the fn argument list. Returns a function which executes fn , passing a subject ahead of the bound arguments supplied. Type S (Chainable S , ...) - S - S Generics S - any - the subject type (extends any value) Parameters fn - Chainable S - a Chainable (of the subject type) ... - ...any - any values Returns (S) - S - a function (taking the subject type, and returning the subject type) Examples local function setHealthTo ( player , health ) player . Health = health end local restoreHealth = dash . bindTail ( setHealthTo , 100 ) local Jimbo = { Health = 1 } restoreHealth local filterHurtPlayers = dash . bindTail ( dash . filter , function ( player ) return player . Health player . MaxHealth end ) local getName = dash . bindTail ( dash . map , function ( player ) return player . Name end ) local filterHurtNames = dash . compose ( filterHurtPlayers , getName ) filterHurtNames ( game . Players ) -- { Frodo , Boromir } Usage Chainable rodash function feeds are mapped to dash.fn , such as dash.fn.map(handler) . See dash.filter dash.compose Chainable call function dash . call ( subject , fn , ...) -- R Calls the supplied fn on the subject and any additional arguments, returning the result. Type S, A, R (S, (S, ...A - R), ...A - R) Generics S - any - the subject type (extends any value) A - any - the primary arguments (extends any value) R - any - the result type (extends any value) Parameters subject - S - the subject type fn - (S, ...A) - R - a function (taking the subject type and the primary arguments, and returning the result type) ... - ...A - the primary arguments Returns R - the result type Examples local function get ( object , key ) return object [ key ] end local Jimbo = { Name = Jimbo } dash . call ( Jimbo , get , Name ) -- Jimbo local function get ( object , key ) return object [ key ] end local isABaggins = dash . fn : call ( get , Name ): endsWith ( Baggins ) local Jimbo = { Name = Jimbo } isABaggins ( Jimbo ) -- false Usage This is useful when used in the dash.fn:call form to call arbitrary function inside a chain. See dash.chain Chainable chain function dash . chain ( fns , actor ) -- Chain S Chain takes a dictionary of chainable functions and returns a Chain instance with methods mapped to the input functions. Chaining is useful when you want to simplify operating on data in a common form and perform sequences of operations on some data with a very concise syntax. An actor function can check the value of the data at each step and change how the chain proceeds. Calling a Chain with a subject reduces the chained operations in order on the subject. Type S (Chainable S {}, Actor S ) - Chain S Generics S - any - the subject type (extends any value) Parameters fns - Chainable S {} - a dictionary (of Chainables (of the subject type)) actor - Actor S - an Actor (of the subject type) - called for each result in the chain to determine how the next operation should process it. (default = dash.invoke ) Returns Chain S - a Chain (of the subject type) Examples -- Define a simple chain that can operate a list of numbers. -- A chain function is called with the subject being processed as first argument, -- and any arguments passed in the chain as subsequent arguments. local numberChain = dash . chain ({ addN = function ( list , n ) return dash . map ( list , function ( element ) return element + n end ) end , sum = function ( list ) return dash . sum ( list ) end }) local op = numberChain : addN ( 2 ): sum () op ({ 1 , 2 , 3 }) -- 12 -- Get the name of a player local function getName ( player ) return player . Name end ) -- Create a chain that filters for hurt players and finds their name local filterHurtNames = dash . fn : filter ( function ( player ) return player . Health player . MaxHealth end ): map ( getName ) -- Run the chain on the current game players filterHurtNames ( game . Players ) -- { Frodo Baggins , Boromir } -- For fun, let s encapsulate the functionality above by -- defining a chain of operations on players... local players = dash . chain ({ filterHurtPlayers = dash . fn : filter ( function ( player ) return player . Health player . MaxHealth end ), -- Filter players by getting their name and checking it ends with Baggins filterBaggins = dash . fn : filter ( dash . fn : call ( getName ): endsWith ( Baggins )) }) local hurtHobbits = players : filterHurtPlayers (): filterBaggins () hurtHobbits ( game . Players ) -- {{Name = Frodo Baggins , ...}} local names = dash . fn : map ( getName ) -- Chains are themselves chainable, so you can compose two chains together local filterHurtHobbitNames = dash . compose ( hurtHobbits , names ) filterHurtHobbitNames ( game . Players ) -- { Frodo Baggins } Usage The \"Rodash\" chain: dash.chain(_) is aliased to dash.fn , so instead of writing dash.chain(_):filter you can simply write dash.fn:filter , or any other chainable method. A chained function can be made using dash.chain or built inductively using other chained methods of dash.fn . A chainable method is one that has the subject which is passed through a chain as the first argument, and subsequent arguments See dash.chainFn - Makes a function chainable if it returns a chain. dash.invoke - the identity actor dash.continue - an actor for chains of asynchronous functions dash.maybe - an actor for chains of partial functions chainFn function dash . chainFn ( fn ) -- (T, ...A) - R Wraps a function, making it chainable if it returns a chain itself. This allows you to define custom functions in terms of the arguments they will take when called in a chain, and return a chained function which performs the operation, rather than explicitly taking the subject as first argument. Type T, A, R ((...A - T - R) - T, ...A - R) Generics T - any - the primary type (extends any value) A - any - the primary arguments (extends any value) R - any - the result type (extends any value) Parameters fn - (...A) - (T) - R - a function (taking the primary arguments, and returning a function (taking the primary type, and returning the result type)) Returns (T, ...A) - R - a function (taking the primary type and the primary arguments, and returning the result type) Examples -- In the chain example addN was defined like so: local function addN ( list , n ) return dash . map ( list , function ( element ) return element + n end ) end numberChain = dash . chain ({ addN = addN }) local op = numberChain : addN ( 2 ): sum () op ({ 1 , 2 , 3 }) -- 12 -- It is more natural to define addN as a function taking one argument, -- to match the way it is called in the chain: local function addN ( n ) -- Methods on dash.fn are themselves chained, so list can be dropped. return dash . fn : map ( function ( element ) return element + n end ) end -- The dash.chainFn is used to wrap any functions which return chains. numberChain = dash . chain ({ addN = dash . chainFn ( addN ) }) local op = numberChain : addN ( 2 ): sum () op ({ 1 , 2 , 3 }) -- 12 See dash.chain Chainable compose function dash . compose (...) -- (...A) - A Returns a function that calls the argument functions in left-right order on an input, passing the return of the previous function as argument(s) to the next. Type A ((...A - ...A)[]) - ...A - A Generics A - any - the primary arguments (extends any value) Parameters ... - (...A) - ...A[] - an array (of functions (taking the primary arguments, and returning the primary arguments)) Returns (...A) - A - a function (taking the primary arguments, and returning the primary arguments) Examples local function fry ( item ) return fried .. item end local function cheesify ( item ) return cheesy .. item end local prepare = dash . compose ( fry , cheesify ) prepare ( nachos ) -- cheesy fried nachos Usage Useful for when you want to lazily compute something expensive that doesn't change. continue function dash . continue ( actor ) -- Actor S An Actor getter which awaits on any promises returned by chain methods, and continues execution when the promise completes. This allows any asynchronous methods to be used in chains without modifying any of the chain's synchronous methods, removing any boilerplate needed to handle promises in the main code body. Can wrap any other actor which handles values after any promise resolution. Type S (Actor S - Actor S ) Generics S - any - the subject type (extends any value) Parameters actor - Actor S - an Actor (of the subject type) - (default = dash.invoke ) The actor to wrap. Returns Actor S - an Actor (of the subject type) Rejects passthrough - The returned promise will reject if promises passed as arguments reject. Examples -- Let s define a function which returns an answer after a delay local getName = function ( player ) return dash . delay ( 1 ): andThen ( dash . returns ( player . Name )) end local players players = dash . chain ( { -- Any chainable function can be used filter = dash . filter , -- A chain which evaluates a promise of the player names mapNames = dash . fn : map ( getName ): parallel (), filterHurt = dash . fn : filter ( function ( player ) return player . Health 100 end ), mapNameIf = dash . chainFn ( function ( expectedName ) -- Methods on self work as expected return players : mapNames (): filter ( dash . fn : endsWith ( expectedName )) end ) }, dash . continue () ) local filterHurtHobbitNames = players : filterHurt (): mapNameIf ( Baggins ) local crew = { { Name = Frodo Baggins , Health = 50 }, { Name = Bilbo Baggins , Health = 100 }, { Name = Boromir , Health = 0 } } filterHurtHobbitNames ( crew ): await () -- { Frodo Baggins } (some time later) See dash.chain debounce function dash . debounce ( fn , delayInSeconds ) -- Clearable (...A) - R Creates a debounced function that delays calling fn until after delayInSeconds seconds have elapsed since the last time the debounced function was attempted to be called. Type A, R (...A - R), number - Clearable (...A - R) Generics A - any - the primary arguments (extends any value) R - any - the result type (extends any value) Parameters fn - (...A) - R - a function (taking the primary arguments, and returning the result type) delayInSeconds - number - a number Returns Clearable (...A) - R - an intersection (of a Clearable and a function (taking the primary arguments, and returning the result type)) - the debounced function with method :clear() can be called on to cancel any scheduled call. Usage A nice visualisation of debounce vs. throttle , the illustrated point being debounce will only call fn at the end of a spurt of events. Chainable id function dash . id (...) -- ...A A simple function that does nothing, but returns its input parameters. Type A (...A - ...A) Generics A - any - the primary arguments (extends any value) Parameters ... - ...A - the primary arguments Returns ...A - the primary arguments Usage This is typically referred to as the \"identity\" function. Useful for when a function is expecting a callback to transform a value but you don't want to make any change to it. invoke function dash . invoke ( fn , ...) -- S An Actor which calls the supplied fn with the argument tail. Type S, A ((A - S), ...A - S) Generics S - any - the subject type (extends any value) A - any - the primary arguments (extends any value) Parameters fn - (A) - S - a function (taking the primary arguments, and returning the subject type) ... - ...A - the primary arguments Returns S - the subject type Examples local getName = function ( player ) return player . Name end local Jimbo = { Name = Jimbo } dash . invoke ( getName , Jimbo ) -- Jimbo Usage This is the default actor for dash.chain and acts as an identity, meaning it has no effect on the result. isCallable function dash . isCallable ( value ) -- bool Return true if the value is a function or a table with a __call entry in its metatable. Type any - bool Parameters value - any - any value Returns bool - a boolean Usage This is a more general test than checking purely for a function type. maybe function dash . maybe ( actor ) -- Actor S An Actor which cancels execution of a chain if a method returns nil, evaluating the chain as nil. Can wrap any other actor which handles values that are non-nil. Type S (Actor S - Actor S ) Generics S - any - the subject type (extends any value) Parameters actor - Actor S - an Actor (of the subject type) Returns Actor S - an Actor (of the subject type) Examples -- We can define a chain of Rodash functions that will skip after a nil is returned. local maybeFn = dash . chain ( _ , dash . maybe ()) local getName = function ( player ) return player . Name end local players players = dash . chain ( { -- Any chainable functions can be used call = dash . call , endsWith = dash . endsWith , filterHurt = dash . fn : filter ( function ( player ) return player . Health 100 end ), filterBaggins = dash . chainFn ( function () -- If getName returns nil here, endsWith will be skipped return dash . fn : filter ( maybeFn : call ( getName ): endsWith ( Baggins )) end ) } ) local hurtHobbits = players : filterHurt (): filterBaggins () local mapNames = dash . fn : map ( getName ) local filterHurtBagginsNames = dash . compose ( hurtHobbits , mapNames ) -- Here, one player record doesn t have a Name property, so it is skipped. local crew = { { Name = Frodo Baggins , Health = 50 }, { Name = Bilbo Baggins , Health = 100 }, { Health = 0 } } memoize function dash . memoize ( fn , serializeArgs ) -- Clearable A AllClearable (...A) - R Like dash.once , but caches non-nil results of calls to fn keyed by some serialization of the input arguments to fn . By default, all the args are serialized simply using tostring . Optionally memoize takes function serializeArgs(args, cache) , a function that should return a string key which a result should be cached at for a given signature. Return nil to avoid caching the result. Type A, R ((...A - R), ...A - string?) - Clearable A AllClearable (...A - R) Generics A - any - the primary arguments (extends any value) R - any - the result type (extends any value) Parameters fn - ((...A) - R, ...A) - string? - a function (taking a function (taking the primary arguments, and returning the result type) and the primary arguments, and returning a string (optional)) serializeArgs - any - any value - (default = dash.serialize ) Returns Clearable A AllClearable (...A) - R - an intersection (of a Clearable (of the primary arguments), an AllClearable and a function (taking the primary arguments, and returning the result type)) - the function with method :clear(...) that resets the cache for the argument specified, or :clearAll() to clear the entire cache. Examples local menu = { soup , bread , butter } local heat = dash . memoize ( function ( index ) return hot ... menu [ index ] end ) heat ( 1 ) -- hot soup menu = { caviar } heat ( 1 ) -- hot soup heat ( 2 ) -- nil menu = { beef , potatoes } heat ( 1 ) -- hot soup heat ( 2 ) -- hot potatoes heat : clear ( 1 ) heat ( 1 ) -- hot beef See dash.once dash.serialize dash.serializeDeep if you want to recursively serialize arguments. noop function dash . noop () -- void A simple function that does nothing, and returns nil. Type () - () Returns void - nothing Usage Shorthand for function() end . Useful for when a function is expecting a callback but you don't want to do anything. Chainable once function dash . once ( fn ) -- Clearable (...A) - R Returns a function that when called, only calls fn the first time the function is called. For subsequent calls, the initial return of fn is returned, even if it is nil . Type A, R ((...A - R), R?) - Clearable (...A - R) Generics A - any - the primary arguments (extends any value) R - any - the result type (extends any value) Parameters fn - (...A) - R - a function (taking the primary arguments, and returning the result type) Returns Clearable (...A) - R - an intersection (of a Clearable and a function (taking the primary arguments, and returning the result type)) - the function with method :clear() that resets the cached value. Throws passthrough - any error thrown when called will cause nil to cache and pass through the error. Examples local fry = dash . once ( function ( item ) return fried .. item end ) fry ( sardine ) -- fried sardine fry ( squid ) -- fried sardine fry : clear () fry ( squid ) -- fried squid fry ( owl ) -- fried squid Usage Useful for when you want to lazily compute something expensive that doesn't change. Chainable returns function dash . returns (...) -- (void) - ...A Returns a function that when called, returns the original input parameters. Type A (...A - () - ...A) Generics A - any - the primary arguments (extends any value) Parameters ... - ...A - the primary arguments Returns (void) - ...A - a function (taking nothing, and returning the primary arguments) Examples findPlayer ( builderman ): andThen ( dash . returns ( Found Dave! )) -- Found Dave! (soon after) Usage Useful for when you want a callback to discard the arguments passed in and instead use static ones. setInterval function dash . setInterval ( fn , intervalInSeconds , delayInSeconds ) -- Clearable Like dash.setTimeout but calls fn after every interval of intervalInSeconds time has passed. The fn is called in a separate thread, meaning that it will not block the thread it is called in, and if the calling threads, the fn will still be called at the expected times. Type (Clearable - ()), number, number? - Clearable Parameters fn - (Clearable) - void - a function (taking a Clearable , and returning nothing) intervalInSeconds - number - a number delayInSeconds - number? - a number (optional) - (default = intervalInSeconds ) The delay before the initial call. Returns Clearable - a Clearable - an instance which :clear() can be called on to prevent fn from firing. Examples local waitInterval = dash . setInterval ( function () print ( Waiting for more players... ) end , 5 ) game . Players . PlayerAdded : Connect ( function ( player ) waitInterval : clear () end ) See dash.setTimeout setTimeout function dash . setTimeout ( fn , delayInSeconds ) -- Clearable Like delay , this calls fn after delayInSeconds time has passed, with the added benefit of being cancelable. The fn is called in a separate thread, meaning that it will not block the thread it is called in, and if the calling threads, the fn will still be called at the expected time. Type (Clearable - ()), number - Clearable Parameters fn - (Clearable) - void - a function (taking a Clearable , and returning nothing) delayInSeconds - number - a number Returns Clearable - a Clearable - an instance which :clear() can be called on to prevent fn from firing. Examples local waitTimeout = dash . setTimeout ( function () print ( Sorry, no players came online! ) end , 5 ) game . Players . PlayerAdded : Connect ( function ( player ) waitTimeout : clear () end ) See dash.delay throttle function dash . throttle ( fn , cooldownInSeconds ) -- (...A) - R Creates a throttle function that drops any repeat calls within a cooldown period and instead returns the result of the last call. Type A, R ((...A) - R), number - ...A - R Generics A - any - the primary arguments (extends any value) R - any - the result type (extends any value) Parameters fn - (...A) - R - a function (taking the primary arguments, and returning the result type) cooldownInSeconds - number - a number Returns (...A) - R - a function (taking the primary arguments, and returning the result type) Examples local post = dash . async ( HttpService . Post ) local saveMap = dash . throttle ( function ( data ) post ( https://example.com/save , data ) end , 10 ) saveMap ( map ) -- This saves the map saveMap ( map ) -- This function call is throttled and won t result in post being called saveMap ( map ) -- Same again wait ( 10 ) saveMap ( map ) -- Enough time has passed, so this saves the map again Usage A nice visualisation of debounce vs. throttle , the illustrated point being throttle will call fn every period during a spurt of events. See dash.async throws function dash . throws ( errorMessage ) -- (void) - fail Returns a function that when called, throws the original message. Type string - () - fail Parameters errorMessage - string - a string Returns (void) - fail - a function (taking nothing, and returning a failure state) Examples findPlayer ( builderman ): andThen ( dash . throws ( DaveNotFound )) --! DaveNotFound (soon after) Usage Useful for when you want a callback to discard any result and throw a message instead. unary function dash . unary ( fn ) -- (A) - R Returns a function that wraps the input fn but only passes the first argument to it. Type A, R ((A - R) - A - R) Generics A - any - the primary arguments (extends any value) R - any - the result type (extends any value) Parameters fn - (A) - R - a function (taking the primary arguments, and returning the result type) Returns (A) - R - a function (taking the primary arguments, and returning the result type) Examples local printOneArgument = dash . unary ( function (...) print (...) end ) printOneArgument ( Hello , World , ! ) -- Hello Members fn dash . fn -- Chain dash A Chain built from Rodash itself. Any Chainable Rodash function can be used as a method on this object, omitting the subject until the whole chain is evaluated by calling it with the subject. Examples local getNames = dash . fn : map ( function ( player ) return player . Name end ) getNames ( game . Players ) -- { Bilbo Baggins , Frodo Baggins , Peregrin Took } local getNames = dash . fn : map ( function ( player ) return player . Name end ): filter ( function ( name ) return dash . endsWith ( name , Baggins ) end ) getNames ( game . Players ) -- { Bilbo Baggins , Frodo Baggins } local getNames = dash . fn : map ( function ( player ) return player . Name end ): filter ( dash . fn : endsWith ( Baggins )) getNames ( game . Players ) -- { Bilbo Baggins , Frodo Baggins }","title":"Functions"},{"location":"api/Functions/#functions","text":"Utility functions and building blocks for functional programming styles.","title":"Functions"},{"location":"api/Functions/#functions_1","text":"","title":"Functions"},{"location":"api/Functions/#bind","text":"function dash . bind ( fn , ...) -- (...A2) - R Takes a function fn and binds arguments to the head of the fn argument list. Returns a function which executes fn , passing the bound arguments supplied, followed by any dynamic arguments. Type A, A2, R (((...A, ...A2 - R), ...A) - ...A2 - R) Generics A - any - the primary arguments (extends any value) A2 - any - the secondary arguments (extends any value) R - any - the result type (extends any value) Parameters fn - (...A, ...A2) - R - a function (taking the primary arguments and the secondary arguments, and returning the result type) ... - ...A - the primary arguments Returns (...A2) - R - a function (taking the secondary arguments, and returning the result type) Examples local function damagePlayer ( player , amount ) player : Damage ( amount ) end local damageLocalPlayer = dash . bind ( damagePlayer , game . Players . LocalPlayer ) damageLocalPlayer ( 5 )","title":"bind"},{"location":"api/Functions/#bindtail","text":"function dash . bindTail ( fn , ...) -- (S) - S Takes a chainable function fn and binds arguments to the tail of the fn argument list. Returns a function which executes fn , passing a subject ahead of the bound arguments supplied. Type S (Chainable S , ...) - S - S Generics S - any - the subject type (extends any value) Parameters fn - Chainable S - a Chainable (of the subject type) ... - ...any - any values Returns (S) - S - a function (taking the subject type, and returning the subject type) Examples local function setHealthTo ( player , health ) player . Health = health end local restoreHealth = dash . bindTail ( setHealthTo , 100 ) local Jimbo = { Health = 1 } restoreHealth local filterHurtPlayers = dash . bindTail ( dash . filter , function ( player ) return player . Health player . MaxHealth end ) local getName = dash . bindTail ( dash . map , function ( player ) return player . Name end ) local filterHurtNames = dash . compose ( filterHurtPlayers , getName ) filterHurtNames ( game . Players ) -- { Frodo , Boromir } Usage Chainable rodash function feeds are mapped to dash.fn , such as dash.fn.map(handler) . See dash.filter dash.compose Chainable","title":"bindTail"},{"location":"api/Functions/#call","text":"function dash . call ( subject , fn , ...) -- R Calls the supplied fn on the subject and any additional arguments, returning the result. Type S, A, R (S, (S, ...A - R), ...A - R) Generics S - any - the subject type (extends any value) A - any - the primary arguments (extends any value) R - any - the result type (extends any value) Parameters subject - S - the subject type fn - (S, ...A) - R - a function (taking the subject type and the primary arguments, and returning the result type) ... - ...A - the primary arguments Returns R - the result type Examples local function get ( object , key ) return object [ key ] end local Jimbo = { Name = Jimbo } dash . call ( Jimbo , get , Name ) -- Jimbo local function get ( object , key ) return object [ key ] end local isABaggins = dash . fn : call ( get , Name ): endsWith ( Baggins ) local Jimbo = { Name = Jimbo } isABaggins ( Jimbo ) -- false Usage This is useful when used in the dash.fn:call form to call arbitrary function inside a chain. See dash.chain Chainable","title":"call"},{"location":"api/Functions/#chain","text":"function dash . chain ( fns , actor ) -- Chain S Chain takes a dictionary of chainable functions and returns a Chain instance with methods mapped to the input functions. Chaining is useful when you want to simplify operating on data in a common form and perform sequences of operations on some data with a very concise syntax. An actor function can check the value of the data at each step and change how the chain proceeds. Calling a Chain with a subject reduces the chained operations in order on the subject. Type S (Chainable S {}, Actor S ) - Chain S Generics S - any - the subject type (extends any value) Parameters fns - Chainable S {} - a dictionary (of Chainables (of the subject type)) actor - Actor S - an Actor (of the subject type) - called for each result in the chain to determine how the next operation should process it. (default = dash.invoke ) Returns Chain S - a Chain (of the subject type) Examples -- Define a simple chain that can operate a list of numbers. -- A chain function is called with the subject being processed as first argument, -- and any arguments passed in the chain as subsequent arguments. local numberChain = dash . chain ({ addN = function ( list , n ) return dash . map ( list , function ( element ) return element + n end ) end , sum = function ( list ) return dash . sum ( list ) end }) local op = numberChain : addN ( 2 ): sum () op ({ 1 , 2 , 3 }) -- 12 -- Get the name of a player local function getName ( player ) return player . Name end ) -- Create a chain that filters for hurt players and finds their name local filterHurtNames = dash . fn : filter ( function ( player ) return player . Health player . MaxHealth end ): map ( getName ) -- Run the chain on the current game players filterHurtNames ( game . Players ) -- { Frodo Baggins , Boromir } -- For fun, let s encapsulate the functionality above by -- defining a chain of operations on players... local players = dash . chain ({ filterHurtPlayers = dash . fn : filter ( function ( player ) return player . Health player . MaxHealth end ), -- Filter players by getting their name and checking it ends with Baggins filterBaggins = dash . fn : filter ( dash . fn : call ( getName ): endsWith ( Baggins )) }) local hurtHobbits = players : filterHurtPlayers (): filterBaggins () hurtHobbits ( game . Players ) -- {{Name = Frodo Baggins , ...}} local names = dash . fn : map ( getName ) -- Chains are themselves chainable, so you can compose two chains together local filterHurtHobbitNames = dash . compose ( hurtHobbits , names ) filterHurtHobbitNames ( game . Players ) -- { Frodo Baggins } Usage The \"Rodash\" chain: dash.chain(_) is aliased to dash.fn , so instead of writing dash.chain(_):filter you can simply write dash.fn:filter , or any other chainable method. A chained function can be made using dash.chain or built inductively using other chained methods of dash.fn . A chainable method is one that has the subject which is passed through a chain as the first argument, and subsequent arguments See dash.chainFn - Makes a function chainable if it returns a chain. dash.invoke - the identity actor dash.continue - an actor for chains of asynchronous functions dash.maybe - an actor for chains of partial functions","title":"chain"},{"location":"api/Functions/#chainfn","text":"function dash . chainFn ( fn ) -- (T, ...A) - R Wraps a function, making it chainable if it returns a chain itself. This allows you to define custom functions in terms of the arguments they will take when called in a chain, and return a chained function which performs the operation, rather than explicitly taking the subject as first argument. Type T, A, R ((...A - T - R) - T, ...A - R) Generics T - any - the primary type (extends any value) A - any - the primary arguments (extends any value) R - any - the result type (extends any value) Parameters fn - (...A) - (T) - R - a function (taking the primary arguments, and returning a function (taking the primary type, and returning the result type)) Returns (T, ...A) - R - a function (taking the primary type and the primary arguments, and returning the result type) Examples -- In the chain example addN was defined like so: local function addN ( list , n ) return dash . map ( list , function ( element ) return element + n end ) end numberChain = dash . chain ({ addN = addN }) local op = numberChain : addN ( 2 ): sum () op ({ 1 , 2 , 3 }) -- 12 -- It is more natural to define addN as a function taking one argument, -- to match the way it is called in the chain: local function addN ( n ) -- Methods on dash.fn are themselves chained, so list can be dropped. return dash . fn : map ( function ( element ) return element + n end ) end -- The dash.chainFn is used to wrap any functions which return chains. numberChain = dash . chain ({ addN = dash . chainFn ( addN ) }) local op = numberChain : addN ( 2 ): sum () op ({ 1 , 2 , 3 }) -- 12 See dash.chain Chainable","title":"chainFn"},{"location":"api/Functions/#compose","text":"function dash . compose (...) -- (...A) - A Returns a function that calls the argument functions in left-right order on an input, passing the return of the previous function as argument(s) to the next. Type A ((...A - ...A)[]) - ...A - A Generics A - any - the primary arguments (extends any value) Parameters ... - (...A) - ...A[] - an array (of functions (taking the primary arguments, and returning the primary arguments)) Returns (...A) - A - a function (taking the primary arguments, and returning the primary arguments) Examples local function fry ( item ) return fried .. item end local function cheesify ( item ) return cheesy .. item end local prepare = dash . compose ( fry , cheesify ) prepare ( nachos ) -- cheesy fried nachos Usage Useful for when you want to lazily compute something expensive that doesn't change.","title":"compose"},{"location":"api/Functions/#continue","text":"function dash . continue ( actor ) -- Actor S An Actor getter which awaits on any promises returned by chain methods, and continues execution when the promise completes. This allows any asynchronous methods to be used in chains without modifying any of the chain's synchronous methods, removing any boilerplate needed to handle promises in the main code body. Can wrap any other actor which handles values after any promise resolution. Type S (Actor S - Actor S ) Generics S - any - the subject type (extends any value) Parameters actor - Actor S - an Actor (of the subject type) - (default = dash.invoke ) The actor to wrap. Returns Actor S - an Actor (of the subject type) Rejects passthrough - The returned promise will reject if promises passed as arguments reject. Examples -- Let s define a function which returns an answer after a delay local getName = function ( player ) return dash . delay ( 1 ): andThen ( dash . returns ( player . Name )) end local players players = dash . chain ( { -- Any chainable function can be used filter = dash . filter , -- A chain which evaluates a promise of the player names mapNames = dash . fn : map ( getName ): parallel (), filterHurt = dash . fn : filter ( function ( player ) return player . Health 100 end ), mapNameIf = dash . chainFn ( function ( expectedName ) -- Methods on self work as expected return players : mapNames (): filter ( dash . fn : endsWith ( expectedName )) end ) }, dash . continue () ) local filterHurtHobbitNames = players : filterHurt (): mapNameIf ( Baggins ) local crew = { { Name = Frodo Baggins , Health = 50 }, { Name = Bilbo Baggins , Health = 100 }, { Name = Boromir , Health = 0 } } filterHurtHobbitNames ( crew ): await () -- { Frodo Baggins } (some time later) See dash.chain","title":"continue"},{"location":"api/Functions/#debounce","text":"function dash . debounce ( fn , delayInSeconds ) -- Clearable (...A) - R Creates a debounced function that delays calling fn until after delayInSeconds seconds have elapsed since the last time the debounced function was attempted to be called. Type A, R (...A - R), number - Clearable (...A - R) Generics A - any - the primary arguments (extends any value) R - any - the result type (extends any value) Parameters fn - (...A) - R - a function (taking the primary arguments, and returning the result type) delayInSeconds - number - a number Returns Clearable (...A) - R - an intersection (of a Clearable and a function (taking the primary arguments, and returning the result type)) - the debounced function with method :clear() can be called on to cancel any scheduled call. Usage A nice visualisation of debounce vs. throttle , the illustrated point being debounce will only call fn at the end of a spurt of events. Chainable","title":"debounce"},{"location":"api/Functions/#id","text":"function dash . id (...) -- ...A A simple function that does nothing, but returns its input parameters. Type A (...A - ...A) Generics A - any - the primary arguments (extends any value) Parameters ... - ...A - the primary arguments Returns ...A - the primary arguments Usage This is typically referred to as the \"identity\" function. Useful for when a function is expecting a callback to transform a value but you don't want to make any change to it.","title":"id"},{"location":"api/Functions/#invoke","text":"function dash . invoke ( fn , ...) -- S An Actor which calls the supplied fn with the argument tail. Type S, A ((A - S), ...A - S) Generics S - any - the subject type (extends any value) A - any - the primary arguments (extends any value) Parameters fn - (A) - S - a function (taking the primary arguments, and returning the subject type) ... - ...A - the primary arguments Returns S - the subject type Examples local getName = function ( player ) return player . Name end local Jimbo = { Name = Jimbo } dash . invoke ( getName , Jimbo ) -- Jimbo Usage This is the default actor for dash.chain and acts as an identity, meaning it has no effect on the result.","title":"invoke"},{"location":"api/Functions/#iscallable","text":"function dash . isCallable ( value ) -- bool Return true if the value is a function or a table with a __call entry in its metatable. Type any - bool Parameters value - any - any value Returns bool - a boolean Usage This is a more general test than checking purely for a function type.","title":"isCallable"},{"location":"api/Functions/#maybe","text":"function dash . maybe ( actor ) -- Actor S An Actor which cancels execution of a chain if a method returns nil, evaluating the chain as nil. Can wrap any other actor which handles values that are non-nil. Type S (Actor S - Actor S ) Generics S - any - the subject type (extends any value) Parameters actor - Actor S - an Actor (of the subject type) Returns Actor S - an Actor (of the subject type) Examples -- We can define a chain of Rodash functions that will skip after a nil is returned. local maybeFn = dash . chain ( _ , dash . maybe ()) local getName = function ( player ) return player . Name end local players players = dash . chain ( { -- Any chainable functions can be used call = dash . call , endsWith = dash . endsWith , filterHurt = dash . fn : filter ( function ( player ) return player . Health 100 end ), filterBaggins = dash . chainFn ( function () -- If getName returns nil here, endsWith will be skipped return dash . fn : filter ( maybeFn : call ( getName ): endsWith ( Baggins )) end ) } ) local hurtHobbits = players : filterHurt (): filterBaggins () local mapNames = dash . fn : map ( getName ) local filterHurtBagginsNames = dash . compose ( hurtHobbits , mapNames ) -- Here, one player record doesn t have a Name property, so it is skipped. local crew = { { Name = Frodo Baggins , Health = 50 }, { Name = Bilbo Baggins , Health = 100 }, { Health = 0 } }","title":"maybe"},{"location":"api/Functions/#memoize","text":"function dash . memoize ( fn , serializeArgs ) -- Clearable A AllClearable (...A) - R Like dash.once , but caches non-nil results of calls to fn keyed by some serialization of the input arguments to fn . By default, all the args are serialized simply using tostring . Optionally memoize takes function serializeArgs(args, cache) , a function that should return a string key which a result should be cached at for a given signature. Return nil to avoid caching the result. Type A, R ((...A - R), ...A - string?) - Clearable A AllClearable (...A - R) Generics A - any - the primary arguments (extends any value) R - any - the result type (extends any value) Parameters fn - ((...A) - R, ...A) - string? - a function (taking a function (taking the primary arguments, and returning the result type) and the primary arguments, and returning a string (optional)) serializeArgs - any - any value - (default = dash.serialize ) Returns Clearable A AllClearable (...A) - R - an intersection (of a Clearable (of the primary arguments), an AllClearable and a function (taking the primary arguments, and returning the result type)) - the function with method :clear(...) that resets the cache for the argument specified, or :clearAll() to clear the entire cache. Examples local menu = { soup , bread , butter } local heat = dash . memoize ( function ( index ) return hot ... menu [ index ] end ) heat ( 1 ) -- hot soup menu = { caviar } heat ( 1 ) -- hot soup heat ( 2 ) -- nil menu = { beef , potatoes } heat ( 1 ) -- hot soup heat ( 2 ) -- hot potatoes heat : clear ( 1 ) heat ( 1 ) -- hot beef See dash.once dash.serialize dash.serializeDeep if you want to recursively serialize arguments.","title":"memoize"},{"location":"api/Functions/#noop","text":"function dash . noop () -- void A simple function that does nothing, and returns nil. Type () - () Returns void - nothing Usage Shorthand for function() end . Useful for when a function is expecting a callback but you don't want to do anything. Chainable","title":"noop"},{"location":"api/Functions/#once","text":"function dash . once ( fn ) -- Clearable (...A) - R Returns a function that when called, only calls fn the first time the function is called. For subsequent calls, the initial return of fn is returned, even if it is nil . Type A, R ((...A - R), R?) - Clearable (...A - R) Generics A - any - the primary arguments (extends any value) R - any - the result type (extends any value) Parameters fn - (...A) - R - a function (taking the primary arguments, and returning the result type) Returns Clearable (...A) - R - an intersection (of a Clearable and a function (taking the primary arguments, and returning the result type)) - the function with method :clear() that resets the cached value. Throws passthrough - any error thrown when called will cause nil to cache and pass through the error. Examples local fry = dash . once ( function ( item ) return fried .. item end ) fry ( sardine ) -- fried sardine fry ( squid ) -- fried sardine fry : clear () fry ( squid ) -- fried squid fry ( owl ) -- fried squid Usage Useful for when you want to lazily compute something expensive that doesn't change. Chainable","title":"once"},{"location":"api/Functions/#returns","text":"function dash . returns (...) -- (void) - ...A Returns a function that when called, returns the original input parameters. Type A (...A - () - ...A) Generics A - any - the primary arguments (extends any value) Parameters ... - ...A - the primary arguments Returns (void) - ...A - a function (taking nothing, and returning the primary arguments) Examples findPlayer ( builderman ): andThen ( dash . returns ( Found Dave! )) -- Found Dave! (soon after) Usage Useful for when you want a callback to discard the arguments passed in and instead use static ones.","title":"returns"},{"location":"api/Functions/#setinterval","text":"function dash . setInterval ( fn , intervalInSeconds , delayInSeconds ) -- Clearable Like dash.setTimeout but calls fn after every interval of intervalInSeconds time has passed. The fn is called in a separate thread, meaning that it will not block the thread it is called in, and if the calling threads, the fn will still be called at the expected times. Type (Clearable - ()), number, number? - Clearable Parameters fn - (Clearable) - void - a function (taking a Clearable , and returning nothing) intervalInSeconds - number - a number delayInSeconds - number? - a number (optional) - (default = intervalInSeconds ) The delay before the initial call. Returns Clearable - a Clearable - an instance which :clear() can be called on to prevent fn from firing. Examples local waitInterval = dash . setInterval ( function () print ( Waiting for more players... ) end , 5 ) game . Players . PlayerAdded : Connect ( function ( player ) waitInterval : clear () end ) See dash.setTimeout","title":"setInterval"},{"location":"api/Functions/#settimeout","text":"function dash . setTimeout ( fn , delayInSeconds ) -- Clearable Like delay , this calls fn after delayInSeconds time has passed, with the added benefit of being cancelable. The fn is called in a separate thread, meaning that it will not block the thread it is called in, and if the calling threads, the fn will still be called at the expected time. Type (Clearable - ()), number - Clearable Parameters fn - (Clearable) - void - a function (taking a Clearable , and returning nothing) delayInSeconds - number - a number Returns Clearable - a Clearable - an instance which :clear() can be called on to prevent fn from firing. Examples local waitTimeout = dash . setTimeout ( function () print ( Sorry, no players came online! ) end , 5 ) game . Players . PlayerAdded : Connect ( function ( player ) waitTimeout : clear () end ) See dash.delay","title":"setTimeout"},{"location":"api/Functions/#throttle","text":"function dash . throttle ( fn , cooldownInSeconds ) -- (...A) - R Creates a throttle function that drops any repeat calls within a cooldown period and instead returns the result of the last call. Type A, R ((...A) - R), number - ...A - R Generics A - any - the primary arguments (extends any value) R - any - the result type (extends any value) Parameters fn - (...A) - R - a function (taking the primary arguments, and returning the result type) cooldownInSeconds - number - a number Returns (...A) - R - a function (taking the primary arguments, and returning the result type) Examples local post = dash . async ( HttpService . Post ) local saveMap = dash . throttle ( function ( data ) post ( https://example.com/save , data ) end , 10 ) saveMap ( map ) -- This saves the map saveMap ( map ) -- This function call is throttled and won t result in post being called saveMap ( map ) -- Same again wait ( 10 ) saveMap ( map ) -- Enough time has passed, so this saves the map again Usage A nice visualisation of debounce vs. throttle , the illustrated point being throttle will call fn every period during a spurt of events. See dash.async","title":"throttle"},{"location":"api/Functions/#throws","text":"function dash . throws ( errorMessage ) -- (void) - fail Returns a function that when called, throws the original message. Type string - () - fail Parameters errorMessage - string - a string Returns (void) - fail - a function (taking nothing, and returning a failure state) Examples findPlayer ( builderman ): andThen ( dash . throws ( DaveNotFound )) --! DaveNotFound (soon after) Usage Useful for when you want a callback to discard any result and throw a message instead.","title":"throws"},{"location":"api/Functions/#unary","text":"function dash . unary ( fn ) -- (A) - R Returns a function that wraps the input fn but only passes the first argument to it. Type A, R ((A - R) - A - R) Generics A - any - the primary arguments (extends any value) R - any - the result type (extends any value) Parameters fn - (A) - R - a function (taking the primary arguments, and returning the result type) Returns (A) - R - a function (taking the primary arguments, and returning the result type) Examples local printOneArgument = dash . unary ( function (...) print (...) end ) printOneArgument ( Hello , World , ! ) -- Hello","title":"unary"},{"location":"api/Functions/#members","text":"","title":"Members"},{"location":"api/Functions/#fn","text":"dash . fn -- Chain dash A Chain built from Rodash itself. Any Chainable Rodash function can be used as a method on this object, omitting the subject until the whole chain is evaluated by calling it with the subject. Examples local getNames = dash . fn : map ( function ( player ) return player . Name end ) getNames ( game . Players ) -- { Bilbo Baggins , Frodo Baggins , Peregrin Took } local getNames = dash . fn : map ( function ( player ) return player . Name end ): filter ( function ( name ) return dash . endsWith ( name , Baggins ) end ) getNames ( game . Players ) -- { Bilbo Baggins , Frodo Baggins } local getNames = dash . fn : map ( function ( player ) return player . Name end ): filter ( dash . fn : endsWith ( Baggins )) getNames ( game . Players ) -- { Bilbo Baggins , Frodo Baggins }","title":"fn"},{"location":"api/Strings/","text":"Strings Useful functions to manipulate strings, based on similar implementations in other standard libraries. Functions Chainable camelCase function dash . camelCase ( str ) -- string Convert str to camel-case. Type string - string Parameters str - string - a string Returns string - a string Examples dash . camelCase ( Pepperoni Pizza ) -- pepperoniPizza dash . camelCase ( --pepperoni-pizza-- ) -- pepperoniPizza dash . camelCase ( __PEPPERONI_PIZZA ) -- pepperoniPizza Chainable capitalize function dash . capitalize ( str ) -- string Capitalize the first letter of str . Type string - string Parameters str - string - a string Returns string - a string Examples dash . capitalize ( hello mould ) -- Hello mould charToHex function dash . charToHex ( char , format , useBytes ) -- string Converts char into a hex representation Type char, string?, boolean? - string Parameters char - char - a char format - string? - a string (optional) - (optional) a string passed to dash.format which formats the hex value of each of the character's code points. useBytes - boolean? - a boolean (optional) - (default = false) whether to use the character's bytes, rather than UTF-8 code points. Returns string - a string Examples dash . charToHex ( ) -- 3C dash . charToHex ( , #{}; ) -- #3C; dash . charToHex ( \ud83d\ude0f ) -- 1F60F dash . charToHex ( \ud83d\ude0f , 0x{} ) -- 0x1F60F dash . charToHex ( \ud83e\udd37\ud83c\udffc\u200d\u2640\ufe0f , #x{}; ) -- #x1F937; #x1F3FC; #x200D; #x2640; #xFE0F; dash . charToHex ( \ud83e\udd37\ud83c\udffc\u200d\u2640\ufe0f , %{} , true ) -- %F0%9F%A4%B7%F0%9F%8F%BC%E2%80%8D%E2%99%80%EF%B8%8F debug function dash . debug ( format , ...) -- string This function first calls dash.format on the arguments provided and then outputs the response to the debug target, set using dash.setDebug . By default, this function does nothing, allowing developers to leave the calls in the source code if that is beneficial. Type string, ... - string Parameters format - string - a string - the format match string ... - ...any - any values Returns string - a string Examples -- During development: dash . setDebug () -- At any point in the code: dash . debug ( Hello {} , game . Players . LocalPlayer ) -- Hello builderman (for example) Usage A common pattern would be to dash.setDebug() to alias to print during local development, and send debug messages to an HTTP server on a production build to allow remote debugging. See dash.setDebug Chainable decodeHtml function dash . decodeHtml ( str ) -- string The inverse of dash.encodeHtml . Converts any HTML entities in str to their corresponding characters. Type string - string Parameters str - string - a string Returns string - a string Examples dash . decodeHtml ( lt;b gt; #34;Smashed quot; lt;/b gt; apos;Avocado #39; #x1F60F; ) -- [[ b Smashed /b Avocado \ud83d\ude0f]] Chainable decodeUrl function dash . decodeUrl ( str ) -- string The inverse of dash.encodeUrl . Use this to turn a URL which has been encoded for use in a HTTP request back into its original form. Type string - string Parameters str - string - a string Returns string - a string Examples dash . decodeUrl ( https://Egg+Fried%20Rice!? ) -- https://Egg+Fried Rice!? Usage This method is designed to act like decodeURI in JavaScript. Chainable decodeUrlComponent function dash . decodeUrlComponent ( str ) -- string The inverse of dash.encodeUrlComponent . Use this to turn a string which has been encoded for use as a component of a url back into its original form. Type string - string Parameters str - string - a string Returns string - a string Throws MalformedInput if str contains characters encoded incorrectly. Examples dash . decodeUrlComponent ( https%3A%2F%2FEgg%2BFried%20Rice!%3F ) -- https://Egg+Fried Rice!? Usage This method is designed to act like decodeURIComponent in JavaScript. Chainable encodeHtml function dash . encodeHtml ( str ) -- string Converts the characters \"' in str to their corresponding HTML entities. Type string - string Parameters str - string - a string Returns string - a string Examples dash . encodeHtml ( [[Pease Bacon Fish Chips ]] ) -- Peas lt; Bacon gt; quot;Fish quot; amp; apos;Chips apos; encodeQueryString function dash . encodeQueryString ( query ) -- string Takes a query dictionary of key-value pairs and builds a query string that can be concatenated to the end of a url. Type K,V (Iterable K,V - string) Generics K - any - the primary key type (extends any value) V - any - the primary value type (extends any value) Parameters query - Iterable K, V - an Iterable (of the primary key type and the primary value type) Returns string - a string Examples dash . encodeQueryString ({ time = 11 , biscuits = hob nobs , chocolatey = true })) -- ?biscuits=hob+nobs time=11 chocolatey=true Usage A query string which contains duplicate keys with different values is technically valid, but this function doesn't provide a way to produce them. Chainable encodeUrl function dash . encodeUrl ( str ) -- string Encodes str for use as a URL, for example when calling an HTTP endpoint. Note that, unlike this function, HttpService.EncodeUrl actually attempts to encode a string for purposes as a URL component rather than an entire URL, and as such will not produce a valid URL. Type string - string Parameters str - string - a string Returns string - a string Examples dash . encodeUrl ( https://example.com/Egg+Fried Rice!?\ud83e\udd37\ud83c\udffc\u200d\u2640\ufe0f ) -- https://example.com/Egg+Fried%20Rice!?%F0%9F%A4%B7%F0%9F%8F%BC%E2%80%8D%E2%99%80%EF%B8%8F Usage This method is designed to act like encodeURI in JavaScript. See dash.encodeUrlComponent Chainable encodeUrlComponent function dash . encodeUrlComponent ( str ) -- string Encodes str for use in a URL, for example as a query parameter of a call to an HTTP endpoint. Type string - string Parameters str - string - a string Returns string - a string Examples dash . encodeUrlComponent ( https://example.com/Egg+Fried Rice!?\ud83e\udd37\ud83c\udffc\u200d\u2640\ufe0f ) -- https%3A%2F%2Fexample.com%2FEgg%2BFried%20Rice!%3F%F0%9F%A4%B7%F0%9F%8F%BC%E2%80%8D%E2%99%80%EF%B8%8F Usage This method is designed to act like encodeURIComponent in JavaScript. This is very similar to HttpService.EncodeUrl , but is included for parity and conforms closer to the standard (e.g. EncodeUrl unnecessarily encodes ! ). Chainable endsWith function dash . endsWith ( str , suffix ) -- bool Checks if str ends with the string suffix . Type string, string - bool Parameters str - string - a string suffix - string - a string Returns bool - a boolean Examples dash . endsWith ( Fun Roblox Games , Games ) -- true dash . endsWith ( Bad Roblox Memes , Games ) -- false format function dash . format ( format , ...) -- string Returns the format string with placeholders {...} substituted with readable representations of the subsequent arguments. This function is a simpler more powerful version of dash.format , inspired by format! in Rust. {} formats and prints the next argument using :format() if available, or a suitable default representation depending on its type. {2} formats and prints the 2nd argument. {#2} prints the length of the 2nd argument. Display parameters can be combined after a : in the curly braces. Any format parameters used in dash.format can be used here, along with these extras: {:?} formats any value using dash.serializeDeep . {:#?} formats any value using dash.pretty . {:b} formats a number in its binary representation. Type string, ... - string Parameters format - string - a string ... - ...any - any values Returns string - a string Examples local props = { teeth , claws , whiskers , tail } dash . format ( {:?} is in {:#?} , whiskers , props ) - whiskers is in { teeth , claws , whiskers , tail } dash . format ( {} in binary is {1:b} , 125 ) - 125 in binary is 110100 dash . format ( The time is {:02}:{:02} , 2 , 4 ) - The time is 02:04 dash . format ( The color blue is #{:06X} , 255 ) - The color blue is #0000FF Usage Escape { with {{ and } similarly with }} . See https://developer.roblox.com/articles/Format-String for complete list of formating options and further use cases. See dash.serializeDeep dash.pretty formatValue function dash . formatValue ( value , displayString ) -- string Format a specific value using the specified displayString . Type any, DisplayString - string Parameters value - any - any value displayString - DisplayString - a DisplayString Returns string - a string Examples dash . formatValue ( 255 , :06X ) -- 0000FF See dash.format - for a full description of valid display strings. hexToChar function dash . hexToChar ( hex ) -- char Generates a character from its hex representation. Type str - char Parameters hex - str - a str Returns char - a char Throws MalformedInput if char is not a valid encoding. Examples dash . hexToChar ( 1F60F ) -- \ud83d\ude0f dash . hexToChar ( %1F60F ) -- \ud83d\ude0f dash . hexToChar ( #1F60F ) -- \ud83d\ude0f dash . hexToChar ( 0x1F60F ) -- \ud83d\ude0f Chainable kebabCase function dash . kebabCase ( str ) -- string Convert str to kebab-case, making all letters lowercase. Type string - string Parameters str - string - a string Returns string - a string Examples dash . kebabCase ( strongStilton ) -- strong-stilton dash . kebabCase ( Strong Stilton ) -- strong-stilton dash . kebabCase ( __STRONG_STILTON__ ) -- strong-stilton Usage Chain with :upper() if you need an upper kebab-case string. Chainable leftPad function dash . leftPad ( str , length , prefix ) -- string Makes a string of length from str by repeating characters from prefix at the start of the string. Type string, number, string - string Parameters str - string - a string length - number - a number prefix - string - a string - (default = \" \" ) Returns string - a string Examples dash . leftPad ( toast , 6 ) -- toast dash . leftPad ( 2 , 2 , 0 ) -- 02 dash . leftPad ( toast , 10 , :) ) -- :):):toast pretty function dash . pretty ( value , serializeOptions ) -- string Returns a human-readable string for the given value . The string will be formatted across multiple lines if a descendant element gets longer than 80 characters. Optionally a table of SerializeOptions can be passed which will pass to the underlying dash.serialize function so you can customise what is displayed. Type T (T, SerializeOptions T ? - string) Generics T - any - the primary type (extends any value) Parameters value - T - the primary type serializeOptions - SerializeOptions T ? - a SerializeOptions (of the primary type) (optional) Returns string - a string Examples local fox = { name = Mr. Fox , color = red } print ( dash . pretty ( fox )) -- {color = red , name = Mr. Fox } local fox = { name = Mr. Fox , color = red } print ( dash . pretty ( fox , { omitKeys = { name }})) -- {color = red } See dash.serializeDeep for a compact alternative. Chainable rightPad function dash . rightPad ( str , length , suffix ) -- string Makes a string of length from str by repeating characters from suffix at the end of the string. Type string, number, string - string Parameters str - string - a string length - number - a number suffix - string - a string - (default = \" \" ) Returns string - a string Examples dash . rightPad ( toast , 6 ) -- toast dash . rightPad ( 2 , 2 , ! ) -- 2! dash . rightPad ( toast , 10 , :) ) -- toast:):): setDebug function dash . setDebug ( fn ) -- void Hooks up any debug methods to invoke fn . By default, dash.debug does nothing. Type A (...A - ()) Generics A - any - the primary arguments (extends any value) Parameters fn - ...A - the primary arguments - (default = print ) Returns void - nothing Examples local postMessage = dash . async ( function ( message ) HttpService . PostAsync ( https://example.com/log , message ) end -- During production: dash . setDebug ( postMessage ) -- At any point in the code: dash . debug ( Hello is printed ) -- Hello is printed is posted to the server Usage Calling dash.setDebug() will simply print all calls to dash.debug with formatted arguments. See dash.debug dash.async Chainable snakeCase function dash . snakeCase ( str ) -- string Convert str to snake-case, making all letters uppercase. Type string - string Parameters str - string - a string Returns string - a string Examples dash . snakeCase ( sweetChickenCurry ) -- SWEET_CHICKEN_CURRY dash . snakeCase ( Sweet Chicken Curry ) -- SWEET_CHICKEN__CURRY dash . snakeCase ( --sweet-chicken--curry-- ) -- SWEET_CHICKEN__CURRY Usage Chain with :lower() if you need a lower snake-case string. Chainable splitOn function dash . splitOn ( str , pattern ) -- string[], string[] Splits str into parts based on a pattern delimiter and returns a table of the parts, followed by a table of the matched delimiters. Type string, pattern - string[], string[] Parameters str - string - a string pattern - pattern - a pattern Returns string[], string[] - a tuple (an array (of strings) and an array (of strings)) Examples dash . splitOn ( rice ) -- { r , i , c , e }, { , , , } dash . splitOn ( one.two::flour , [.:] ) -- { one , two , , flour }, { . , : , : } Usage This method is useful only when you need a pattern as a delimiter. Use the Roblox native string.split if you are splitting on a simple string. Chainable startsWith function dash . startsWith ( str , prefix ) -- bool Checks if str starts with the string start . Type string, string - bool Parameters str - string - a string prefix - string - a string Returns bool - a boolean Examples dash . startsWith ( Fun Roblox Games , Fun ) -- true dash . startsWith ( Chess , Fun ) -- false Chainable titleCase function dash . titleCase ( str ) -- string Convert str to title-case, where the first letter of each word is capitalized. Type string - string Parameters str - string - a string Returns string - a string Examples dash . titleCase ( jello world ) -- Jello World dash . titleCase ( yellow-jello with_sprinkles ) -- Yellow-jello With_sprinkles dash . titleCase ( yellow jello s don\u2019t mellow ) -- Yellow Jello s Dont\u2019t Mellow Usage Dashes, underscores and apostraphes don't break words. Chainable trim function dash . trim ( str ) -- string Removes any spaces from the start and end of str . Type string - string Parameters str - string - a string Returns string - a string Examples dash . trim ( roast veg ) -- roast veg","title":"Strings"},{"location":"api/Strings/#strings","text":"Useful functions to manipulate strings, based on similar implementations in other standard libraries.","title":"Strings"},{"location":"api/Strings/#functions","text":"Chainable","title":"Functions"},{"location":"api/Strings/#camelcase","text":"function dash . camelCase ( str ) -- string Convert str to camel-case. Type string - string Parameters str - string - a string Returns string - a string Examples dash . camelCase ( Pepperoni Pizza ) -- pepperoniPizza dash . camelCase ( --pepperoni-pizza-- ) -- pepperoniPizza dash . camelCase ( __PEPPERONI_PIZZA ) -- pepperoniPizza Chainable","title":"camelCase"},{"location":"api/Strings/#capitalize","text":"function dash . capitalize ( str ) -- string Capitalize the first letter of str . Type string - string Parameters str - string - a string Returns string - a string Examples dash . capitalize ( hello mould ) -- Hello mould","title":"capitalize"},{"location":"api/Strings/#chartohex","text":"function dash . charToHex ( char , format , useBytes ) -- string Converts char into a hex representation Type char, string?, boolean? - string Parameters char - char - a char format - string? - a string (optional) - (optional) a string passed to dash.format which formats the hex value of each of the character's code points. useBytes - boolean? - a boolean (optional) - (default = false) whether to use the character's bytes, rather than UTF-8 code points. Returns string - a string Examples dash . charToHex ( ) -- 3C dash . charToHex ( , #{}; ) -- #3C; dash . charToHex ( \ud83d\ude0f ) -- 1F60F dash . charToHex ( \ud83d\ude0f , 0x{} ) -- 0x1F60F dash . charToHex ( \ud83e\udd37\ud83c\udffc\u200d\u2640\ufe0f , #x{}; ) -- #x1F937; #x1F3FC; #x200D; #x2640; #xFE0F; dash . charToHex ( \ud83e\udd37\ud83c\udffc\u200d\u2640\ufe0f , %{} , true ) -- %F0%9F%A4%B7%F0%9F%8F%BC%E2%80%8D%E2%99%80%EF%B8%8F","title":"charToHex"},{"location":"api/Strings/#debug","text":"function dash . debug ( format , ...) -- string This function first calls dash.format on the arguments provided and then outputs the response to the debug target, set using dash.setDebug . By default, this function does nothing, allowing developers to leave the calls in the source code if that is beneficial. Type string, ... - string Parameters format - string - a string - the format match string ... - ...any - any values Returns string - a string Examples -- During development: dash . setDebug () -- At any point in the code: dash . debug ( Hello {} , game . Players . LocalPlayer ) -- Hello builderman (for example) Usage A common pattern would be to dash.setDebug() to alias to print during local development, and send debug messages to an HTTP server on a production build to allow remote debugging. See dash.setDebug Chainable","title":"debug"},{"location":"api/Strings/#decodehtml","text":"function dash . decodeHtml ( str ) -- string The inverse of dash.encodeHtml . Converts any HTML entities in str to their corresponding characters. Type string - string Parameters str - string - a string Returns string - a string Examples dash . decodeHtml ( lt;b gt; #34;Smashed quot; lt;/b gt; apos;Avocado #39; #x1F60F; ) -- [[ b Smashed /b Avocado \ud83d\ude0f]] Chainable","title":"decodeHtml"},{"location":"api/Strings/#decodeurl","text":"function dash . decodeUrl ( str ) -- string The inverse of dash.encodeUrl . Use this to turn a URL which has been encoded for use in a HTTP request back into its original form. Type string - string Parameters str - string - a string Returns string - a string Examples dash . decodeUrl ( https://Egg+Fried%20Rice!? ) -- https://Egg+Fried Rice!? Usage This method is designed to act like decodeURI in JavaScript. Chainable","title":"decodeUrl"},{"location":"api/Strings/#decodeurlcomponent","text":"function dash . decodeUrlComponent ( str ) -- string The inverse of dash.encodeUrlComponent . Use this to turn a string which has been encoded for use as a component of a url back into its original form. Type string - string Parameters str - string - a string Returns string - a string Throws MalformedInput if str contains characters encoded incorrectly. Examples dash . decodeUrlComponent ( https%3A%2F%2FEgg%2BFried%20Rice!%3F ) -- https://Egg+Fried Rice!? Usage This method is designed to act like decodeURIComponent in JavaScript. Chainable","title":"decodeUrlComponent"},{"location":"api/Strings/#encodehtml","text":"function dash . encodeHtml ( str ) -- string Converts the characters \"' in str to their corresponding HTML entities. Type string - string Parameters str - string - a string Returns string - a string Examples dash . encodeHtml ( [[Pease Bacon Fish Chips ]] ) -- Peas lt; Bacon gt; quot;Fish quot; amp; apos;Chips apos;","title":"encodeHtml"},{"location":"api/Strings/#encodequerystring","text":"function dash . encodeQueryString ( query ) -- string Takes a query dictionary of key-value pairs and builds a query string that can be concatenated to the end of a url. Type K,V (Iterable K,V - string) Generics K - any - the primary key type (extends any value) V - any - the primary value type (extends any value) Parameters query - Iterable K, V - an Iterable (of the primary key type and the primary value type) Returns string - a string Examples dash . encodeQueryString ({ time = 11 , biscuits = hob nobs , chocolatey = true })) -- ?biscuits=hob+nobs time=11 chocolatey=true Usage A query string which contains duplicate keys with different values is technically valid, but this function doesn't provide a way to produce them. Chainable","title":"encodeQueryString"},{"location":"api/Strings/#encodeurl","text":"function dash . encodeUrl ( str ) -- string Encodes str for use as a URL, for example when calling an HTTP endpoint. Note that, unlike this function, HttpService.EncodeUrl actually attempts to encode a string for purposes as a URL component rather than an entire URL, and as such will not produce a valid URL. Type string - string Parameters str - string - a string Returns string - a string Examples dash . encodeUrl ( https://example.com/Egg+Fried Rice!?\ud83e\udd37\ud83c\udffc\u200d\u2640\ufe0f ) -- https://example.com/Egg+Fried%20Rice!?%F0%9F%A4%B7%F0%9F%8F%BC%E2%80%8D%E2%99%80%EF%B8%8F Usage This method is designed to act like encodeURI in JavaScript. See dash.encodeUrlComponent Chainable","title":"encodeUrl"},{"location":"api/Strings/#encodeurlcomponent","text":"function dash . encodeUrlComponent ( str ) -- string Encodes str for use in a URL, for example as a query parameter of a call to an HTTP endpoint. Type string - string Parameters str - string - a string Returns string - a string Examples dash . encodeUrlComponent ( https://example.com/Egg+Fried Rice!?\ud83e\udd37\ud83c\udffc\u200d\u2640\ufe0f ) -- https%3A%2F%2Fexample.com%2FEgg%2BFried%20Rice!%3F%F0%9F%A4%B7%F0%9F%8F%BC%E2%80%8D%E2%99%80%EF%B8%8F Usage This method is designed to act like encodeURIComponent in JavaScript. This is very similar to HttpService.EncodeUrl , but is included for parity and conforms closer to the standard (e.g. EncodeUrl unnecessarily encodes ! ). Chainable","title":"encodeUrlComponent"},{"location":"api/Strings/#endswith","text":"function dash . endsWith ( str , suffix ) -- bool Checks if str ends with the string suffix . Type string, string - bool Parameters str - string - a string suffix - string - a string Returns bool - a boolean Examples dash . endsWith ( Fun Roblox Games , Games ) -- true dash . endsWith ( Bad Roblox Memes , Games ) -- false","title":"endsWith"},{"location":"api/Strings/#format","text":"function dash . format ( format , ...) -- string Returns the format string with placeholders {...} substituted with readable representations of the subsequent arguments. This function is a simpler more powerful version of dash.format , inspired by format! in Rust. {} formats and prints the next argument using :format() if available, or a suitable default representation depending on its type. {2} formats and prints the 2nd argument. {#2} prints the length of the 2nd argument. Display parameters can be combined after a : in the curly braces. Any format parameters used in dash.format can be used here, along with these extras: {:?} formats any value using dash.serializeDeep . {:#?} formats any value using dash.pretty . {:b} formats a number in its binary representation. Type string, ... - string Parameters format - string - a string ... - ...any - any values Returns string - a string Examples local props = { teeth , claws , whiskers , tail } dash . format ( {:?} is in {:#?} , whiskers , props ) - whiskers is in { teeth , claws , whiskers , tail } dash . format ( {} in binary is {1:b} , 125 ) - 125 in binary is 110100 dash . format ( The time is {:02}:{:02} , 2 , 4 ) - The time is 02:04 dash . format ( The color blue is #{:06X} , 255 ) - The color blue is #0000FF Usage Escape { with {{ and } similarly with }} . See https://developer.roblox.com/articles/Format-String for complete list of formating options and further use cases. See dash.serializeDeep dash.pretty","title":"format"},{"location":"api/Strings/#formatvalue","text":"function dash . formatValue ( value , displayString ) -- string Format a specific value using the specified displayString . Type any, DisplayString - string Parameters value - any - any value displayString - DisplayString - a DisplayString Returns string - a string Examples dash . formatValue ( 255 , :06X ) -- 0000FF See dash.format - for a full description of valid display strings.","title":"formatValue"},{"location":"api/Strings/#hextochar","text":"function dash . hexToChar ( hex ) -- char Generates a character from its hex representation. Type str - char Parameters hex - str - a str Returns char - a char Throws MalformedInput if char is not a valid encoding. Examples dash . hexToChar ( 1F60F ) -- \ud83d\ude0f dash . hexToChar ( %1F60F ) -- \ud83d\ude0f dash . hexToChar ( #1F60F ) -- \ud83d\ude0f dash . hexToChar ( 0x1F60F ) -- \ud83d\ude0f Chainable","title":"hexToChar"},{"location":"api/Strings/#kebabcase","text":"function dash . kebabCase ( str ) -- string Convert str to kebab-case, making all letters lowercase. Type string - string Parameters str - string - a string Returns string - a string Examples dash . kebabCase ( strongStilton ) -- strong-stilton dash . kebabCase ( Strong Stilton ) -- strong-stilton dash . kebabCase ( __STRONG_STILTON__ ) -- strong-stilton Usage Chain with :upper() if you need an upper kebab-case string. Chainable","title":"kebabCase"},{"location":"api/Strings/#leftpad","text":"function dash . leftPad ( str , length , prefix ) -- string Makes a string of length from str by repeating characters from prefix at the start of the string. Type string, number, string - string Parameters str - string - a string length - number - a number prefix - string - a string - (default = \" \" ) Returns string - a string Examples dash . leftPad ( toast , 6 ) -- toast dash . leftPad ( 2 , 2 , 0 ) -- 02 dash . leftPad ( toast , 10 , :) ) -- :):):toast","title":"leftPad"},{"location":"api/Strings/#pretty","text":"function dash . pretty ( value , serializeOptions ) -- string Returns a human-readable string for the given value . The string will be formatted across multiple lines if a descendant element gets longer than 80 characters. Optionally a table of SerializeOptions can be passed which will pass to the underlying dash.serialize function so you can customise what is displayed. Type T (T, SerializeOptions T ? - string) Generics T - any - the primary type (extends any value) Parameters value - T - the primary type serializeOptions - SerializeOptions T ? - a SerializeOptions (of the primary type) (optional) Returns string - a string Examples local fox = { name = Mr. Fox , color = red } print ( dash . pretty ( fox )) -- {color = red , name = Mr. Fox } local fox = { name = Mr. Fox , color = red } print ( dash . pretty ( fox , { omitKeys = { name }})) -- {color = red } See dash.serializeDeep for a compact alternative. Chainable","title":"pretty"},{"location":"api/Strings/#rightpad","text":"function dash . rightPad ( str , length , suffix ) -- string Makes a string of length from str by repeating characters from suffix at the end of the string. Type string, number, string - string Parameters str - string - a string length - number - a number suffix - string - a string - (default = \" \" ) Returns string - a string Examples dash . rightPad ( toast , 6 ) -- toast dash . rightPad ( 2 , 2 , ! ) -- 2! dash . rightPad ( toast , 10 , :) ) -- toast:):):","title":"rightPad"},{"location":"api/Strings/#setdebug","text":"function dash . setDebug ( fn ) -- void Hooks up any debug methods to invoke fn . By default, dash.debug does nothing. Type A (...A - ()) Generics A - any - the primary arguments (extends any value) Parameters fn - ...A - the primary arguments - (default = print ) Returns void - nothing Examples local postMessage = dash . async ( function ( message ) HttpService . PostAsync ( https://example.com/log , message ) end -- During production: dash . setDebug ( postMessage ) -- At any point in the code: dash . debug ( Hello is printed ) -- Hello is printed is posted to the server Usage Calling dash.setDebug() will simply print all calls to dash.debug with formatted arguments. See dash.debug dash.async Chainable","title":"setDebug"},{"location":"api/Strings/#snakecase","text":"function dash . snakeCase ( str ) -- string Convert str to snake-case, making all letters uppercase. Type string - string Parameters str - string - a string Returns string - a string Examples dash . snakeCase ( sweetChickenCurry ) -- SWEET_CHICKEN_CURRY dash . snakeCase ( Sweet Chicken Curry ) -- SWEET_CHICKEN__CURRY dash . snakeCase ( --sweet-chicken--curry-- ) -- SWEET_CHICKEN__CURRY Usage Chain with :lower() if you need a lower snake-case string. Chainable","title":"snakeCase"},{"location":"api/Strings/#spliton","text":"function dash . splitOn ( str , pattern ) -- string[], string[] Splits str into parts based on a pattern delimiter and returns a table of the parts, followed by a table of the matched delimiters. Type string, pattern - string[], string[] Parameters str - string - a string pattern - pattern - a pattern Returns string[], string[] - a tuple (an array (of strings) and an array (of strings)) Examples dash . splitOn ( rice ) -- { r , i , c , e }, { , , , } dash . splitOn ( one.two::flour , [.:] ) -- { one , two , , flour }, { . , : , : } Usage This method is useful only when you need a pattern as a delimiter. Use the Roblox native string.split if you are splitting on a simple string. Chainable","title":"splitOn"},{"location":"api/Strings/#startswith","text":"function dash . startsWith ( str , prefix ) -- bool Checks if str starts with the string start . Type string, string - bool Parameters str - string - a string prefix - string - a string Returns bool - a boolean Examples dash . startsWith ( Fun Roblox Games , Fun ) -- true dash . startsWith ( Chess , Fun ) -- false Chainable","title":"startsWith"},{"location":"api/Strings/#titlecase","text":"function dash . titleCase ( str ) -- string Convert str to title-case, where the first letter of each word is capitalized. Type string - string Parameters str - string - a string Returns string - a string Examples dash . titleCase ( jello world ) -- Jello World dash . titleCase ( yellow-jello with_sprinkles ) -- Yellow-jello With_sprinkles dash . titleCase ( yellow jello s don\u2019t mellow ) -- Yellow Jello s Dont\u2019t Mellow Usage Dashes, underscores and apostraphes don't break words. Chainable","title":"titleCase"},{"location":"api/Strings/#trim","text":"function dash . trim ( str ) -- string Removes any spaces from the start and end of str . Type string - string Parameters str - string - a string Returns string - a string Examples dash . trim ( roast veg ) -- roast veg","title":"trim"},{"location":"api/Tables/","text":"Tables A collection of functions that operate on Lua tables. These can operate on arrays, dictionaries and any collection types implemented with tables. These functions can iterate over any Iterable values. These functions typically act on immutable tables and return new tables in functional style. Note that mutable arguments in Rodash are explicitly typed as such with the mut keyword. Functions all function dash . all ( source , handler ) -- bool Return true if handler returns true for every element in source it is called with. If no handler is provided, dash.all returns true if every element is non-nil. Type T: Iterable K,V (T, (value: V, key: K - bool)?) - bool Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type handler - (value: V, key: K) - bool? - a function (taking value (the primary value type) and key (the primary key type), and returning a boolean) (optional) - (default = dash.id ) Returns bool - a boolean Examples local names = { [ 3 ] = Boromir , [ 1 ] = Frodo , [ 8 ] = Bilbo } local allNamesStartWithB = dash . all ( names , function ( name ) return dash . startsWith ( name , B ) end ) allNamesStartWithB -- false any function dash . any ( source , handler ) -- bool Return true if handler returns true for at least one element in source it is called with. If no handler is provided, dash.any returns true if some element is non-nil. Type T: Iterable K,V (T - bool) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type handler - any - any value - (default = dash.id ) Returns bool - a boolean Examples local names = { [ 3 ] = Boromir , [ 1 ] = Frodo , [ 8 ] = Bilbo } local anyNameStartsWithB = dash . any ( names , function ( name ) return dash . startsWith ( name , B ) end ) anyNameStartsWithB -- true assign function dash . assign ( target , ...) -- T Adds new elements in target from subsequent table arguments in order, with elements in later tables replacing earlier ones if their keys match. Type T: Iterable K,V (mut T, ...T) - T Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters target - mut T - the primary type (which can be mutated) ... - ...T - the primary type - any number of other tables Returns T - the primary type Examples local someInfo = { Frodo = { name = Frodo Baggins , team = blue }, Boromir = { score = 5 } } local someOtherInfo = { Frodo = { team = red , score = 10 }, Bilbo = { team = yellow , }, Boromir = { score = { 1 , 2 , 3 } } } local assignedInfo = dash . assign ( someInfo , someOtherInfo ) --[[ -- { Frodo = { team = red , score = 10 }, Bilbo = { team = yellow }, Boromir = { score = {1, 2, 3} } } ]] See dash.defaults dash.merge clone function dash . clone ( source ) -- T Returns a shallow copy of source . Type T: Iterable K,V (T - T) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type Returns T - the primary type Examples local Hermione = { name = Hermione Granger , time = 12 } local PastHermione = dash . clone ( Hermione ) PastHermione . time = 9 Hermione . time -- 12 See dash.cloneDeep - if you also want to clone descendants of the table, though this can be costly. dash.map - if you want to return different values for each key. dash.Cloneable - use this to derive a default :clone() method for class instances. cloneDeep function dash . cloneDeep ( source ) -- T Recursively clones descendants of source , returning the cloned object. If references to the same table are found, the same clone is used in the result. This means that dash.cloneDeep is cycle-safe. Elements which are not tables are not modified. Type T: Iterable K,V (T - T) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type Returns T - the primary type Examples local Harry = { patronus = stag , age = 12 } local Hedwig = { animal = owl , owner = Harry } Harry . pet = Hedwig local clonedHarry = dash . cloneDeep ( Harry ) Harry . age = 13 -- The object clonedHarry is completely independent of any changes to Harry: dash . pretty ( clonedHarry ) -- 1 {age = 12, patronus = stag , pet = {animal = owl , owner = 1}} See dash.clone - if you simply want to perform a shallow clone. compact function dash . compact ( source ) -- V[] Returns an array of elements from a sparse array source with the returned elements provided in original key-order. Type T: Iterable K,V (T - V[]) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type Returns V[] - an array (of the primary value type) Examples local names = { [ 3 ] = Boromir , [ 1 ] = Frodo , [ 8 ] = Bilbo } local inOrderNames = dash . compact ( names ) inOrderNames -- { Frodo , Boromir , Bilbo } deepEqual function dash . deepEqual ( a , b ) -- bool Returns true if every element in a recursively matches every element b . For elements which are not tables, they match if they are equal. If they are tables they match if the left is recursively deeply-equal to the right. Type any, any - bool Parameters a - any - any value b - any - any value Returns bool - a boolean Examples local car = { speed = 10 , wheels = 4 , lightsOn = { indicators = true , headlights = false } } local car2 = { speed = 10 , wheels = 4 , lightsOn = { indicators = false , headlights = false } } dash . deepEqual ( car , {}) -- false dash . deepEqual ( car , car ) -- true dash . deepEqual ( car , dash . clone ( car )) -- true dash . deepEqual ( car , dash . cloneDeep ( car )) -- true dash . deepEqual ( car , car2 ) -- false See dash.isSubset dash.shallowEqual defaults function dash . defaults ( target , ...) -- T Adds new elements in target from subsequent table arguments in order, with elements in earlier tables overriding later ones if their keys match. Type T: Iterable K,V (mut T, ...T) - T Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters target - mut T - the primary type (which can be mutated) ... - ...T - the primary type - any number of other tables Returns T - the primary type Examples local someInfo = { Frodo = { name = Frodo Baggins , team = blue }, Boromir = { score = 5 } } local someOtherInfo = { Frodo = { team = red , score = 10 }, Bilbo = { team = yellow , }, Boromir = { score = { 1 , 2 , 3 } } } local assignedInfo = dash . assign ( someInfo , someOtherInfo ) --[[ -- { Frodo = { name = Frodo Baggins , team = blue }, Boromir = { score = 5 } Bilbo = { team = yellow } } ]] See dash.assign dash.merge defaultSerializer function dash . defaultSerializer ( input ) -- string A function which provides a simple, shallow string representation of a value. Type any - string Parameters input - any - any value Returns string - a string Examples dash . defaultSerializer () -- nil dash . defaultSerializer ( true ) -- true dash . defaultSerializer ( 5.8 ) -- 5.8 dash . defaultSerializer ( Hello .. \\ n .. there ) -- Hello \\n there entries function dash . entries ( source ) -- {K, V}[] Returns an array of all the entries of elements in source . Each entry is a tuple (key, value) . Type T: Iterable K,V (T - {K, V}[]) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type Returns {K, V}[] - an array (of arrays (of tuples (the primary key type and the primary value type))) Examples dash . values ({ Frodo = 1 , Boromir = 2 , Bilbo = 3 }) -- {{ Frodo , 1}, { Boromir , 2}, { Bilbo , 3}} (in some order) filter function dash . filter ( source , handler ) -- V[] Returns an array of any values in source that the handler function returned true for, in order of iteration. Type T: Iterable K,V (T, (element: V, key: K - bool) - V[]) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type handler - (element: V, key: K) - bool - a function (taking element (the primary value type) and key (the primary key type), and returning a boolean) Returns V[] - an array (of the primary value type) Examples local myTools = game . Players . LocalPlayer . Backpack : GetChildren () local mySpoons = dash . filter ( myTools , function ( tool ) return dash . endsWith ( tool . Name , Spoon ) end ) mySpoons -- {SilverSpoon, TableSpoon} See dash.map if you would like to remove elements but preserve table keys find function dash . find ( source , handler ) -- V? Picks a value from the table that handler returns true for. If multiple elements might return true, any one of them may be returned as the iteration order over a table is stochastic. Type T: Iterable K,V ((T, (element: V, key: K) - bool) - V?) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - (T, element: V, key: K) - bool - a function (taking the primary type and a tuple ( element (the primary value type) and key (the primary key type)), and returning a boolean) handler - any - any value Returns V? - the primary value type (optional) Examples local names = { [ 3 ] = Boromir , [ 1 ] = Frodo , [ 8 ] = Bilbo } local nameWithB = dash . find ( names , function ( name ) return dash . startsWith ( name , B ) end ) nameWithB -- Bilbo , 8 (or Boromir , 3) -- Or use a chain: local nameWithF = dash . find ( names , dash . fn : startsWith ( name , B )) nameWithF -- Frodo , 1 -- Or find the key of a specific value: local _ , key = dash . find ( names , dash . fn : matches ( Bilbo )) key -- 8 Usage If you need to find the first value of an array that matches, use dash.first . See dash.first flatMap function dash . flatMap ( source , handler ) -- V2[] Like dash.mapValues this function iterates through source and returns an array of values, using handler to transform them. However, handler must return an array of results, these elements being insterted into the resulting array. You can return an empty array {} from handler to avoid inserting anything for a particular element. Type T: Iterable K,V , V2 ((T, (element: V, key: K) - V2[]) - V2[]) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) V2 - any - the secondary value type (extends any value) Parameters source - (T, element: V, key: K) - V2[] - a function (taking the primary type and a tuple ( element (the primary value type) and key (the primary key type)), and returning an array (of the secondary value type)) handler - any - any value Returns V2[] - an array (of the secondary value type) Examples local tools = dash . flatMap ( game . Players : GetChildren (), function ( player ) return player . Backpack : GetChildren () end ) tools -- {Spoon, Ring, Sting, Book} Chainable get function dash . get ( source , ...) -- V? Get a child or descendant of a table, returning nil if any errors are generated. Type K, V, T: {[K]: V} (T, ...K) - V? Generics K - any - the primary key type (extends any value) V - any - the primary value type (extends any value) T - {[K]: V} - the primary type (extends a dictionary mapping the primary key type to the primary value type) Parameters source - T - the primary type ... - ...K - the primary key type - Further keys to address any descendent. Returns V? - the primary value type (optional) Examples local upperTorso = dash . get ( game . Players , LocalPlayer , Character , UpperTorso ) upperTorso -- Part (if player s character and its UpperTorso are defined) -- You can also bind a lookup to get later on: local getUpperTorso = dash . bindTail ( dash . get , Character , UpperTorso ) getUpperTorso ( players . LocalPlayer ) -- Part groupBy function dash . groupBy ( source , handler ) -- Iterable K2, Iterable K, V This function iterates over source , calling handler to obtain a key for each element. Elements from source are then appended to an array of elements based on their key, so that this function returns a dictionary of arrays of the elements grouped by their keys. If the handler returns nil, the element is dropped from the result. Type T: Iterable K,V , K2 (((value: T, key: K) - K2) - Iterable K2, Iterable K,V ) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) K2 - any - the secondary key type (extends any value) Parameters source - (value: T, key: K) - K2 - a function (taking value (the primary type) and key (the primary key type), and returning the secondary key type) handler - any - any value Returns Iterable K2, Iterable K, V - an Iterable (of the secondary key type and Iterable (of the primary key type and the primary value type)) Examples local playerSet = { Frodo = Frodo , Bilbo = Bilbo , Boromir = Boromir } local healthSet = dash . keyBy ( playerSet , function ( name ) return dash . get ( game . Players , name , Character , Humanoid , Health ) end ) healthSet -- {100 = {}, 50 = { Bilbo , Frodo }, 0 = { Boromir }} See dash.keyBy - if you only want one element to be preserved at each key dash.get includes function dash . includes ( source , item ) -- bool Returns true if item exists as a value in the source table. Type T: Iterable K,V (T, V - bool) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type item - V - the primary value type Returns bool - a boolean Examples local names = { [ 3 ] = Boromir , [ 1 ] = Frodo , [ 8 ] = Bilbo } dash . includes ( names , Boromir ) -- true dash . includes ( names , 1 ) -- false invert function dash . invert ( source ) -- Iterable V, K Returns a table with elements from source with their keys and values flipped. Type K, V (Iterable K,V - Iterable V,K ) Generics K - any - the primary key type (extends any value) V - any - the primary value type (extends any value) Parameters source - Iterable K, V - an Iterable (of the primary key type and the primary value type) Returns Iterable V, K - an Iterable (of the primary value type and the primary key type) Examples local teams = { red = Frodo , blue = Bilbo , yellow = Boromir } local players = dash . invert ( teams ) players -- {Frodo = red , Bilbo = blue , Boromir = yellow } isArray function dash . isArray ( source ) -- bool Returns true is source is made up only of natural keys 1..n . Type T: Iterable K,V (T - bool) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type Returns bool - a boolean Examples dash . isArray ({ 1 , 2 , 3 }) -- true dash . isArray ({ a = 1 , b = 2 , c = 3 }) -- false -- Treating sparse arrays as natural arrays will only complicate things: dash . isArray ({ 1 , 2 , nil , nil , 3 }) -- false dash . isArray ( dash . compact ({ 1 , 2 , nil , nil , 3 })) -- true isEmpty function dash . isEmpty ( source ) -- bool Returns true if source has no keys. Type T: Iterable K,V (T - bool) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type Returns bool - a boolean Examples dash . isEmpty ({}) -- true dash . isEmpty ({ false }) -- false dash . isEmpty ({ a = 1 }) -- false Usage Note that a table only has a length if it is an array, so this can be used on non-arrays. isSubset function dash . isSubset ( left , right ) -- bool Returns true if all the values in left match corresponding values in right recursively. For elements which are not tables, they match if they are equal. If they are tables they match if the right table is a subset of the left. Type T (T{}, T{}) - bool Generics T - any - the primary type (extends any value) Parameters left - T{} - a dictionary (of the primary type) right - T{} - a dictionary (of the primary type) Returns bool - a boolean Examples local car = { speed = 10 , wheels = 4 , lightsOn = { indicators = true , headlights = false } } dash . isSubset ( car , {}) -- true dash . isSubset ( car , car ) -- true dash . isSubset ( car , { speed = 10 , lightsOn = { indicators = true }}) -- true dash . isSubset ( car , { speed = 12 }) -- false dash . isSubset ({}, car ) -- false iterator function dash . iterator ( source , asArray ) -- Iterator T Determines a suitable Iterator to use for source , allowing source to be either a plain table, a table that has a metatable with an iterable key, or a function. By default, the iterator is unordered, but passing asArray as true uses ipairs to iterate through natural keys 1..n in order. Type T: Iterable (T, bool - Iterator T ) Generics T - Iterable - the primary type (extends an Iterable ) Parameters source - T - the primary type asArray - bool - a boolean Returns Iterator T - an Iterator (of the primary type) keyBy function dash . keyBy ( source , handler ) -- Iterable K2, V This function iterates over source , calling handler to obtain a key for each element. The element is then assigned by its key to the resulting object, overriding any previous element assigned to that key from source. If the handler returns nil, the element is dropped from the result. Type T: Iterable K,V , K2 ((T, (element: V, key: K) - K2) - Iterable K2,V ) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) K2 - any - the secondary key type (extends any value) Parameters source - (T, element: V, key: K) - K2 - a function (taking the primary type and a tuple ( element (the primary value type) and key (the primary key type)), and returning the secondary key type) handler - any - any value Returns Iterable K2, V - an Iterable (of the secondary key type and the primary value type) Examples local playerSet = { Frodo = true , Bilbo = true , Boromir = true } local healthSet = dash . keyBy ( playerSet , function ( name ) return dash . get ( game . Players , name , Character , Humanoid , Health ) end ) healthSet -- {100 = true, 50 = true, 0 = true} See dash.groupBy - if you want to preseve all the elements at each key. keys function dash . keys ( source ) -- K[] Returns an array of all the keys of the elements in source . Type T: Iterable K,V (T - K[]) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type Returns K[] - an array (of the primary key type) Examples dash . values ({ Frodo = 1 , Boromir = 2 , Bilbo = 3 }) -- { Frodo , Boromir , Bilbo } (in some order) len function dash . len ( source ) -- int Returns the number of elements in source . Type T: Iterable K,V (T - int) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type Returns int - an integer Examples local names = { [ 3 ] = Boromir , [ 1 ] = Frodo , [ 8 ] = Bilbo } dash . len ( names ) -- 3 Usage Note that a table only has a length if it is an array, so this can be used on non-arrays. map function dash . map ( source , handler ) -- Iterable K, V2 Create a new table from source where each value is replaced with the value returned from calling handler with each element in source . Type T: Iterable K,V , V2 ((T, (element: V, key: K) - V2) - Iterable K,V2 ) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) V2 - any - the secondary value type (extends any value) Parameters source - (T, element: V, key: K) - V2 - a function (taking the primary type and a tuple ( element (the primary value type) and key (the primary key type)), and returning the secondary value type) handler - any - any value Returns Iterable K, V2 - an Iterable (of the primary key type and the secondary value type) Examples -- Use map to get the same property of each value: local playerNames = dash . map ( game . Players : GetChildren (), function ( player ) return player . Name end ) playerNames -- { Frodo Baggins , Bilbo Baggins , Boromir } -- Use map to remove elements while preserving keys: local ingredients = { veg = carrot , sauce = tomato , herb = basil } local carrotsAndHerbs = dash . map ( ingredients , function ( value , key ) if value == carrot or key == herb then return value end end ) carrotsAndHerbs -- {veg = carrot , herb = basil } -- Use map with multiple values of a table at once: local numbers = { 1 , 1 , 2 , 3 , 5 } local nextNumbers = dash . map ( numbers , function ( value , key ) return value + ( numbers [ key - 1 ] or 0 ) end ) nextNumbers -- {1, 2, 3, 5, 8} See dash.filter - if you want to remove values using a predicate. mapValues function dash . mapValues ( source , handler ) -- V2[] Like dash.map , but returns an array of the transformed values in the order that they are iterated over, dropping the original keys. Type T: Iterable K,V , V2 ((T, (element: V, key: K) - V2) - V2[]) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) V2 - any - the secondary value type (extends any value) Parameters source - (T, element: V, key: K) - V2 - a function (taking the primary type and a tuple ( element (the primary value type) and key (the primary key type)), and returning the secondary value type) handler - any - any value Returns V2[] - an array (of the secondary value type) Examples local ingredients = { veg = carrot , sauce = tomato , herb = basil } local list = dash . mapValues ( function ( value ) return dash . format ( {} x2 , value ) end ) list -- { carrot x2 , tomato x2 , basil x2 } (in some order) Usage This is equivalent to dash.values(dash.map(...)) but more concise. See dash.map merge function dash . merge ( target , ...) -- T Mutates target by iterating recursively through elements of the subsequent arguments in order and inserting or replacing the values in target with each element preserving keys. If any values are both tables, these are merged recursively using dash.merge . Type T: Iterable K,V (mut T, ...T) - T Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters target - mut T - the primary type (which can be mutated) ... - ...T - the primary type Returns T - the primary type Examples local someInfo = { Frodo = { name = Frodo Baggins , team = blue }, Boromir = { score = 5 } } local someOtherInfo = { Frodo = { team = red , score = 10 }, Bilbo = { team = yellow , }, Boromir = { score = { 1 , 2 , 3 } } } local mergedInfo = dash . merge ( someInfo , someOtherInfo ) --[[ -- { Frodo = { name = Frodo Baggins , team = red , score = 10 }, Bilbo = { team = yellow }, Boromir = { score = {1, 2, 3} } } ]] See dash.assign dash.defaults occurences function dash . occurences ( source ) -- {[T]: int} Return a set of the tables that appear as descendants of source , mapped to the number of times each table has been found with a unique parent. Repeat occurences are not traversed, so the function is cycle-safe. If any tables in the result have a count of two or more, they may form cycles in the source . Type T: Iterable K,V (T - {[T]:int}) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type Returns {[T]: int} - a dictionary mapping the primary type to integers Examples local plate = { veg = potato , pie = { stilton , beef }} dash . occurences ( plate ) --[[ { [{veg = potato , pie = { stilton , beef }}] = 1 [{ stilton , beef }] = 1 }]] local kyle = { name = Kyle } kyle . child = kyle dash . occurences ( kyle ) --[[ { [{name = Kyle , child = kyle}] = 2 }]] one function dash . one ( source ) -- V, K? Returns an element from source , if it has one. If there are multiple elements in source , any one of them may be returned as the iteration order over a table is stochastic. Type T: Iterable K,V (T - (V, K)?) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type Returns V, K? - a tuple (the primary value type and the primary key type) (optional) Examples dash . one ({}) -- nil dash . one ({ a = 1 , b = 2 , c = 3 }) -- b, 2 (or any another element) privatize function dash . privatize ( source ) -- T{} Returns a copy of source , ensuring each key starts with an underscore _ . Keys which are already prefixed with an underscore are left unchanged. Type T (T{} - T{}) Generics T - any - the primary type (extends any value) Parameters source - T{} - a dictionary (of the primary type) Returns T{} - a dictionary (of the primary type) Examples local privates = dash . privatize ({ [ 1 ] = 1 , public = 2 , _private = 3 }) privates -- {_1 = 1, _public = 2, _private = 3} -- Make a static factory to create Cars with private fields local interface = { speed = t . number , color = t . string } local Car = dash . classWithInterface ( dash . privatize ( interface ) ) local CarFactory = { make = function ( props ) return Car . new ( dash . privatize ( props )) end } -- Create a new car using a public interface: local car = CarFactory . make ({ speed = 5 , color = red }) -- By convention, private fields should only by their owner. car . _speed -- 5 Usage Fields starting with an underscore are considered private in many programming languages without inbuild access control. This function allows you to translate a public interface into a private one suitable for a class instance with private fields. See dash.class dash.classWithInterface serialize function dash . serialize ( source , options ) -- string Returns a string representation of source including all elements with sorted keys. dash.serialize preserves the properties of being unique, stable and cycle-safe if the serializer functions provided also obey these properties. Type T: Iterable K,V ((T, SerializeOptions T ) - string) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type options - SerializeOptions T - a SerializeOptions (of the primary type) Returns string - a string Examples dash . serialize ({ 1 , 2 , 3 }) -- {1,2,3} dash . serialize ({ a = 1 , b = true , [ 3 ] = hello }) -- { a :1, b :true,3: hello } dash . serialize ({ a = function () end , b = { a = table }) -- { a : function: 0x... , b = table: 0x... } Usage Use dash.serialize when you need a representation of a table which doesn't need to be human-readable, or you need to customize the way serialization works. dash.pretty is more appropriate when you need a human-readable string. See dash.serializeDeep dash.defaultSerializer dash.pretty serializeDeep function dash . serializeDeep ( source , options ) -- string Like dash.serialize , but if a child element is a table it is serialized recursively. Returns a string representation of source including all elements with sorted keys. This function preserves uniqueness, stability and cycle-safety. Type T: Iterable K,V ((T, SerializeOptions T ) - string) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type options - SerializeOptions T - a SerializeOptions (of the primary type) Returns string - a string Examples dash . serializeDeep ({ a = { b = table }) -- { a :{ b : table }} local kyle = { name = Kyle } kyle . child = kyle dash . serializeDeep ( kyle ) -- 0 { child : 0 , name : Kyle } See dash.serialize dash.defaultSerializer Chainable set function dash . set ( source , path , value ) -- bool Set a child or descendant value in a table. Returns true if the operation completed without error. The function walks through the object using keys from path in turn. If any values along the path are not tables, dash.set will do nothing and return false . Type T: Iterable K, V (T, K[], V) - bool Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type path - K[] - an array (of the primary key type) value - V - the primary value type Returns bool - a boolean - true if the set worked Examples dash . set ( game . Players , { LocalPlayer , Character , UpperTorso , Color }, Color3 . new ( 255 , 255 , 255 )) -- true (if the set worked) shallowEqual function dash . shallowEqual ( left , right ) -- bool Returns true if left and right are equal, or if they are tables and the elements in one are present and have equal values to those in the other. Type any, any - bool Parameters left - any - any value right - any - any value Returns bool - a boolean Examples local car = { speed = 10 , wheels = 4 , lightsOn = { indicators = true , headlights = false } } dash . shallowEqual ( car , {}) -- false dash . shallowEqual ( car , car ) -- true dash . shallowEqual ( car , dash . clone ( car )) -- true dash . shallowEqual ( car , dash . cloneDeep ( car )) -- false Based on https : // developmentarc . gitbooks . io / react - indepth / content / life_cycle / update / using_should_component_update . html See dash.deepEqual unique function dash . unique ( source ) -- T[] Returns an array of the values in source , without any repetitions. Values are considered equal if the have the same key representation. Type T (T[] - T[]) Generics T - any - the primary type (extends any value) Parameters source - T[] - an array (of the primary type) Returns T[] - an array (of the primary type) Examples local list = { 1 , 2 , 2 , 3 , 5 , 1 } dash . unique ( list ) -- {1, 2, 3, 5} (or another order) values function dash . values ( source ) -- V[] Returns an array of all the values of the elements in source . Type T: Iterable K,V (T - V[]) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type Returns V[] - an array (of the primary value type) Examples dash . values ({ Frodo = 1 , Boromir = 2 , Bilbo = 3 }) -- {1, 2, 3} (in some order) without function dash . without ( source , value ) -- V[] Returns an array of elements in source with any elements of value removed. Type T: Iterable K,V (T, V - V[]) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type value - V - the primary value type Returns V[] - an array (of the primary value type) Examples local points = { 0 , 10 , 3 , 0 , 5 } local nonZero = dash . without ( points , 0 ) nonZero -- {10, 3, 5} local ingredients = { veg = carrot , sauce = tomato , herb = basil } local withoutCarrots = dash . without ( ingredients , carrot ) withoutCarrots -- { tomato , basil } (in some order)","title":"Tables"},{"location":"api/Tables/#tables","text":"A collection of functions that operate on Lua tables. These can operate on arrays, dictionaries and any collection types implemented with tables. These functions can iterate over any Iterable values. These functions typically act on immutable tables and return new tables in functional style. Note that mutable arguments in Rodash are explicitly typed as such with the mut keyword.","title":"Tables"},{"location":"api/Tables/#functions","text":"","title":"Functions"},{"location":"api/Tables/#all","text":"function dash . all ( source , handler ) -- bool Return true if handler returns true for every element in source it is called with. If no handler is provided, dash.all returns true if every element is non-nil. Type T: Iterable K,V (T, (value: V, key: K - bool)?) - bool Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type handler - (value: V, key: K) - bool? - a function (taking value (the primary value type) and key (the primary key type), and returning a boolean) (optional) - (default = dash.id ) Returns bool - a boolean Examples local names = { [ 3 ] = Boromir , [ 1 ] = Frodo , [ 8 ] = Bilbo } local allNamesStartWithB = dash . all ( names , function ( name ) return dash . startsWith ( name , B ) end ) allNamesStartWithB -- false","title":"all"},{"location":"api/Tables/#any","text":"function dash . any ( source , handler ) -- bool Return true if handler returns true for at least one element in source it is called with. If no handler is provided, dash.any returns true if some element is non-nil. Type T: Iterable K,V (T - bool) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type handler - any - any value - (default = dash.id ) Returns bool - a boolean Examples local names = { [ 3 ] = Boromir , [ 1 ] = Frodo , [ 8 ] = Bilbo } local anyNameStartsWithB = dash . any ( names , function ( name ) return dash . startsWith ( name , B ) end ) anyNameStartsWithB -- true","title":"any"},{"location":"api/Tables/#assign","text":"function dash . assign ( target , ...) -- T Adds new elements in target from subsequent table arguments in order, with elements in later tables replacing earlier ones if their keys match. Type T: Iterable K,V (mut T, ...T) - T Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters target - mut T - the primary type (which can be mutated) ... - ...T - the primary type - any number of other tables Returns T - the primary type Examples local someInfo = { Frodo = { name = Frodo Baggins , team = blue }, Boromir = { score = 5 } } local someOtherInfo = { Frodo = { team = red , score = 10 }, Bilbo = { team = yellow , }, Boromir = { score = { 1 , 2 , 3 } } } local assignedInfo = dash . assign ( someInfo , someOtherInfo ) --[[ -- { Frodo = { team = red , score = 10 }, Bilbo = { team = yellow }, Boromir = { score = {1, 2, 3} } } ]] See dash.defaults dash.merge","title":"assign"},{"location":"api/Tables/#clone","text":"function dash . clone ( source ) -- T Returns a shallow copy of source . Type T: Iterable K,V (T - T) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type Returns T - the primary type Examples local Hermione = { name = Hermione Granger , time = 12 } local PastHermione = dash . clone ( Hermione ) PastHermione . time = 9 Hermione . time -- 12 See dash.cloneDeep - if you also want to clone descendants of the table, though this can be costly. dash.map - if you want to return different values for each key. dash.Cloneable - use this to derive a default :clone() method for class instances.","title":"clone"},{"location":"api/Tables/#clonedeep","text":"function dash . cloneDeep ( source ) -- T Recursively clones descendants of source , returning the cloned object. If references to the same table are found, the same clone is used in the result. This means that dash.cloneDeep is cycle-safe. Elements which are not tables are not modified. Type T: Iterable K,V (T - T) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type Returns T - the primary type Examples local Harry = { patronus = stag , age = 12 } local Hedwig = { animal = owl , owner = Harry } Harry . pet = Hedwig local clonedHarry = dash . cloneDeep ( Harry ) Harry . age = 13 -- The object clonedHarry is completely independent of any changes to Harry: dash . pretty ( clonedHarry ) -- 1 {age = 12, patronus = stag , pet = {animal = owl , owner = 1}} See dash.clone - if you simply want to perform a shallow clone.","title":"cloneDeep"},{"location":"api/Tables/#compact","text":"function dash . compact ( source ) -- V[] Returns an array of elements from a sparse array source with the returned elements provided in original key-order. Type T: Iterable K,V (T - V[]) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type Returns V[] - an array (of the primary value type) Examples local names = { [ 3 ] = Boromir , [ 1 ] = Frodo , [ 8 ] = Bilbo } local inOrderNames = dash . compact ( names ) inOrderNames -- { Frodo , Boromir , Bilbo }","title":"compact"},{"location":"api/Tables/#deepequal","text":"function dash . deepEqual ( a , b ) -- bool Returns true if every element in a recursively matches every element b . For elements which are not tables, they match if they are equal. If they are tables they match if the left is recursively deeply-equal to the right. Type any, any - bool Parameters a - any - any value b - any - any value Returns bool - a boolean Examples local car = { speed = 10 , wheels = 4 , lightsOn = { indicators = true , headlights = false } } local car2 = { speed = 10 , wheels = 4 , lightsOn = { indicators = false , headlights = false } } dash . deepEqual ( car , {}) -- false dash . deepEqual ( car , car ) -- true dash . deepEqual ( car , dash . clone ( car )) -- true dash . deepEqual ( car , dash . cloneDeep ( car )) -- true dash . deepEqual ( car , car2 ) -- false See dash.isSubset dash.shallowEqual","title":"deepEqual"},{"location":"api/Tables/#defaults","text":"function dash . defaults ( target , ...) -- T Adds new elements in target from subsequent table arguments in order, with elements in earlier tables overriding later ones if their keys match. Type T: Iterable K,V (mut T, ...T) - T Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters target - mut T - the primary type (which can be mutated) ... - ...T - the primary type - any number of other tables Returns T - the primary type Examples local someInfo = { Frodo = { name = Frodo Baggins , team = blue }, Boromir = { score = 5 } } local someOtherInfo = { Frodo = { team = red , score = 10 }, Bilbo = { team = yellow , }, Boromir = { score = { 1 , 2 , 3 } } } local assignedInfo = dash . assign ( someInfo , someOtherInfo ) --[[ -- { Frodo = { name = Frodo Baggins , team = blue }, Boromir = { score = 5 } Bilbo = { team = yellow } } ]] See dash.assign dash.merge","title":"defaults"},{"location":"api/Tables/#defaultserializer","text":"function dash . defaultSerializer ( input ) -- string A function which provides a simple, shallow string representation of a value. Type any - string Parameters input - any - any value Returns string - a string Examples dash . defaultSerializer () -- nil dash . defaultSerializer ( true ) -- true dash . defaultSerializer ( 5.8 ) -- 5.8 dash . defaultSerializer ( Hello .. \\ n .. there ) -- Hello \\n there","title":"defaultSerializer"},{"location":"api/Tables/#entries","text":"function dash . entries ( source ) -- {K, V}[] Returns an array of all the entries of elements in source . Each entry is a tuple (key, value) . Type T: Iterable K,V (T - {K, V}[]) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type Returns {K, V}[] - an array (of arrays (of tuples (the primary key type and the primary value type))) Examples dash . values ({ Frodo = 1 , Boromir = 2 , Bilbo = 3 }) -- {{ Frodo , 1}, { Boromir , 2}, { Bilbo , 3}} (in some order)","title":"entries"},{"location":"api/Tables/#filter","text":"function dash . filter ( source , handler ) -- V[] Returns an array of any values in source that the handler function returned true for, in order of iteration. Type T: Iterable K,V (T, (element: V, key: K - bool) - V[]) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type handler - (element: V, key: K) - bool - a function (taking element (the primary value type) and key (the primary key type), and returning a boolean) Returns V[] - an array (of the primary value type) Examples local myTools = game . Players . LocalPlayer . Backpack : GetChildren () local mySpoons = dash . filter ( myTools , function ( tool ) return dash . endsWith ( tool . Name , Spoon ) end ) mySpoons -- {SilverSpoon, TableSpoon} See dash.map if you would like to remove elements but preserve table keys","title":"filter"},{"location":"api/Tables/#find","text":"function dash . find ( source , handler ) -- V? Picks a value from the table that handler returns true for. If multiple elements might return true, any one of them may be returned as the iteration order over a table is stochastic. Type T: Iterable K,V ((T, (element: V, key: K) - bool) - V?) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - (T, element: V, key: K) - bool - a function (taking the primary type and a tuple ( element (the primary value type) and key (the primary key type)), and returning a boolean) handler - any - any value Returns V? - the primary value type (optional) Examples local names = { [ 3 ] = Boromir , [ 1 ] = Frodo , [ 8 ] = Bilbo } local nameWithB = dash . find ( names , function ( name ) return dash . startsWith ( name , B ) end ) nameWithB -- Bilbo , 8 (or Boromir , 3) -- Or use a chain: local nameWithF = dash . find ( names , dash . fn : startsWith ( name , B )) nameWithF -- Frodo , 1 -- Or find the key of a specific value: local _ , key = dash . find ( names , dash . fn : matches ( Bilbo )) key -- 8 Usage If you need to find the first value of an array that matches, use dash.first . See dash.first","title":"find"},{"location":"api/Tables/#flatmap","text":"function dash . flatMap ( source , handler ) -- V2[] Like dash.mapValues this function iterates through source and returns an array of values, using handler to transform them. However, handler must return an array of results, these elements being insterted into the resulting array. You can return an empty array {} from handler to avoid inserting anything for a particular element. Type T: Iterable K,V , V2 ((T, (element: V, key: K) - V2[]) - V2[]) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) V2 - any - the secondary value type (extends any value) Parameters source - (T, element: V, key: K) - V2[] - a function (taking the primary type and a tuple ( element (the primary value type) and key (the primary key type)), and returning an array (of the secondary value type)) handler - any - any value Returns V2[] - an array (of the secondary value type) Examples local tools = dash . flatMap ( game . Players : GetChildren (), function ( player ) return player . Backpack : GetChildren () end ) tools -- {Spoon, Ring, Sting, Book} Chainable","title":"flatMap"},{"location":"api/Tables/#get","text":"function dash . get ( source , ...) -- V? Get a child or descendant of a table, returning nil if any errors are generated. Type K, V, T: {[K]: V} (T, ...K) - V? Generics K - any - the primary key type (extends any value) V - any - the primary value type (extends any value) T - {[K]: V} - the primary type (extends a dictionary mapping the primary key type to the primary value type) Parameters source - T - the primary type ... - ...K - the primary key type - Further keys to address any descendent. Returns V? - the primary value type (optional) Examples local upperTorso = dash . get ( game . Players , LocalPlayer , Character , UpperTorso ) upperTorso -- Part (if player s character and its UpperTorso are defined) -- You can also bind a lookup to get later on: local getUpperTorso = dash . bindTail ( dash . get , Character , UpperTorso ) getUpperTorso ( players . LocalPlayer ) -- Part","title":"get"},{"location":"api/Tables/#groupby","text":"function dash . groupBy ( source , handler ) -- Iterable K2, Iterable K, V This function iterates over source , calling handler to obtain a key for each element. Elements from source are then appended to an array of elements based on their key, so that this function returns a dictionary of arrays of the elements grouped by their keys. If the handler returns nil, the element is dropped from the result. Type T: Iterable K,V , K2 (((value: T, key: K) - K2) - Iterable K2, Iterable K,V ) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) K2 - any - the secondary key type (extends any value) Parameters source - (value: T, key: K) - K2 - a function (taking value (the primary type) and key (the primary key type), and returning the secondary key type) handler - any - any value Returns Iterable K2, Iterable K, V - an Iterable (of the secondary key type and Iterable (of the primary key type and the primary value type)) Examples local playerSet = { Frodo = Frodo , Bilbo = Bilbo , Boromir = Boromir } local healthSet = dash . keyBy ( playerSet , function ( name ) return dash . get ( game . Players , name , Character , Humanoid , Health ) end ) healthSet -- {100 = {}, 50 = { Bilbo , Frodo }, 0 = { Boromir }} See dash.keyBy - if you only want one element to be preserved at each key dash.get","title":"groupBy"},{"location":"api/Tables/#includes","text":"function dash . includes ( source , item ) -- bool Returns true if item exists as a value in the source table. Type T: Iterable K,V (T, V - bool) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type item - V - the primary value type Returns bool - a boolean Examples local names = { [ 3 ] = Boromir , [ 1 ] = Frodo , [ 8 ] = Bilbo } dash . includes ( names , Boromir ) -- true dash . includes ( names , 1 ) -- false","title":"includes"},{"location":"api/Tables/#invert","text":"function dash . invert ( source ) -- Iterable V, K Returns a table with elements from source with their keys and values flipped. Type K, V (Iterable K,V - Iterable V,K ) Generics K - any - the primary key type (extends any value) V - any - the primary value type (extends any value) Parameters source - Iterable K, V - an Iterable (of the primary key type and the primary value type) Returns Iterable V, K - an Iterable (of the primary value type and the primary key type) Examples local teams = { red = Frodo , blue = Bilbo , yellow = Boromir } local players = dash . invert ( teams ) players -- {Frodo = red , Bilbo = blue , Boromir = yellow }","title":"invert"},{"location":"api/Tables/#isarray","text":"function dash . isArray ( source ) -- bool Returns true is source is made up only of natural keys 1..n . Type T: Iterable K,V (T - bool) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type Returns bool - a boolean Examples dash . isArray ({ 1 , 2 , 3 }) -- true dash . isArray ({ a = 1 , b = 2 , c = 3 }) -- false -- Treating sparse arrays as natural arrays will only complicate things: dash . isArray ({ 1 , 2 , nil , nil , 3 }) -- false dash . isArray ( dash . compact ({ 1 , 2 , nil , nil , 3 })) -- true","title":"isArray"},{"location":"api/Tables/#isempty","text":"function dash . isEmpty ( source ) -- bool Returns true if source has no keys. Type T: Iterable K,V (T - bool) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type Returns bool - a boolean Examples dash . isEmpty ({}) -- true dash . isEmpty ({ false }) -- false dash . isEmpty ({ a = 1 }) -- false Usage Note that a table only has a length if it is an array, so this can be used on non-arrays.","title":"isEmpty"},{"location":"api/Tables/#issubset","text":"function dash . isSubset ( left , right ) -- bool Returns true if all the values in left match corresponding values in right recursively. For elements which are not tables, they match if they are equal. If they are tables they match if the right table is a subset of the left. Type T (T{}, T{}) - bool Generics T - any - the primary type (extends any value) Parameters left - T{} - a dictionary (of the primary type) right - T{} - a dictionary (of the primary type) Returns bool - a boolean Examples local car = { speed = 10 , wheels = 4 , lightsOn = { indicators = true , headlights = false } } dash . isSubset ( car , {}) -- true dash . isSubset ( car , car ) -- true dash . isSubset ( car , { speed = 10 , lightsOn = { indicators = true }}) -- true dash . isSubset ( car , { speed = 12 }) -- false dash . isSubset ({}, car ) -- false","title":"isSubset"},{"location":"api/Tables/#iterator","text":"function dash . iterator ( source , asArray ) -- Iterator T Determines a suitable Iterator to use for source , allowing source to be either a plain table, a table that has a metatable with an iterable key, or a function. By default, the iterator is unordered, but passing asArray as true uses ipairs to iterate through natural keys 1..n in order. Type T: Iterable (T, bool - Iterator T ) Generics T - Iterable - the primary type (extends an Iterable ) Parameters source - T - the primary type asArray - bool - a boolean Returns Iterator T - an Iterator (of the primary type)","title":"iterator"},{"location":"api/Tables/#keyby","text":"function dash . keyBy ( source , handler ) -- Iterable K2, V This function iterates over source , calling handler to obtain a key for each element. The element is then assigned by its key to the resulting object, overriding any previous element assigned to that key from source. If the handler returns nil, the element is dropped from the result. Type T: Iterable K,V , K2 ((T, (element: V, key: K) - K2) - Iterable K2,V ) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) K2 - any - the secondary key type (extends any value) Parameters source - (T, element: V, key: K) - K2 - a function (taking the primary type and a tuple ( element (the primary value type) and key (the primary key type)), and returning the secondary key type) handler - any - any value Returns Iterable K2, V - an Iterable (of the secondary key type and the primary value type) Examples local playerSet = { Frodo = true , Bilbo = true , Boromir = true } local healthSet = dash . keyBy ( playerSet , function ( name ) return dash . get ( game . Players , name , Character , Humanoid , Health ) end ) healthSet -- {100 = true, 50 = true, 0 = true} See dash.groupBy - if you want to preseve all the elements at each key.","title":"keyBy"},{"location":"api/Tables/#keys","text":"function dash . keys ( source ) -- K[] Returns an array of all the keys of the elements in source . Type T: Iterable K,V (T - K[]) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type Returns K[] - an array (of the primary key type) Examples dash . values ({ Frodo = 1 , Boromir = 2 , Bilbo = 3 }) -- { Frodo , Boromir , Bilbo } (in some order)","title":"keys"},{"location":"api/Tables/#len","text":"function dash . len ( source ) -- int Returns the number of elements in source . Type T: Iterable K,V (T - int) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type Returns int - an integer Examples local names = { [ 3 ] = Boromir , [ 1 ] = Frodo , [ 8 ] = Bilbo } dash . len ( names ) -- 3 Usage Note that a table only has a length if it is an array, so this can be used on non-arrays.","title":"len"},{"location":"api/Tables/#map","text":"function dash . map ( source , handler ) -- Iterable K, V2 Create a new table from source where each value is replaced with the value returned from calling handler with each element in source . Type T: Iterable K,V , V2 ((T, (element: V, key: K) - V2) - Iterable K,V2 ) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) V2 - any - the secondary value type (extends any value) Parameters source - (T, element: V, key: K) - V2 - a function (taking the primary type and a tuple ( element (the primary value type) and key (the primary key type)), and returning the secondary value type) handler - any - any value Returns Iterable K, V2 - an Iterable (of the primary key type and the secondary value type) Examples -- Use map to get the same property of each value: local playerNames = dash . map ( game . Players : GetChildren (), function ( player ) return player . Name end ) playerNames -- { Frodo Baggins , Bilbo Baggins , Boromir } -- Use map to remove elements while preserving keys: local ingredients = { veg = carrot , sauce = tomato , herb = basil } local carrotsAndHerbs = dash . map ( ingredients , function ( value , key ) if value == carrot or key == herb then return value end end ) carrotsAndHerbs -- {veg = carrot , herb = basil } -- Use map with multiple values of a table at once: local numbers = { 1 , 1 , 2 , 3 , 5 } local nextNumbers = dash . map ( numbers , function ( value , key ) return value + ( numbers [ key - 1 ] or 0 ) end ) nextNumbers -- {1, 2, 3, 5, 8} See dash.filter - if you want to remove values using a predicate.","title":"map"},{"location":"api/Tables/#mapvalues","text":"function dash . mapValues ( source , handler ) -- V2[] Like dash.map , but returns an array of the transformed values in the order that they are iterated over, dropping the original keys. Type T: Iterable K,V , V2 ((T, (element: V, key: K) - V2) - V2[]) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) V2 - any - the secondary value type (extends any value) Parameters source - (T, element: V, key: K) - V2 - a function (taking the primary type and a tuple ( element (the primary value type) and key (the primary key type)), and returning the secondary value type) handler - any - any value Returns V2[] - an array (of the secondary value type) Examples local ingredients = { veg = carrot , sauce = tomato , herb = basil } local list = dash . mapValues ( function ( value ) return dash . format ( {} x2 , value ) end ) list -- { carrot x2 , tomato x2 , basil x2 } (in some order) Usage This is equivalent to dash.values(dash.map(...)) but more concise. See dash.map","title":"mapValues"},{"location":"api/Tables/#merge","text":"function dash . merge ( target , ...) -- T Mutates target by iterating recursively through elements of the subsequent arguments in order and inserting or replacing the values in target with each element preserving keys. If any values are both tables, these are merged recursively using dash.merge . Type T: Iterable K,V (mut T, ...T) - T Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters target - mut T - the primary type (which can be mutated) ... - ...T - the primary type Returns T - the primary type Examples local someInfo = { Frodo = { name = Frodo Baggins , team = blue }, Boromir = { score = 5 } } local someOtherInfo = { Frodo = { team = red , score = 10 }, Bilbo = { team = yellow , }, Boromir = { score = { 1 , 2 , 3 } } } local mergedInfo = dash . merge ( someInfo , someOtherInfo ) --[[ -- { Frodo = { name = Frodo Baggins , team = red , score = 10 }, Bilbo = { team = yellow }, Boromir = { score = {1, 2, 3} } } ]] See dash.assign dash.defaults","title":"merge"},{"location":"api/Tables/#occurences","text":"function dash . occurences ( source ) -- {[T]: int} Return a set of the tables that appear as descendants of source , mapped to the number of times each table has been found with a unique parent. Repeat occurences are not traversed, so the function is cycle-safe. If any tables in the result have a count of two or more, they may form cycles in the source . Type T: Iterable K,V (T - {[T]:int}) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type Returns {[T]: int} - a dictionary mapping the primary type to integers Examples local plate = { veg = potato , pie = { stilton , beef }} dash . occurences ( plate ) --[[ { [{veg = potato , pie = { stilton , beef }}] = 1 [{ stilton , beef }] = 1 }]] local kyle = { name = Kyle } kyle . child = kyle dash . occurences ( kyle ) --[[ { [{name = Kyle , child = kyle}] = 2 }]]","title":"occurences"},{"location":"api/Tables/#one","text":"function dash . one ( source ) -- V, K? Returns an element from source , if it has one. If there are multiple elements in source , any one of them may be returned as the iteration order over a table is stochastic. Type T: Iterable K,V (T - (V, K)?) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type Returns V, K? - a tuple (the primary value type and the primary key type) (optional) Examples dash . one ({}) -- nil dash . one ({ a = 1 , b = 2 , c = 3 }) -- b, 2 (or any another element)","title":"one"},{"location":"api/Tables/#privatize","text":"function dash . privatize ( source ) -- T{} Returns a copy of source , ensuring each key starts with an underscore _ . Keys which are already prefixed with an underscore are left unchanged. Type T (T{} - T{}) Generics T - any - the primary type (extends any value) Parameters source - T{} - a dictionary (of the primary type) Returns T{} - a dictionary (of the primary type) Examples local privates = dash . privatize ({ [ 1 ] = 1 , public = 2 , _private = 3 }) privates -- {_1 = 1, _public = 2, _private = 3} -- Make a static factory to create Cars with private fields local interface = { speed = t . number , color = t . string } local Car = dash . classWithInterface ( dash . privatize ( interface ) ) local CarFactory = { make = function ( props ) return Car . new ( dash . privatize ( props )) end } -- Create a new car using a public interface: local car = CarFactory . make ({ speed = 5 , color = red }) -- By convention, private fields should only by their owner. car . _speed -- 5 Usage Fields starting with an underscore are considered private in many programming languages without inbuild access control. This function allows you to translate a public interface into a private one suitable for a class instance with private fields. See dash.class dash.classWithInterface","title":"privatize"},{"location":"api/Tables/#serialize","text":"function dash . serialize ( source , options ) -- string Returns a string representation of source including all elements with sorted keys. dash.serialize preserves the properties of being unique, stable and cycle-safe if the serializer functions provided also obey these properties. Type T: Iterable K,V ((T, SerializeOptions T ) - string) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type options - SerializeOptions T - a SerializeOptions (of the primary type) Returns string - a string Examples dash . serialize ({ 1 , 2 , 3 }) -- {1,2,3} dash . serialize ({ a = 1 , b = true , [ 3 ] = hello }) -- { a :1, b :true,3: hello } dash . serialize ({ a = function () end , b = { a = table }) -- { a : function: 0x... , b = table: 0x... } Usage Use dash.serialize when you need a representation of a table which doesn't need to be human-readable, or you need to customize the way serialization works. dash.pretty is more appropriate when you need a human-readable string. See dash.serializeDeep dash.defaultSerializer dash.pretty","title":"serialize"},{"location":"api/Tables/#serializedeep","text":"function dash . serializeDeep ( source , options ) -- string Like dash.serialize , but if a child element is a table it is serialized recursively. Returns a string representation of source including all elements with sorted keys. This function preserves uniqueness, stability and cycle-safety. Type T: Iterable K,V ((T, SerializeOptions T ) - string) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type options - SerializeOptions T - a SerializeOptions (of the primary type) Returns string - a string Examples dash . serializeDeep ({ a = { b = table }) -- { a :{ b : table }} local kyle = { name = Kyle } kyle . child = kyle dash . serializeDeep ( kyle ) -- 0 { child : 0 , name : Kyle } See dash.serialize dash.defaultSerializer Chainable","title":"serializeDeep"},{"location":"api/Tables/#set","text":"function dash . set ( source , path , value ) -- bool Set a child or descendant value in a table. Returns true if the operation completed without error. The function walks through the object using keys from path in turn. If any values along the path are not tables, dash.set will do nothing and return false . Type T: Iterable K, V (T, K[], V) - bool Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type path - K[] - an array (of the primary key type) value - V - the primary value type Returns bool - a boolean - true if the set worked Examples dash . set ( game . Players , { LocalPlayer , Character , UpperTorso , Color }, Color3 . new ( 255 , 255 , 255 )) -- true (if the set worked)","title":"set"},{"location":"api/Tables/#shallowequal","text":"function dash . shallowEqual ( left , right ) -- bool Returns true if left and right are equal, or if they are tables and the elements in one are present and have equal values to those in the other. Type any, any - bool Parameters left - any - any value right - any - any value Returns bool - a boolean Examples local car = { speed = 10 , wheels = 4 , lightsOn = { indicators = true , headlights = false } } dash . shallowEqual ( car , {}) -- false dash . shallowEqual ( car , car ) -- true dash . shallowEqual ( car , dash . clone ( car )) -- true dash . shallowEqual ( car , dash . cloneDeep ( car )) -- false Based on https : // developmentarc . gitbooks . io / react - indepth / content / life_cycle / update / using_should_component_update . html See dash.deepEqual","title":"shallowEqual"},{"location":"api/Tables/#unique","text":"function dash . unique ( source ) -- T[] Returns an array of the values in source , without any repetitions. Values are considered equal if the have the same key representation. Type T (T[] - T[]) Generics T - any - the primary type (extends any value) Parameters source - T[] - an array (of the primary type) Returns T[] - an array (of the primary type) Examples local list = { 1 , 2 , 2 , 3 , 5 , 1 } dash . unique ( list ) -- {1, 2, 3, 5} (or another order)","title":"unique"},{"location":"api/Tables/#values","text":"function dash . values ( source ) -- V[] Returns an array of all the values of the elements in source . Type T: Iterable K,V (T - V[]) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type Returns V[] - an array (of the primary value type) Examples dash . values ({ Frodo = 1 , Boromir = 2 , Bilbo = 3 }) -- {1, 2, 3} (in some order)","title":"values"},{"location":"api/Tables/#without","text":"function dash . without ( source , value ) -- V[] Returns an array of elements in source with any elements of value removed. Type T: Iterable K,V (T, V - V[]) Generics T - Iterable K, V - the primary type (extends an Iterable (of the primary key type and the primary value type)) Parameters source - T - the primary type value - V - the primary value type Returns V[] - an array (of the primary value type) Examples local points = { 0 , 10 , 3 , 0 , 5 } local nonZero = dash . without ( points , 0 ) nonZero -- {10, 3, 5} local ingredients = { veg = carrot , sauce = tomato , herb = basil } local withoutCarrots = dash . without ( ingredients , carrot ) withoutCarrots -- { tomato , basil } (in some order)","title":"without"}]}